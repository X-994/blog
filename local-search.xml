<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2024/10/28/ComNetworking/"/>
    <url>/2024/10/28/ComNetworking/</url>
    
    <content type="html"><![CDATA[<h1 id="概叙"><a href="#概叙" class="headerlink" title="概叙"></a>概叙</h1><h2 id="互联网概叙"><a href="#互联网概叙" class="headerlink" title="互联网概叙"></a>互联网概叙</h2><h3 id="计算机网络的构成"><a href="#计算机网络的构成" class="headerlink" title="计算机网络的构成"></a>计算机网络的构成</h3><ul><li>计算机网络：<ul><li>由若干节点和连接这些节点的链路组成</li><li>节点可以是计算机、集线器、交换机或者路由器等</li></ul></li></ul><p>链路：是传递信息的通道<br><img src="/../img/ComNetworking/1.png"></p><ul><li>互联网：特指覆盖全球的，具有连通性和资源共享的计算机网络<ul><li>多个网络通过一些路由器互相连接起来，构成一个覆盖范围更大的计算机网络</li><li>网络的网络</li></ul></li></ul><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><h4 id="边缘部分："><a href="#边缘部分：" class="headerlink" title="边缘部分："></a>边缘部分：</h4><p>描述：由所有连接在互联网上的主机(端系统）组成，由用户直接使用，用来进行通信（传送数据、音频或视频）和资源共享</p><ul><li>终端系统不负责数据的转发(桌面计算机，移动计算机，服务器，其他智能终端设备)</li></ul><p><img src="/../img/ComNetworking/2.png"><br>计算机之间的通信：主机A的某个进程和主机B上的另外一个进程行通信</p><p>端系统之间的通信方式</p><ul><li>客户&#x2F;服务器方式(C&#x2F;S方式)<ul><li>进程之间的服务和被服务的关系<br><img src="/../img/ComNetworking/3.png"></li><li>通信可以是双向的，客户和服务器都可发送和接受数据</li><li>客户程序<ul><li>被用户<strong>调用运行</strong>，需<strong>主动</strong>向远地服务器发起通信。必须知道服务器程序的地址</li><li>不需要特许的硬件和很复杂的操作系统</li></ul></li><li>服务器程序<ul><li>专门用来提供方某种服务的程序，可同时处理多个客户请求</li><li>一直<strong>不断运行着，被动等待</strong>并接受来自各地的用户的通信请求，不知道客户程序的地址</li><li>需要强大的硬件和高级操作系统支持</li></ul></li></ul></li><li>对等方式(P2P方式)<ul><li>两台主机在通信时不区分服务请求方和服务提供方</li><li>只要都运行P2P软件，就可以进行平等的，对等连接通信</li><li>从本质来看依旧是<strong>使用客户服务器方式</strong><br><img src="/../img/ComNetworking/4.png"></li></ul></li></ul><h4 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分:"></a>核心部分:</h4><p>描述：由大量网络和连接这些网络的路由器组成，为边缘部分提供服务（提供连通性和交换）</p><ul><li>是互联网中最复杂的部分</li><li>向网络边缘中的主机<strong>提供连通性</strong>，使任何一台主机都能够向其他主机通信</li><li>在网络核心部分起特殊作用的是<strong>路由器</strong></li><li>路由器是实现<strong>分组交换</strong>的关键构建，其任务是<strong>转发</strong>收到的分组。<strong>分组转发</strong>是网络核心部分的最重要的功能</li></ul><p><img src="/../img/ComNetworking/5.png"></p><ul><li>典型交换技术<ul><li>电路交换<ul><li>每一个电话都直接连接到交换机上，而交换机使用交换的方法，让电话用户彼此之间还可以很方便地通信<br><img src="/../img/ComNetworking/6.png"></li><li><strong>转换地含义是转接</strong>，是按照某种方式动态分配传输线路地资源</li><li>分为三个阶段<ul><li>建立连接(占用通信资源)</li><li>通话(一直占用通信资源)</li><li>释放连接(归还通信资源)</li></ul></li><li>通话地两个用户始终占用端到端地通信资源<br><img src="/../img/ComNetworking/7.png"></li><li>计算机数据<strong>具有突发性</strong>，通信线路利用率很低</li></ul></li><li>分组交换<ul><li>采用<strong>存储转发</strong>技术<br><img src="/../img/ComNetworking/8.png"><ul><li>数据段前面添加首部构成分组<br><img src="/../img/ComNetworking/9.png"></li></ul></li><li>互联网采用分组交换技术，分组交换以“<strong>分组</strong>”作为数据传输单元</li><li>分组在<strong>互联网中传送</strong>的数据单元</li><li>发送端<strong>依次</strong>把各分组发送到接收端<ul><li>接收端收到分组后剥去首部，还原成原来的报文</li></ul></li><li>分组在互联网中的转发<ul><li>根据<strong>首部</strong>中包含的目的地址、源地址等重要控制信息进行转发</li><li>每一个分组在互联网中<strong>独立选择</strong>传输路径</li><li>位于网络核心部分<strong>路由器负责转发分组</strong>，即分组交换</li><li>路由器要创建和动态维护<strong>转发表</strong><br><img src="/../img/ComNetworking/10.png"></li></ul></li><li>每个分组独立选择传输路径<br><img src="/../img/ComNetworking/11.png"></li><li>优点<br><img src="/../img/ComNetworking/12.png"></li><li>缺点<br><img src="/../img/ComNetworking/13.png"></li></ul></li><li>报文交换<ul><li>基于存储转发原理的报文交换</li><li>时延较长，从几分钟到几小时不等</li><li>现在 很少人使用</li></ul></li><li>主要区别<br><img src="/../img/ComNetworking/14.png"></li></ul></li><li>互联网的核心部分采用<strong>分组交换技术</strong></li></ul><h2 id="网络的定义、分类以及性能"><a href="#网络的定义、分类以及性能" class="headerlink" title="网络的定义、分类以及性能"></a>网络的定义、分类以及性能</h2><h3 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h3><ul><li>主要是由一些通用的，可编程的硬件互连而成的，而这些硬件并非专门实现某一特定目的(传输数据或视频信号等)这些可编程的硬件能够用来传送多种<strong>不同类型的数据</strong>，并能支持广泛的和日益增长的应用</li><li>“可编程硬件”表明：这种硬件一点包含有中央处理器CPU</li><li>计算机网络所连接的硬件包括：</li><li>一般的计算机</li><li>智能手机，电视</li><li>计算机网络还可以<ul><li>传送数据</li><li>资源共享</li><li>支持多种应用</li></ul></li></ul><h3 id="计算机分类"><a href="#计算机分类" class="headerlink" title="计算机分类"></a>计算机分类</h3><ul><li>按照网络作用范围<br><img src="/../img/ComNetworking/15.png"></li><li>按照网络使用者<br><img src="/../img/ComNetworking/16.png"></li><li>用来把用户接入互联网的网络<br><img src="/../img/ComNetworking/17.png"></li><li>拓扑结构<ul><li>根据网络设备的连接关系</li></ul></li></ul><h3 id="计算机网络性能"><a href="#计算机网络性能" class="headerlink" title="计算机网络性能"></a>计算机网络性能</h3><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p><img src="/../img/ComNetworking/18.png"></p><ul><li>速率<ul><li><strong>比特成为信息中的基本单位</strong> </li><li>速率是指<strong>数据传送速率</strong>，也称为<strong>数据率</strong>或<strong>比特率</strong>，在理想状态下，一定时间内网络信息能通过最大数据量</li><li>单位：bit&#x2F;s,kbit&#x2F;s,Mbit&#x2F;s,Gbit&#x2F;s等</li><li>速率往往是指<strong>额定速率</strong>或<strong>标称速率</strong>，非实际运行速率</li></ul></li><li>带宽</li><li>频域<ul><li>某个信道具有的频带宽度</li><li>单位是赫</li><li>某通信道允许通过的信号频带范围称为该信道的带宽</li></ul></li><li>时域<ul><li>网络中某通道传送数据的能力，表示单位时间内网络中的某信道等通过的”最高数据率”</li><li>单位就是数据率的单位bit&#x2F;s</li></ul></li><li>吞吐量 <ul><li>单位时间内通过某个网络的实际数据量</li><li>受网络的带宽或者网络的额定速率限制<ul><li>额定速率是绝对上限值</li><li>可能会远小于额定速率，甚至下降道零</li></ul></li></ul></li><li>时延<ul><li>数据(一个报文或者分组，甚至比特)从网络(或链路)的<strong>一端传送到另外一段所需</strong>的时间 </li><li>包括 总时延(单边) &#x3D; 发生时延 + 传播时延 + 处理时延 + 排队时延<ul><li>发生时延<ul><li>主机或路由器发生数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间</li><li>发生时延&#x3D;数据帧长度(bit) &#x2F; 发送速率(bit&#x2F;s)</li><li>发生在机器内部的发送器中，与传输信道的长度(或信号传输的距离)没有任何关系</li></ul></li><li>传播时延<ul><li>电磁波在信道中传播一定的距离需要花费的时间</li><li>传播时延&#x3D;信道长度(m) &#x2F; 信号在信道上的传播速率(m&#x2F;s)</li><li>发送在机器外部的传输信道媒体上，而与信号的发送速率无关。信号传送的距离越远，传播时延就越大</li></ul></li><li>处理时延<ul><li>主机或路由器在收到分组时，为处理分组所花费的时间</li></ul></li><li>排队时延<ul><li>分组在路由器输入输出中排队等待处理和转发所经历的时延</li><li>取决于网络中当时的通信量，当通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延为无穷大</li></ul></li><li>在总时延中，究竟是哪一种时延占主导地位，必须具体分析</li><li>在高速网络链路，我们<strong>提高的仅仅是数据的发生速率</strong>，而不是比特在链路上的传播速率</li><li>提高数据的发生速率<strong>只是减小了数据的发生时延</strong></li></ul></li><li>时延带宽积 <ul><li>时延带宽积 &#x3D; 传播时延*带宽，即比特计数的链路长度 </li><li>管道中的比特数表示从发生端发生但尚未到达接收端的比特数</li><li>只有在代表链路的管道都充满比特时，链路才得到了充分利用</li></ul></li><li>往返时间RTT<ul><li>表示发送方发送完数据，到发送方收到来自接收方的确认共经历的时间</li><li>有效数据率 &#x3D; 数据长度&#x2F;(发送时间 + RTT)</li></ul></li><li>利用率<ul><li>信道利用率是指某信道有百分之几的时间是被利用的(有数据通过)。完全空闲的信道的利用率就是零 </li><li>网络利用率是指网络的信道利用率的加权平均值</li><li>根据排队论，当某信道利用率增大时，时延会迅速增加<br><img src="/../img/ComNetworking/19.png"></li></ul></li></ul></li></ul><h4 id="非性能指标"><a href="#非性能指标" class="headerlink" title="非性能指标"></a>非性能指标</h4><p><img src="/../img/ComNetworking/20.png"></p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>网络体系结构时计算机网络的各层一期协议的<strong>集合</strong>，就时这个计算机以其构件所应完成的<strong>功能的精确定义</strong></p><ul><li>网络协议(协议)<ul><li>描述:为进行网络中的数据交换而建立的规则，标准或约定</li><li>三个组成要素<ul><li>语法：规定传输数据的格式，解决交换信息的格式问题</li><li>语义：规定所要完成的功能，解决做什么的问题</li><li>同步：规定各种朝左的顺序，又称作时序，解决什么时间什么条件下做什么特定操作的问题</li></ul></li><li>两种形式<ul><li>文字描述：便于人来阅读和理解</li><li>程序代码：让计算机能够理解</li></ul></li><li>特点<ul><li>必须遵守</li><li>非常复杂，无法十全十美</li></ul></li></ul></li></ul><h3 id="分层体系"><a href="#分层体系" class="headerlink" title="分层体系"></a>分层体系</h3><h4 id="层次间的关系-水平、垂直"><a href="#层次间的关系-水平、垂直" class="headerlink" title="层次间的关系(水平、垂直)"></a>层次间的关系(水平、垂直)</h4><ul><li>分层原则：<ul><li><img src="/../img/ComNetworking/21.png"></li></ul></li><li>各层至少要完成以下功能<ul><li>差错控制：使对应层次对等方的通信更加可靠</li><li>流量控制：发送端的发送速率必须使接收端来的及接受，不要太快</li><li>分段和重装：将发送端将要发送的数据块划分为更小的单位，接受端还原</li><li>复用和分用：发送端几个高层会话复用一条低层的连接，在接收端再进行分配</li><li>连接建立和释放：交换数先建立一条<strong>逻辑连接</strong>，数据传送结束后释放数据连接<br><img src="/../img/ComNetworking/22.png"></li></ul></li></ul><h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><ul><li>优点<br> <img src="/../img/ComNetworking/23.png"></li><li>缺点<ul><li>降低效率</li><li>有些功能会在不同层次中重复出现，因此产生额外的开销</li></ul></li></ul><h4 id="不同层次体系模型"><a href="#不同层次体系模型" class="headerlink" title="不同层次体系模型"></a>不同层次体系模型</h4><ul><li>OSI 7层模型(法律上的国际标准)<br><img src="/../img/ComNetworking/24.png"></li><li>TCP&#x2F;IP(事实上的国际标准)<br><img src="/../img/ComNetworking/25.png"><br><img src="/../img/ComNetworking/26.png"></li><li>五层协议体系结构(讲述原理的体系结构)<br><img src="/../img/ComNetworking/27.png"></li></ul><h4 id="五层体系各层的名称和功能"><a href="#五层体系各层的名称和功能" class="headerlink" title="五层体系各层的名称和功能"></a>五层体系各层的名称和功能</h4><ul><li>应用层<br><img src="/../img/ComNetworking/28.png"></li><li>运输层<br><img src="/../img/ComNetworking/29.png"></li><li>网络层<br><img src="/../img/ComNetworking/30.png"></li><li>数据路层<br><img src="/../img/ComNetworking/31.png"></li><li>物理层<br><img src="/../img/ComNetworking/32.png"></li></ul><p><img src="/../img/ComNetworking/33.png"></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>实体：表示任何可发送或接受信息的硬件或软件进程</li><li>协议：控制两个对等实体进行通信的规则的集合</li><li>服务：在协议的控制下，两个对等实体的通信使的本层能够向上一层提供服务。要实现本次协议，还需要下层提供的服务</li><li>服务访问点SAP：在同一系统中相邻两层的实体进行交互(交换信息)，它实际上是一个<strong>逻辑接口</strong></li><li>服务是垂直的(上层使用服务原语获得下册所提供的服务)，协议是水平的<br><img src="/../img/ComNetworking/34.png"></li></ul><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="概念和功能"><a href="#概念和功能" class="headerlink" title="概念和功能"></a>概念和功能</h2><ul><li>位置：网络体系结构最底层(逻辑概念)<ul><li>不是具体传输媒体，也不是连接计算机的具体物理设备</li></ul></li><li>功能：如何在连接各种计算机的传输媒体上的<strong>传输数据比特流</strong><ul><li>数据链路层将比特流传送给物理层</li><li>物理层将比特流按照传输传媒的需要进行编码</li><li>然后将信号通过传输媒体传输到下一个节点的物理层</li></ul></li><li>作用：尽可能屏蔽掉不同传媒体和通信手段的差异<ul><li>为数据链路层提供一个统一的数据传输服务</li></ul></li><li>用于物理层的协议也称为物理层规程</li><li>主要任务：确定与媒体的接口有关的一些特性</li><li><img src="/../img/ComNetworking/35.png" alt="接口"></li><li>物理层协议是DTE和DCE的约定，规定了标准化的DTE&#x2F;DCE皆有具有的特性<ul><li><strong>机械特性</strong>:接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置</li><li><strong>电气特性</strong>:在接口电缆的各线路的电气连接以及有关电路特性例如电压范围，阻抗，传输速率等</li><li><strong>功能特性</strong>:指明某条线上出现的某一电平的电压的意义，定义接线器的每一引脚(针)的作用<br><img src="/../img/ComNetworking/36.png"></li><li><strong>过程特性</strong>:指明对于不同功能的各种事件的出现顺序</li></ul></li></ul><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><ul><li><p>三大部分：源系统(或发送端，发送方)、传输系统(或传输网络)和目的系统(或接收端，接收方)<br><img src="/../img/ComNetworking/37.png"></p></li><li><p>数据通信常用术语</p><ul><li>通信是在源点与终点之间传递消息或信息，但信息和消息有着不同的概念 </li><li><strong>信息</strong>是指向人们表达客观物质运动和主观思维活动的文字、符号、数据、语音和图像等<ul><li>能被通信双方所理解</li><li>可以相互传递</li></ul></li><li><strong>信息</strong>是指包含在信息中对通信者有意义的那部分内用，<strong>消息是信息的载体</strong></li><li>数据是对某一事实的不经解释并赋予一定含义的数字、字母、文字等符号以其组合的原始表达，是运送信息的实体，分为模拟数据和数字数据</li><li>信号是信息的载体(比如电信号，光信号等)，是数据的电气的或电磁的表现<ul><li>在通信系统中，信息是通过电信号来传递的，电信号具有模拟信号和数字信号</li></ul></li></ul></li><li><p>有关信道的几个基本概念</p></li><li><p>信道：信号传输的通道，按照数据信号在信道上的传送方向与时间的关系，传输方式可分为三类：</p><ul><li>**单向通信(单工通信)**：只有一个方向的通信，没有反方向的交互</li><li><strong>双向交替(半双工通信)</strong>:通信的双方都可以发送信息，但双方不能同时发送</li><li><strong>双向同时通信(全双工通信)</strong>:通信的双方可以同时发送和接受信息</li></ul></li><li><p>基带信号(即基本频信号)</p></li><li><p>信号源发出没有的经过调制的原始信号</p></li><li><p>包含有较多的低频成分，基本有直流成分</p></li><li><p>调制：让信号可以在相应信道中传输<br><img src="/../img/ComNetworking/38.png"><br><img src="/../img/ComNetworking/39.png">  </p></li><li><p>常用编码方式<br><img src="/../img/ComNetworking/40.png"><br><img src="/../img/ComNetworking/41.png"></p><ul><li>信号频率：<ul><li>曼切斯特编码是差分曼切斯特编码产生的信号频率不比不归零制高</li></ul></li><li>自同步能力：<ul><li>不归零制不能从信号波形本身中提取信号钟频率(没有自同步能力)</li><li>曼彻斯特编码和差分曼彻斯特编码<strong>具有自同步能力</strong></li></ul></li></ul></li><li><p>基本的带通调制方法</p></li><li><p>基带信号往往包含有较多的低频成分，甚至直流成分，而许多信道并不能传输这种低频分量或直流分量</p></li><li><p>必须对基带信号进行调制</p></li><li><p>最基本的调制方法有以下几种</p><ul><li>调幅(AM):载波的振幅随基带数字信号而变化</li><li>调频(FM):载波的频率随 基带数字信号而变化</li><li>调相(PM):载波的初始相位随基带数字信号而变化<br><img src="/../img/ComNetworking/42.png"></li></ul></li></ul><h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><ul><li>传输媒体是数据传输系统中在发送器和接收器之间的物理通路</li><li>两大类<ul><li>导引型传输媒体:电磁波导引沿着固体媒体传播</li><li>非导引型传输媒体:自由空间。非导引型传输媒体中电磁波的传输常称为无线传输</li></ul></li></ul><h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><p><img src="/../img/ComNetworking/43.png"><br><img src="/../img/ComNetworking/44.png"><br><img src="/../img/ComNetworking/45.png"></p><h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><p><img src="/../img/ComNetworking/46.png"><br>微波接力：远距离微波通信，中继站把前一站送来的信号放大再发送到下一站</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ul><li>为什么要信道复用<ul><li>信道资源是有限的，实际网络中，多对用户往往需要利用相同的信道资源传输信息</li><li>不同的信号同时在一个信道中传输会产生严重互相干扰，导致传输失败</li></ul></li><li>什么是信道复用<ul><li>多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高信道利用率</li><li>允许用户使用一个共享信道进行通信，降低成本，提高利用率</li></ul></li><li>频分复用<br><img src="/../img/ComNetworking/47.png"><br>可让N个用户各使用一个频带，或让更多的用户轮流使用这个N个频带。这种方式成频分多址接入FDMA,简称为频分多址</li><li>时分复用<br><img src="/../img/ComNetworking/48.png"><br>可让N个用户各使用一个时隙，或让更多的用户轮流使用这个N个时隙。这种方式成频分多址接入TDMA,简称为时分多址<ul><li>由于数据具有突发性，时分复用会导致信道利用率不高</li></ul></li><li>统计时分复用<br><img src="/../img/ComNetworking/49.png"></li><li>光分复用<br><img src="/../img/ComNetworking/50.png"></li><li>码分复用<br><img src="/../img/ComNetworking/51.png"></li></ul><blockquote><p><strong>物理层解决了相邻结点透明传输比特的问题</strong></p></blockquote><h1 id="数据链路链路层"><a href="#数据链路链路层" class="headerlink" title="数据链路链路层"></a>数据链路链路层</h1><h2 id="概叙-1"><a href="#概叙-1" class="headerlink" title="概叙"></a>概叙</h2><ul><li>什么是数据链路<ul><li>链路是结点间的物理通道，无源的物理线路，中间无任何其他交换结点</li><li>数据链路是节点间的逻辑通道，是实现控制数据传输的协议的硬件和软件加到链路上，即链路+协议</li><li>数据链路层：负责通过一条链路从一个结点向物理链路直接相连的相邻结点传送帧<br>帧：链路层协议数据单元，封装网络层的数据报</li></ul></li><li>数据链路层不必考虑物理层如何*<em>实现比特传输的细节</em></li><li>数据链路层信道类型</li><li>点对点信道(一对一)</li><li>广播信道(一对多)</li></ul><h2 id="解决三个基本问题"><a href="#解决三个基本问题" class="headerlink" title="解决三个基本问题"></a>解决三个基本问题</h2><ul><li>封装成帧<ul><li>在前后一段数据的前后分别添加首部和尾部，构成一个帧</li><li>首部和尾部一个重要的作用就是帧定界</li><li>将比特流分成”帧”的主要目的是为了检测和纠正物理层在比特传输中可能出现的错误<br><img src="/../img/ComNetworking/52.png"></li><li>如何标识一个帧的开始<ul><li>接收方必须能从物理层接受的比特流中明确区分出一帧的开始和结束</li><li>选择何种定界符？定界符出现的数据部分如何处理？<br>成帧的方式</li><li>字节计数法<ul><li>无差错传输的情形<br><img src="/../img/ComNetworking/53.png"></li></ul></li><li>带<strong>字节</strong>填充的定界符法<br><img src="/../img/ComNetworking/54.png"></li><li>带<strong>比特</strong>填充的定界符法</li><li>物理层编码违例</li></ul></li></ul></li><li>透明传输<ul><li>透明：指某一个实际存在的事物看起来却好像不存在一样</li><li>“在数据链路层透明传送数据”表示：无论送什么样的比特组合的数据，这些数据都能按照原样<strong>没有差错</strong>地通过这个数据链路层</li><li>发送方采用”字节填充”或”字符填充”法(异步)<br><img src="/../img/ComNetworking/55.png"><br><img src="/../img/ComNetworking/56.png"></li></ul></li><li>差错控制<br><img src="/../img/ComNetworking/57.png"><br>传输错误的比特占所传输总数的比率称为误码率BER，与信噪比有关。<ul><li>数据链路层需要进行差错检验<ul><li>纠错码：检测到错误的就纠正，主要用于错误发生比较频繁信道，如无线链路</li><li>检错码：一出错就丢掉数据，主要用在高可靠，错码率较低的信道，例如光纤链路<br><img src="/../img/ComNetworking/58.png"></li><li><img src="/../img/ComNetworking/59.png"></li><li>数据后面添加的冗余码称为帧检验序列FCS</li><li>CRC循环冗余校验不可以实现数据的可靠传输<blockquote><ul><li>无比特差错与无传输差错是不同的</li><li>可靠传输：链路层的发送端发送什么，在接收端就收到什么</li><li>传输差错可以分为：<ul><li>比特差错</li><li>传输出错：帧丢失，帧重复或帧失序等</li></ul></li><li>在数据链路层使用CRC检验，能实现五比特差错的传输但这还不是可靠传输</li><li><strong>要做到可靠传输，还必须加上帧编号、确认和重传等机制</strong></li></ul></blockquote></li></ul></li></ul></li></ul><h2 id="点对点协议PPP-广域网"><a href="#点对点协议PPP-广域网" class="headerlink" title="点对点协议PPP(广域网)"></a>点对点协议PPP(广域网)</h2><ul><li>满足的需求<ul><li>简单</li><li>能够承载不同的网络层分组</li><li>能够在多种类型的链路上运行</li><li>封装成帧</li><li>透明传输–字节填充、零比特填充</li><li>差错检测</li><li>实施监测链路工作状态</li><li>设置链路最大传送单元MTU</li><li>网络层地址协商机制– 必须提供一种机制是通信的额两个网络层实体能够协商知道或配置彼此的网络层地址</li><li>数据压缩协商机制、</li></ul></li><li>PPP协议组成</li><li>一种将IP数据报封装到同步(零比特填充)&#x2F;异步(字节填充)串行链路的方法</li><li>链路控制协议LCP<ul><li>用来建立、配置和测试数据链路的链路控制协议，通信双方可协商一些选项，最重要的功能之一是身份验证</li></ul></li><li>网络控制协议NCP<ul><li>其中每个协议支持一种不同的网络层协议，如IP、OSI的网络层<br><img src="/../img/ComNetworking/60.png"></li></ul></li><li>PPP协议的状态图<br><img src="/../img/ComNetworking/61.png"></li></ul><h2 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h2><ul><li><p>局域网最主要的特点</p><ul><li>具有广播功能，从一个站点可很方便地访问全网</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变</li><li>提高系统的可靠性、可用性和生存性</li></ul></li><li><p>问题：可能两个(或更多)站点同时请求占用信道</p></li><li><p>解决方法：介质多路访问控制，在多路访问上确定下一个使用者</p></li><li><p>怎么介质访问控制</p><ul><li>静态分配<ul><li>频分复用、时分复用、波分用、码分复用 </li><li>适用于通信量大且流量稳定的情况、用户数量少且用户数固定</li><li>代价高，不适合突发性业务，不是个局域网</li></ul></li><li>动态分配<ul><li>随机接入：所有用户可随机地发送信息(以太网)</li><li>受控接入：用户必须服从一定的控制。如轮询</li></ul></li></ul></li><li><p>适配器的作用<br><img src="/../img/ComNetworking/62.png"></p><ul><li>重要功能 <ul><li>进行串行&#x2F;并行转换</li><li>对数据进行缓存</li><li>在计算机的操作系统安装设备驱动程序</li><li>实现以太网协议</li></ul></li></ul></li><li><p>以太网采取2种重要措施</p><ul><li>采用较灵活的无连接的工作方式<ul><li>不必先建立连接就可以直接发送数据</li><li>对发送的数据帧不进行编号，也不要求对方发回确认</li><li>提供不可靠，尽最大可能的交付服务</li><li>差错帧是否重传由高层决定</li></ul></li><li>发送的数据都使用曼彻斯特编码，便于同步</li></ul></li><li><p>CSMA&#x2F;CD协议(先听后发，边听边发，冲突停止，延迟重发)</p><ul><li>载波监听多点接入&#x2F;碰撞测试</li><li><strong>多点接入</strong>：说明这是总线型网络。许多计算机以多点接入的方式连接在一根总线上</li><li><strong>载波监听</strong>：即”边发送边监听”。不管在想要发送数据之前，还是在发送数据之中，每个站都必须不停地检测信道</li><li><strong>碰撞检测</strong>：适配器边发送数据，边检测信道上地信号电压变化情况。电压摆动超出一定地门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞</li><li>检测到碰撞后：<ul><li>适配器立即停止发送(碰撞点后面地已发信号会一直叠加)</li><li>等待一段随机时间后再次发送(避免再次冲突)</li></ul></li></ul></li></ul><blockquote><p>Q1:既然发送已监听过信道，为什么要进行碰撞检测</p></blockquote><p>因为信号有传播时延，监听信道空闲，但信道可能并非真正空闲<br>每一个站在自己发送数据未到终点之前，都存在着碰撞地可能性</p><blockquote><p>Q2:发送数据后，至少要在多少时间内收到数据才能说明没有碰撞</p></blockquote><p><img src="/../img/ComNetworking/63.png"></p><blockquote><p>Q3:经过争用期这段时间还没有检测到碰撞，就能肯定这次发送不会发生碰撞嘛</p></blockquote><p>是的</p><blockquote><p>Q4:碰撞后什么时候重传</p></blockquote><p>采用截断二进制指数退避确定<br><img src="/../img/ComNetworking/64.png"></p><ul><li><p>使用集线器的星形拓扑</p><ul><li>传统以太网传输媒体：粗同轴电缆-&gt;细同轴电缆-&gt;双绞线</li><li>使用双绞线的以太网采用星形拓扑</li><li>在星形的中心则增加一种可靠性非常高的设备，叫做集线器</li></ul></li><li><p>集线器一些特点</p><ul><li>使用集线器的以太网<strong>在逻辑上仍是一个总线网</strong>，只是使用电子器件来模拟实际电缆的工作</li><li>仍然是<strong>共享信道</strong>，各工作站使用的还是CSMA&#x2F;CD协议，并共享逻辑上的总线</li><li><strong>工作在物理层</strong></li><li>采用专门芯片，进行自适应串音回波抵消，减少了近端串音</li></ul></li><li><p>MAC层</p><ul><li>又称为<strong>物理地址</strong>，或<strong>MAC地址</strong></li><li>IEEE 802标准为局域网规定了一种48位的全球地址(简称为地址)是指局域网上的每一台计算机<strong>固化在适配器的ROM中的地址</strong></li><li>每一个适配器都有一个MAC地址，相当于它的标识符，与其所处的位置无关</li><li><strong>局域网上的每一个接口都有一个MAC地址(48bit)</strong><br><img src="/../img/ComNetworking/65.png"></li><li>分类<br><img src="/../img/ComNetworking/66.png"></li><li>适配器每收到一个MAC帧，先用硬件检查帧中的MAC地址</li><li>如果是发往本站的帧则收下，然后再进行其他的处理</li><li>否则就将此帧丢失，不再进行其他的处理</li><li>最常见的MAC帧是<strong>以太网V2的格式</strong><br><img src="/../img/ComNetworking/67.png"></li></ul></li></ul><h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><p>物理层扩展</p><ul><li>使用光纤扩展</li><li>使用集线器扩展<ul><li>碰撞域(冲突域):指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络<br><img src="/../img/ComNetworking/68.png"></li></ul></li></ul><p>数据链路层扩展</p><ul><li>更为常用</li><li>早期使用<strong>网桥(信道全双工)<strong>，现在使用以太网</strong>交换机</strong></li><li>网桥根据MAC帧的目的地址对收到的帧进行转发和过滤。或者转发、或者丢弃<br><img src="/../img/ComNetworking/69.png"></li><li>以太网交换机的特点<ul><li>实质上是一个<strong>多接口网桥</strong><ul><li>通常有十几个或更多的接口</li></ul></li><li>每个接口都直接与一个单台主机或另一个以太网交换机相连，并且都工作在<strong>全双工</strong>方式</li><li>并行性<ul><li>能同时连通多对接口，使多对主机能同时通信</li><li>相互通信的主机都独占传输媒体，无碰撞地传输数据</li><li>每一个端口和连接到端口的主机构成一个碰撞域<br><img src="/../img/ComNetworking/70.png">  </li><li>接口有存储器</li><li><strong>即插即用</strong>。内部的帧<strong>交换表</strong>(地址表)是通过<strong>自学习算法</strong>自动地逐渐建立起来的<ul><li>自学习功能<br><img src="/../img/ComNetworking/71.png"></li></ul></li><li>使用专用的交换结构芯片，用硬件转发，其转发率要比使用软件转发的网桥快很多</li><li>每个接口用户独享带宽，增加总容量<ul><li>支持多种速率接口</li><li>支持多类型接口</li></ul></li></ul></li></ul></li><li>多台以太网交换机互连<ul><li><strong>回路会带来什么问题</strong><ul><li>广播不断循环，造成广播风暴，造成资源浪费，极大降低网络效率</li></ul></li><li>解决环路<ul><li>使用生成树协议(STP)<ul><li><strong>不改变</strong>网络的实际拓扑，但<strong>在逻辑上</strong>则切断某些链路(阻塞接口)，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象</li></ul></li></ul></li></ul></li></ul><h2 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h2><ul><li>广播域<ul><li>指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接受</li><li>一个以太网是一个广播域</li></ul></li><li>虚拟局域网定义：<ul><li>是由一些局域网网段构成的<strong>与物理地位无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个VLAN</li></ul></li><li>虚拟局域网其实只是局域网个用户提供一种服务，并不是一种新型局域网</li><li>VLAN是一个在物理网络上根据用途，工作组，应用等来<strong>逻辑划分</strong>的局域网络，与网络的物理位置没有关系</li><li>每一个VLAN是一个广播域</li><li>一台主机发出的广播包，只能在VLAN中传播</li><li>主要优点<ul><li>便于网络管理，具有相似需求的用户共享一个VLAN</li><li>增加网络的安全性，敏感用户与普通用户隔离</li><li>减少了不必要的网络流量</li><li>限制了广播报文的洪泛，抑制广播风暴</li><li>减少网络拓扑变更成本</li><li>降低计算机CPU的开销</li></ul></li></ul><h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><ul><li>100BASE-T 以太网<ul><li>又称为<strong>快速以太网</strong></li><li>在双绞线上传送100Mbit&#x2F;s基带信号的星形拓扑以太网</li><li>仍使用IEEE 802.3的CSMA&#x2F;CD协议</li><li>特点<ul><li>可在全双工方式下工作而无冲突发生</li><li>在全双工方式下工作时，不使用CMSA&#x2F;AD协议</li><li>使用IEEE 802.3的协议规定的MAC帧格式</li><li>保持最短帧长不变，但将一个网络的最大电缆长度减小到100米</li></ul></li></ul></li><li>吉比特以太网<ul><li>允许在1Gbit&#x2F;s下以全双工和半双工2种方式工作</li><li>仍使用IEEE 802.3的MAC帧格式</li><li>在<strong>半双工</strong>方式下使用CSMA&#x2F;CD协议，而在<strong>全双工</strong>方式不适用CSMA&#x2F;CD协议</li><li>与10BASE-T和100BASE-T技术向后<strong>兼容</strong></li></ul></li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><ul><li>为什么要网络层<ul><li>数据链路层解决了同一局域网计算机间帧的传输问题，但没有解决<strong>异构网络之间的连接和资源共享</strong>问题<ul><li>异构网络互联，即跨局域网连接和资源共享</li><li>互联网网络中主机标识问题</li><li>互联网中主机路由选择问题(最佳路径)</li><li>互联网中数据转发的问题(分组转发)</li><li>网络层要向传输层提供面向连接的服务，还是无连接的服务(在计算机通信中，可靠交付应当<strong>网络负责</strong>还是<strong>端系统负责</strong>)<ul><li>让网络负责可靠交付(虚电路服务)<ul><li><img src="/../img/ComNetworking/72.png"></li><li>链路中任何一个组成环节仍有可能失效，而这种失效是严重的，可能会导致所有数据丢失</li></ul></li><li>网络提供数据报服务(数据报服务)<ul><li><img src="/../img/ComNetworking/73.png"></li><li>网络层不提供服务质量的承诺，即所传送的分组可能会出错、丢失、重复和失序(不按序到达终点)，也不保证分组传送的时限</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><ul><li>虚拟互联网(IP网)<ul><li>概念：逻辑互联网络，使用路由器解决各种异构的物理网络连接在一起的问题。使用IP协议的虚拟互连网络简称为IP网</li><li>中间设备又称为中间系统或中继系统<br><img src="/../img/ComNetworking/74.png"></li></ul></li><li>网际协议IP<ul><li><img src="/../img/ComNetworking/75.png"></li><li>IP地址就是给每个连接在互联网上的主机或路由器的<strong>每一个接口</strong>分配的<strong>全球唯一的标识符</strong></li><li>IP地址是32位的二进制地址，采用2级结构<ul><li>IP地址::&#x3D;{&lt;网络号&gt;,&lt;主机号&gt;}</li><li>IP地址管理机构负责分配网络号，单位负责分配主机号，方便IP地址管理</li><li>路由器根据网络号将分组转发到对应网络，大大减小路由表项目数，减少存储空间占用，提高效率</li><li><img src="/../img/ComNetworking/79.png"></li><li><img src="/../img/ComNetworking/80.png"></li><li><img src="/../img/ComNetworking/81.png"></li></ul></li><li>子网划分</li><li><img src="/../img/ComNetworking/80.png"></li><li>划分子网是单位内部的事情:在网络内部将一个网络块进行划分多个内部网络使用，对外仍是一个网络</li><li>子网掩码，与IP地址一一对应，是32bit的二进制数，置1表示网络位，置0表示主机位</li><li><strong>IP地址</strong>和<strong>子网掩码</strong>进行<strong>与</strong>运算得到<strong>子网网络地址</strong></li><li>分类的IP地址的优点和缺点<ul><li><img src="/../img/ComNetworking/83.png"></li></ul></li><li>无分类编制方法CIDR<ul><li><img src="/../img/ComNetworking/84.png"> </li><li>斜线记法：IP地址&#x2F;n(前面有多少位是网络前缀)  IP地址 AND运算 掩码 -&gt;该地址的网络前缀</li><li><img src="/../img/ComNetworking/85.png"></li><li>一个CIDR地址块可以表示很多地址，多个较小地址块也能构成一个更大地址块，称为<strong>构成超网</strong>，又称为<strong>路由聚合</strong></li><li>路由聚合可以减少路由条目，但<strong>CIDR无法解决地址空间不足的问题</strong></li></ul></li></ul></li><li>IP数据报<ul><li>IP数据报由首部(20字节)和数据两部分组成<br> <img src="/../img/ComNetworking/76.png"></li><li>版本：占4位，指IP协议的版本，目前的IP协议版本号位4(即IPv4)</li><li>首部长度：占4位，可表示的最大数值是15个单位(一个单位为4字节)，因此IP的首部的长度最大值是60字节</li><li>总长度：占16位，指首部和数据之和的长度，单位为字节，因此数据包的最大长度为65535字节，数据链路层MTU会限制实际的IP数据报长度<br><img src="/../img/ComNetworking/77.png"></li><li>分片和重组需要用到标识、标志和片偏移三个字段<ul><li>标识：占16位，它是一个计数器，用来产生数据报的标识，不是序号，每产生一个数据包，就增加1</li><li>标志(flag)：占3位，标志字段的最低位为MF。MF&#x3D;1表示后面”还有分片”。MF&#x3D;0表示最后一个分片。标志字段中间的一位是DF，只有当DF&#x3D;0时才允许分片。</li><li>片偏移：占13位，指出较长的分组在分片后，某片在原分组中的相对位置，片偏移以8个字节为偏移单位<br><img src="/../img/ComNetworking/78.png"></li></ul></li><li>生存时间：数据报在网络当中可以通过路由器的最大数量，每经过一跳(TTL)，生存时间减一,<strong>防止了所有数据在网络上不停的跑</strong></li><li>协议：占8位，指出数据包携带的数据使用何种协议以便目的主机的IP层将数据部分上交给哪个处理过程</li><li>首部检验和：占16位，只检验数据包的首部，不检验数据部分，这里不采用CRC检验码而采用简单的计算方法</li><li>源地址和目标地址：各占4位，就是IP地址</li></ul></li><li>IP协议功能及报头字段总结<ul><li>网络层基本功能<ul><li>支持多跳寻路将IP数报送达目的端:<strong>目的IP地址</strong></li><li>表明发生端身份:<strong>源IP地址</strong></li><li>根据IP头部协议类型，提交给不同上层协议处理：<strong>协议</strong></li></ul></li><li>其他相关问题<ul><li>数据报长度大于传输链路的MTU的问题，通过分片机制解决:<strong>标识、标志、片偏移</strong></li><li>防止循环转发浪费网络资源(路由错误，设备故障),通过跳数限制解决:<strong>生存时间TTL</strong></li><li>IP报头错误导致无效传输，通过头部校验解决:<strong>首部校验和</strong></li></ul></li></ul></li></ul><h2 id="IP分组的转发"><a href="#IP分组的转发" class="headerlink" title="IP分组的转发"></a>IP分组的转发</h2><ul><li>基于终点的转发<ul><li>分组在互联网中是<strong>逐跳转发</strong>的，路由器通过查转发表确定下一跳</li><li>基于终点的转发：基于分部首部中的<strong>目的地址</strong>传送和转发</li><li>路由转发表中可能包含哪些信息<ul><li>目的网络地址，下一跳地址，掩码</li></ul></li><li>一个网络中可能有多个地址，为压缩路由表的大小，将”目的地址”变化为”目的网络地址”</li><li>查转发表的过程就是逐行寻找前缀匹配</li><li>主机路由<ul><li>又叫做特定主机路由</li><li>是对特定目的的主机的IP地址专门指明的一个路由</li><li>网络前缀就是a.b.c.d&#x2F;32</li><li>放在转发表的最前面</li></ul></li><li>默认路由<ul><li>不管分组的最终目的网络在哪里，都由指定的路由器R来处理</li><li>用特殊前缀0.0.0.0&#x2F;0表示</li><li>放在转发表的最后面</li></ul></li></ul></li><li>最长前缀匹配<ul><li>使用CIDR时，在查找转发表时可能会得到不止一个匹配结果</li><li>原则：选择前缀最长的一个作为匹配的前缀</li><li>网络前缀越长，其地址快就越小，因而路由就越具体</li><li>把前缀最长的排在转发表的第一行</li></ul></li></ul><p><img src="/../img/ComNetworking/86.png"></p><blockquote><p>受限广播地址(255.255.255.255)无法转发<br>但是直接广播地址(2.255.255.255&#x2F;8)是可以转发的</p></blockquote><ul><li>使用二叉线索查找转发表<br><img src="/../img/ComNetworking/87.png"></li><li>IP地址与MAC地址<br><img src="/../img/ComNetworking/88.png"><ul><li>区别<br><img src="/../img/ComNetworking/89.png"></li></ul></li><li>地址解析协议ARP<ul><li>实现IP通信时使用了两个地址<ul><li>IP地址(网络层地址)</li><li>MAC地址(数据链路层地址)</li></ul></li><li>作用：已知主机或路由器的IP地址，解析出其相应的MAC地址<ul><li>IP分组向下交给数据链路层</li><li>数据链路层需要通过MAC地址寻址，于是需要封装MAC地址</li><li>在不知道下接口MAC地址的情况下，就需要根据目的IP，解析目的MAC地址</li></ul></li><li>APR高速缓存<ul><li>存放IP地址到MAC地址的映射表</li><li>映射表动态更新</li><li>作用<br><img src="/../img/ComNetworking/90.png"><br><img src="/../img/ComNetworking/91.png"></li></ul></li></ul></li></ul><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><ul><li>概叙<ul><li>ICMP允许主机或路由器报告错误情况和提供有关异常报告</li><li>由主机和路由器用于网络层通信</li><li>ICMP是网络层的互联网标准协议</li></ul></li><li>ICMP报文格式<ul><li><img src="/../img/ComNetworking/92.png"></li><li><img src="/../img/ComNetworking/93.png"></li></ul></li><li>ICMP错误报告报文<br><img src="/../img/ComNetworking/94.png"></li><li>Traceroute和ICMP<br><img src="/../img/ComNetworking/95.png"></li><li>ICMP询问报文<br><img src="/../img/ComNetworking/96.png"></li><li>Ping和ICMP<ul><li>Ping用来检测两个主机之间的连通性</li><li>Ping使用了ICMP回送回答报文</li></ul></li></ul><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><ul><li>概叙<ul><li><img src="/../img/ComNetworking/97.png"></li></ul></li><li>IPv6的一般形式<ul><li><img src="/../img/ComNetworking/98.png"></li><li>基本首部<br><img src="/../img/ComNetworking/99.png"><ul><li><strong>版本</strong>：4位，指明协议的版本，IPv6字段是6</li><li><strong>通信量</strong>：8位，这是为了区分不同的IPv6数据报的类别或优先级</li><li><strong>流标号</strong>：20位，”流”是互联网上从特定源点到特定终点的一系列数据白，所属同一个流的数据报都具有同样的流标号。资源预分配时使用，对实时音频&#x2F;视频数据报的传送特别有用</li><li><strong>有效载荷长度</strong>：16位。指明了IPv6数据报除基本首部以外的字节数(k扩展首部+数据)</li><li><strong>下一个首部</strong>：8位，相当于IPv4的协议字段或可选字段，可能是TCP&#x2F;UDP&#x2F;ICMP等，也可能是扩展头</li><li><strong>跳数限制</strong>：8位，相当于IPv4的TTL，最大值255，为0时丢弃</li><li><strong>源地址</strong>：128位，是数据报的发送站的IP地址</li><li><strong>目的地址</strong>：128位，是数据报的接受站IP地址</li></ul></li><li>扩展首部<br><img src="/../img/ComNetworking/100.png"></li></ul></li><li>IPv6的地址<ul><li>每个地址占128位</li><li>三种基本类型<ul><li>单播：传统点对点通信</li><li>多播：一点对多点的通信</li><li>任播：IPv6增加的一种类型。任播的终点是一组计算机，但数据报在交付时只交付其中的一个。通常时按照路由算法得出的距离最近一个</li></ul></li><li>冒号十六进制记法<ul><li><img src="/../img/ComNetworking/101.png"></li><li>零压缩：一串连续的零可以用一对冒号(::)取代</li><li>在任一地址中，只能使用一次零压缩</li></ul></li><li>点分十进制记法的后缀<ul><li>结合使用点分十进制记法的后缀在IPv4的后缀在IPv4向IPv6的转换阶段特别有用</li><li>前缀的表示方法<ul><li>CIDR的<strong>斜线表示法</strong>仍然可以使用，<strong>但取消了子网掩码</strong></li><li><img src="/../img/ComNetworking/102.png"></li></ul></li></ul></li></ul></li><li>IPv6地址配置方式<ul><li>手动配置</li><li>DHCPv6(IPv6动态主机配置协议)</li><li>无状态地址自动配置，基于<strong>邻居发现协议</strong>(ND)的<strong>路由请求报文</strong>(RS)的IPv6前缀信息，结合自己的链路层地址生存IPv6地址</li></ul></li><li>IPv4向IPv6过渡<ul><li>两种过渡策略<ul><li>使用双协议栈<ul><li><img src="/../img/ComNetworking/103.png"></li></ul></li><li>使用隧道技术<ul><li><img src="/../img/ComNetworking/104.png"></li></ul></li></ul></li></ul></li><li>ICMPv6<br><img src="/../img/ComNetworking/105.png"></li></ul><h2 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h2><ul><li>理想的路由算法<ul><li>算法必须是<strong>正确的和完整的</strong></li><li>算法在计算上应<strong>简单</strong></li><li>算法应能适应通信量和网络拓扑的变化，要有<strong>自适应</strong></li><li>算法应具有<strong>稳定性</strong></li><li>算法应是<strong>公平的</strong></li><li>算法应是<strong>最佳的</strong></li></ul></li><li>路由选择非常复杂<ul><li>需要许多路由器协同动作</li><li>环境不断变化，而这种变化有时无法事先知道</li><li>当网络发生拥塞时，很难获得所需要的路由选择信息</li></ul></li><li>根据路由算法是否随网络的通信量或拓扑自适应划分<ul><li>静态路由选择策略<ul><li>非自适应路由选择</li><li>不能及时适应网络状态的变化</li><li>简单，开销较小</li></ul></li><li>动态路由选择策略<ul><li>自适应路由选择</li><li>能较好地适应网络状态的变化</li><li>能较好适应网络状态的变化</li><li>实现较为复杂，开销较大</li></ul></li></ul></li><li>分层次的路由选择协议 <ul><li><img src="/../img/ComNetworking/109.png"></li><li>互联网由大量不同的网络互连，每个管理机构控制的网络时自治的 </li><li>自治系统<ul><li><img src="/../img/ComNetworking/110.png"></li></ul></li><li>自治系统内部使用内部网关路由协议<ul><li>OSPF,RIP,IS-IS,EIGRP</li></ul></li><li>自治系统之间使用外部网关路由协议<ul><li>BGP<br><img src="/../img/ComNetworking/110.png"><br><img src="/../img/ComNetworking/113.png"></li></ul></li></ul></li></ul><h3 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h3><ul><li>是一种<strong>分布式的，基于距离向量</strong>的路由选择协议</li><li>最大优点：简单</li><li>要求网络中的每个路由器都要<strong>维护</strong>从它自己到其他每一个目的网络的<strong>距离记录</strong></li><li>距离的定义<br><img src="/../img/ComNetworking/106.png"></li><li>特点<ul><li>仅和<strong>相邻</strong>路由器交换信息</li><li>交换信息是当前本路由器所知道的<strong>全部信息</strong>，即自己的路由表<ul><li>路由表表项：目的网络，距离，下一跳</li></ul></li><li>按固定时间间隔交换路由信息</li><li>好消息传播得块，坏消息传播得慢</li></ul></li><li>距离向量算法<br><img src="/../img/ComNetworking/107.png"><br><img src="/../img/ComNetworking/107.png"></li><li>优缺点<ul><li>优点<ul><li>实现简单，开销较小</li></ul></li><li>缺点<ul><li>网络规模有限。最大距离为15</li><li>交换得路由信息为完整路由表，开销较大</li><li>坏消息传播得慢，收敛时间过长</li></ul></li></ul></li></ul><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><ul><li>采用<strong>Dijkstra</strong>提出得最短路径算法SPF</li><li>采用<strong>分布式的链路状态协议</strong></li><li>现在使用OSPFv2</li><li>特点<ul><li>向本自治系统中所有路由器<strong>洪泛</strong>信息</li><li>发送的信息是与本地路由器<strong>相邻</strong>的所有路由器的链路状态</li><li>只有<strong>当链路状态发生变化时</strong>路由器才用洪泛发生此信息</li><li>适用于更大的网络，为加快收敛，便于管理，使用层次结构的区域划分，以缩小LSDB规模，减少网络流量<br><img src="/../img/ComNetworking/112.png"></li></ul></li><li>优点<ul><li>减少整个网络上的通信量</li><li>减少了需要维护的状态数量</li></ul></li><li>缺点<ul><li>交换信息的种类增多了</li><li>使OSPF更加复杂了</li></ul></li></ul><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><ul><li>主要特点<ul><li>力求选择出一条能够跨域AS达到目的网络且比<strong>较好的路由</strong>，而<strong>并非要计算出一条最佳路由</strong></li><li>采用<strong>路径向量</strong>路由选择协议</li></ul></li><li>eBGP和iBGP连接(使用TCP连接)<br> <img src="/../img/ComNetworking/114.png"></li><li>BGP的路由选择顺序<ul><li>本地偏好值最高的路由</li><li>AS跳数最小的路由</li><li>最近的下一跳路由器</li><li>最小路由器ID</li></ul></li></ul><h3 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h3><ul><li>路由器工作在网络层，用于在<strong>不同网络之间转发分组</strong></li><li>在路由器之间传送的信息以下2大类<ul><li>主机之间需要传送的<strong>数据</strong></li><li><strong>路由信息</strong>(为数据传送服务)</li><li>第二类信息的传送使为第一类信息服务</li></ul></li><li>路由器包含两个核心功能<ul><li><strong>控制层面</strong>：运行各种协议(BGP,OSPF,RIP等)，学习去往不同目的的转发路径(路由表)</li><li><strong>数据层面</strong>：根据上述路由表，将收到的IP分组转发到正确的下一跳链路</li></ul></li><li>路由器的结构<br><img src="/../img/ComNetworking/115.png"></li><li>路由器中IP报文转发核心功能<br><img src="/../img/ComNetworking/116.png"></li></ul><h2 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h2><ul><li><p>源主机给网络中的一部分目标用户发送数据包</p></li><li><p>目的：更好地支持一对多通信</p></li><li><p>一对多通信：一个源点发送到许多个终点</p></li><li><p>多播IP地址</p><ul><li>在IP多播数据报的目的地址使用IP地址的<strong>D类地址</strong>(多播地址)<ul><li>地址范围：224.0.0.0~239.255.255.255</li></ul></li><li>局域网多播地址(一跳子网内使用)</li></ul></li><li><p>多播硬件地址</p><ul><li>TCP&#x2F;IP协议使用的以太网地址多播地址的范围是<ul><li>从00-00-5E-00-00-00到00-00-5E-FF-FF-FF</li></ul></li><li>所有通信<strong>都使用IP多播</strong>。只要有可能，都用<strong>硬件多播</strong>来传送，以减小网络开销</li></ul></li><li><p>多播路由：多播路由选择协议多播路由器协同工作，把多播数据报用最小代价传送给多播组的所有成员</p><ul><li>世纪上就是要找出以源主机为根结节点的<strong>多播转发树(生成树)</strong></li><li>不同的多播组对应不同的多播转发树</li><li>数据报沿生成树发送</li><li>转发多播数据报时使用三种方法<ul><li>洪泛与剪除<ul><li>适用于较小的多播组，所有组成员接入的局域网也是相邻接的</li><li>为避免兜圈子，采用<strong>反向路径广播RPB</strong>的策略，即受控制的洪泛</li></ul></li><li>隧道技术<ul><li>隧道：可以使用多播数据报穿越不支持多播的网络</li></ul></li><li>基于核心的发现技术<ul><li>最佳生成树的使用取决于组的密度分布<ul><li>密集分布：接受者遍布在网络的大部分区域(基于源点树)<ul><li>链路状态路由算法：每个路由器针对组内的每个发送者构成一颗独立树；</li><li>距离向量路由算法：逆向路径转发，修剪没有组成员的路由器</li></ul></li><li>稀疏分布：大部分网络区域都不属于组播组(基于核心树)<ul><li>多个组播共享树</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h2><ul><li>虚拟专用网VPN利用<strong>公用互联网</strong>作为本机构各<strong>专用网之间</strong>的<strong>通信载体</strong><ul><li>专用网：指这种网络时为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信</li><li>虚拟：表示实际上没有使用通信专线，只是在效果上和真正的专用网一样</li></ul></li><li>vpn指利用公用网络架设专用网络的远程访问技术</li><li>VPN通过隧道技术在公共网络上模拟出一条点到点的逻辑专线，从而达到安全数据传输的目的</li><li>VPN的设计原则<ul><li>安全性，隧道与加密，数据验证，用户验证，防火墙与攻击检测<br><img src="/../img/ComNetworking/117.png"></li></ul></li></ul><h2 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h2><ul><li><p>所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将<strong>本地IP地址</strong>转换成<strong>全球IP地址</strong>，才能和互联网连接</p><ul><li>当NAT路由器具有n个全球IP地址时，专用网内<strong>最多</strong>可以<strong>同时</strong>有n台主机接入到互联网</li><li>可以使专用网内较多数量的主机<strong>轮流</strong>使用NAT路由器有限数量的全球IP地址</li><li>并不能节约IP地址</li></ul></li><li><p>网络地址与端口号转换NAPT</p><ul><li>使用传输端端口号的NAT叫做网络地址与端口号转换</li><li>NAPT可以使多台拥有本地地址的主机，<strong>共用</strong>一个全球IP地址，<strong>同时</strong>和互联网上的不同主机进行通信</li><li>NAPT把专用网内不同的源IP地址都转换为相同的全球IP地址，将TCP源端口号转换成<strong>不同的</strong>新TCP端口号</li><li>收到从互联网发来的应答时，从IP数据报的数据部分找出运输层端口号，从NAPT转换表中找到正确的目的主机<br><img src="/../img/ComNetworking/118.png"></li></ul></li></ul><h2 id="多协议标签交换MPLS"><a href="#多协议标签交换MPLS" class="headerlink" title="多协议标签交换MPLS"></a>多协议标签交换MPLS</h2><ul><li>MPLS<ul><li>多协议：在MPLS的上层可以采用多种协议</li><li>标签：MPLS利用面向技术连接技术，使每个分组携带一个叫做标签的小整数。标签交互路由器用标签值检索转发表，实现分组的快速转发</li></ul></li><li>MPLS的工作过程<br><img src="/../img/ComNetworking/119.png"></li><li>MPLS报文结构<ul><li>不要求下层的网络都使用面向连接的技术</li><li>采用封装技术：在把IP数据报封装成以太网帧之前，先要插入一个MPLS首部</li><li>从层次的角度来看，MPLS首部在第二层和第三层之间<br><img src="/../img/ComNetworking/120.png"></li></ul></li></ul><h2 id="软件定义网络SDN简介"><a href="#软件定义网络SDN简介" class="headerlink" title="软件定义网络SDN简介"></a>软件定义网络SDN简介</h2><ul><li>优点<ul><li>提高网络带宽利用率</li><li>网络运行更加稳定</li><li>管理更加高效简化</li><li>运行费用明显降低</li></ul></li></ul><p><img src="/../img/ComNetworking/121.png"></p><ul><li>SDN与传统网络的差别<br><img src="/../img/ComNetworking/122.png"></li></ul><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="概叙-2"><a href="#概叙-2" class="headerlink" title="概叙"></a>概叙</h2><h3 id="为什么需要运输层"><a href="#为什么需要运输层" class="headerlink" title="为什么需要运输层"></a>为什么需要运输层</h3><ul><li>网络层实现了异构网络之间的通信，尽最大努力在主机之间交付数据</li><li>但仍然遗留一些问题<ul><li>参与通信的主机中，到底谁在发送和接受应用程序的数据</li><li>如果出现了分组的重复，丢失，失序等不可靠传输的问题，如何处理</li></ul></li><li>传输层：面向通信部分的最高层，用户功能的最底层</li><li>进程之间的通信<ul><li>主机之间的通信，实际是两台主机中的应用<strong>进程之间的通信</strong>，并且往往是一台主机上的多个进程同时和另一台上的多个进程之间的通信</li><li><img src="/../img/ComNetworking/123.png"></li></ul></li></ul><h3 id="运输层提供的服务"><a href="#运输层提供的服务" class="headerlink" title="运输层提供的服务"></a>运输层提供的服务</h3><ul><li>因特网的网络层提供”<strong>尽力而为</strong>“的服务：<ul><li>网络层尽最大努力在终端间交付分组，且不提供任何承诺</li><li>具体来说，不保证交付，不保证按序交付，不保证数据完整，不保证延迟，不保证带宽</li></ul></li><li>传输层<strong>依赖并扩展网络层的服务，有所为，有所不为：</strong><ul><li>传输层可以通过差错恢复，重排序等手段提供可靠，按序的交付服务</li><li>但运输层无法提供延迟保证，带宽保证等服务</li></ul></li><li>最低限度(必须要要做)的传输服务<ul><li>进程到进程的数据交付<ul><li>运输层提供应用进程之间的逻辑通信，在两个运输层实体之间建立<strong>端到端的逻辑通信信道</strong></li><li>运输层向高层用户<strong>屏蔽</strong>了下面网络核心的细节</li></ul></li><li>差错检测<ul><li>将对运输层报文及其他信息进行检测</li><li>网络层的IP首部校验和仅检测IP首部而不检测数据部分</li><li>数据链路层校验用于检测收到的帧是否存在比特传输的错误</li></ul></li></ul></li><li>运输层提供的增加服务：<strong>可靠传输，流量控制，拥塞控制</strong> 等</li><li>可靠信道与不可信道<br><img src="/../img/ComNetworking/124.png"> </li><li>传输协议数据单元<ul><li>两个对等运输实体在通信是传送的数据单位叫做<strong>运输协议数据单元TPDU</strong></li><li>TCP传送的数据单位协议是<strong>TCP报文段</strong></li><li>UDP传送的数据单位协议是<strong>UDP报文</strong>或<strong>用户数据报</strong></li></ul></li><li>UDP与TCP的区别<br><img src="/../img/ComNetworking/125.png"></li></ul><h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><ul><li><strong>复用</strong>:应用进程都可以通过运输层再传送到IP层(网络层)</li><li><strong>分用</strong>:运输层从IP层收到发送给应用进程的数据后，必须分别交付给<strong>指明的</strong>各应用进程</li><li><strong>协议端口号</strong>，简称为<strong>端口</strong><ul><li><strong>端口是通信的抽象终点</strong></li><li>在一台主机中准确的找到某个进程</li><li>不受操作系统的限制</li><li>实现异构系统之间的通信</li></ul></li><li>运输层协议把数据交给指定的端口，而不关心接口所代表的功能</li><li>操作系统只要让正确的进程对应正确的端口，那交付就不会出错</li><li>端口用一个<strong>16位端口号</strong>进行标志，允许有65535个不同的端口号</li><li>端口号只具有<strong>本地意义</strong>，只是为了标志<strong>本计算机应用层中的各进程</strong></li><li>在互联网中，不同计算机的相同端口号没有联系<br><img src="/../img/ComNetworking/126.png"></li><li>通信需要同时知道对方的IP地址和端口号</li><li>套接字socket &#x3D; (IP地址:端口号)</li><li>UDP的套接字<ul><li>使用&lt;IP地址,端口号&gt;二元组进行标识</li><li>&lt;目的IP地址,目的端口号&gt;相同的UDP报文字段交付给同一个套接字，与&lt;源IP地址,源端口号&gt;</li></ul></li><li>TCP的套接字 <ul><li>&lt;源IP地址,源端口号,目的IP地址,目的端口号&gt;</li><li>一个TCP服务器为了同时服务多个客户，使用监听套接字和连接套接字</li><li>每个连接套接字只与一个客户通信，即只接受以下四元组的报文段<ul><li>源IP地址 &#x3D; 客户IP地址, 源端口号 &#x3D; 客户套接字端口号,</li><li>目的IP地址 &#x3D; 服务器IP地址,目的端口号 &#x3D; 服务器监听套接字的端口号</li></ul></li><li>同一个IP地址可以有多个不同的TCP连接</li><li>同一个端口号也可以出现多个不同的TCP连接中</li></ul></li></ul><h2 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h2><h3 id="概叙-3"><a href="#概叙-3" class="headerlink" title="概叙"></a>概叙</h3><ul><li>UDP只在IP的数据报服务上增加了一些功能<ol><li>复用和分用</li><li>差错检测</li></ol></li></ul><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li><strong>无连接</strong>。发送数据之前不要建立连接</li><li><strong>使用尽最大努力交付</strong>。即不保证可靠交付</li><li><strong>面向报文</strong>。UDP一次传送和交付一个完整的报文<br><img src="/../img/ComNetworking/127.png"></li><li><strong>没有拥塞控制</strong>。不会因网络拥塞降低源主机的发送速率，适合某些实时多媒体通信</li><li>支持<strong>一对一、一对多、多对一、多对多</strong>等交互通信</li><li><strong>首部开销小</strong>，只有8个字节</li></ul><blockquote><p>为什需要UDP？</p></blockquote><ul><li>应用可以尽可能块地发送报文<ul><li>无建立连接的延迟</li><li>不限制发送速率(不进行拥塞控制和流量控制)</li></ul></li><li>报头开销小</li><li>协议处理简单</li></ul><blockquote><p>UDP适合哪些应用</p></blockquote><ul><li>容忍丢包但对延迟敏感的应用：IP电话，视频会议，多媒体应用等</li><li>以单次请求&#x2F;响应为主的应用：DNS,RIP,DHCP等</li><li>若应用要求基于UDP进行可靠传输：由应用层实现可靠性</li></ul><h3 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h3><p><img src="/../img/ComNetworking/128.png"></p><ul><li>源端口：在需要对方回信时选用。不需要时可用全0</li><li>目的端口：终点交付报文时必须使用<ul><li>如果接收方UDP发现收到的报文中的端口号不正确(即不存在对应于该端口号的应用进程)，就丢弃该报文，并由ICMP发送”端口不可达”错误报文给发送方</li></ul></li><li>长度：UDP用户数据报的长度，其最小值是8(仅有首部)</li><li>校验和：检测UDP用户数据报在传输中是否由错，首部和数据部分一起参加计算，有错就丢弃<ul><li>在计算检验和时，临时把12字节的”伪首部”和UDP用户数据报连接在一起。伪首部仅仅是为了计算检验和<br><img src="/../img/ComNetworking/129.png"></li></ul></li></ul><h2 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h2><h3 id="概叙-4"><a href="#概叙-4" class="headerlink" title="概叙"></a>概叙</h3><p>TCP是<strong>面向连接</strong>的运输层协议，在无连接、不可靠的IP地址网络基础之上提供<strong>可靠交付</strong>的服务。为此，在IP的数据报服务基础之上，增加了保证可靠性的一系列措施</p><h3 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li>TCP是<strong>面向连接</strong>的运输层协议</li><li>每一条TCP来连接<strong>只能有两个端点</strong>，每一条TCP连接只能是<strong>点对点</strong>的</li><li>TCP在无连接、不可靠的IP地址之上，提供面向连接的<strong>可靠交付</strong>服务：流水线式发送、报文段检错，丢失重传</li><li>TCP提供<strong>全双工</strong>通信，发送方和接收方可以同时与对方收发数据<ul><li>面向连接<br><img src="/../img/ComNetworking/130.png"></li></ul></li><li>面向字节流<ul><li>TCP中的”流”指的是流入或流出进程的<strong>字节序列</strong></li><li><strong>面向字节流</strong>:可靠，有序的字节流，不保留报文边界</li><li>发送的字节流和接受的字节流完全一致</li></ul></li></ul><h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3><ul><li><p>TCP传送的数据单元是报文段</p></li><li><p>一个TCP报文段分为首部和数据两部分</p></li><li><p>TCP报文段首部的前220字节是固定的，后面有4n个字节是根据需要而增加的选项。TCP首部的最小长度是20字节<br><img src="/../img/ComNetworking/131.png"></p></li><li><p><strong>源端口和目的端口</strong>：各占2字节，是运输层与应用层的服务接口</p></li><li><p><strong>序号</strong>:占4字节。TCP连接中传送的数据流中的<strong>每一个字节</strong>都一个序号。序号字段的值则是指的是<strong>本报文段所发送的数据的第一字节</strong>的序号</p></li><li><p><strong>确认号</strong>：占4个字节。是<strong>期望收到</strong>对方的下一个报文段的数据的第一个字节的序号</p></li><li><p><strong>数据偏移</strong>：占4位。指出TCP报文段的<strong>数据起始</strong>处距离TCP<strong>报文段起始</strong>处有多远，即TCP头部长度。以4字节为计算单位</p></li><li><p>标志位(位大小都为1)</p><ul><li><strong>保留位</strong>：占6位，保留为以后使用，但目前有应置为0</li><li><strong>紧急UGR</strong>：当URG&#x3D;1时，表明紧急指针字段有效，告诉系统此报文段中有紧急数据，应尽快传送</li><li><strong>确认ACK</strong>:当ACK&#x3D;1时，确认号字段才有效</li><li><strong>推送PSH</strong>：接受TCP收到PSH&#x3D;1的报文段后，就尽快交付接受应用进程，而不再等到整个缓存都填满后再交付</li><li><strong>复位PST</strong>：当RST&#x3D;1时，表明TCP连接中出现严重错误，必须释放连接，然后再重新建立运输连接</li><li><strong>同步SYN</strong>：SYN&#x3D;1表示时一个连接请求或连接接受的报文<ul><li>当SYN&#x3D;1，ACK&#x3D;0，这是一个连接请求报文字段</li><li>当SYN&#x3D;1，ACK&#x3D;1，这是一个连接接受报文字段</li></ul></li><li><strong>终止FIN</strong>：FIN&#x3D;1表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</li></ul></li><li><p><strong>窗口</strong>：接受方目前允许对方发送的数据量(以字节为单位)，窗口值是动态变化的 </p></li><li><p><strong>校验和</strong>：占2字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在TCP报文段的前面加上12字节的<strong>伪首部</strong><br><img src="/../img/ComNetworking/132.png"></p></li><li><p><strong>紧急指针</strong>：占2字节。在URG&#x3D;1时，指出本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据)，指出了紧急数据的末尾在报文段中的位置</p></li><li><p><strong>选项</strong>:长度可变，最长可达40字节</p></li><li><p><strong>填充</strong>：使整个TCP首部长度是4字节的整数倍</p></li><li><p><strong>最大报文段长度MSS</strong>：是每个TCP报文段中的数据字段的最大长度，<strong>与接受窗口值没有关系</strong></p></li><li><p>建立连接时，每个主机可声明自己能够接受的MSS，缺省为536字节<br><img src="/../img/ComNetworking/133.png"></p></li><li><p>窗口扩大：建立连接时，双方可以协商一个窗口比例因子</p></li><li><p>时间戳：占10字节，主要时间戳值字段(4字节)和时间戳送回答字段(4字节)</p><ul><li>两个主要功能<ul><li>计算往返时间RTT</li><li>防止序号绕回PAWS：序号空间对于高宽带很容易消耗完。序号重复时，时间戳可以使接受方能够把<strong>新报文段</strong>和迟到很久的<strong>旧报文段</strong>区分开</li></ul></li></ul></li></ul><h2 id="可靠传输工作原理"><a href="#可靠传输工作原理" class="headerlink" title="可靠传输工作原理"></a>可靠传输工作原理</h2><blockquote><p>理想传输条件的特点</p></blockquote><ol><li>传输信道不产生差错(不纠错)</li><li>不管发送方以多块的数据发送数据，接受方总是来得及收到的数据(不进行流量控制)</li></ol><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ul><li>没发送完一个分组就停止发送，等待对方的确认。在确认后再发送下一个分组。确认的内容不重要</li><li>全双工通信的双方即是发送方也是接收方</li></ul><ol><li>无差错情况<br><img src="/../img/ComNetworking/134.png"></li><li>出现差错<br><img src="/../img/ComNetworking/135.png"><br>解决方法:超时重传<br><img src="/../img/ComNetworking/136.png"></li><li>确认丢失和确认迟到<ul><li>确认丢失<br><img src="/../img/ComNetworking/137.png"></li><li>确认迟到<br><img src="/../img/ComNetworking/138.png"></li></ul></li></ol><blockquote><p>停止等待协议要点<br><strong>停止等待</strong>:发送方每次只发送一个分组，在收到确认后再发一个分组<br><strong>暂存</strong>：在发送完一个分组后，发送方必须暂存已发的分组的副本，以备重发<br><strong>编号</strong>：对方发送的每个分组和确认都进行编号<br><strong>超时重传</strong>:发送方为发送的每一个分组设置一个超时计时器。若计时器超时未收到确认，发送方会<strong>自动</strong>超时重传分组<br>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些，防止不必要的重传<br>自动重传请求ARQ:重传的请求是<strong>发送方</strong>自动进行的</p></blockquote><p>信道利用率<br>停止-等待机制<strong>降低</strong>了信道利用率<br>解决办法：通过流水线传输提高效率 </p><ul><li>流水线传输：在收到确认之前，发送方连续发出多个分组，使得信道上一直有数据不间断地传送，提高信道利用率</li><li>连续ARQ协议和滑动窗口协议采用流水线传输方式</li></ul><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><ul><li><strong>发送窗口</strong>:发送方维持一个发送窗口，位于发送窗口内得分组都可以被连续发送出去，而不需要等待对方得确认。即发送方一次可以发送多个分组</li><li><strong>发送窗口滑动</strong>:发送方每收到一个确认，就把发送窗口向前活动一个分组得位置。控制发送方和控制方所能发送和接收得分组的数量和编号<br><img src="/../img/ComNetworking/139.png"></li><li>累积确认:接收方对按序达到的最后一个分组发送确认，表示这个分组为止的所有分组都已正确收到了<br><img src="/../img/ComNetworking/140.png"><ul><li>优点:容易实现，即使确认丢失也不必重传</li><li>缺点:不能向发送方反映出接收方已经正确收到所有的分组的信息</li></ul></li><li>连续ARQ协议采用GO-back-N(回退N)<ul><li>**GO-back-N(回退N)**：表示需要再2退回来重传已发送过的N个分组</li><li>基本原理<ul><li>当发送方发送N个帧后，若发现该N帧的前一个帧在计时器超时后仍为未返回其确认信息，则该帧被判为出错或丢失，此时发送方就重新发送出错帧以其后的N帧</li></ul></li><li>当通信线路质量不好时，连续ARQ协议会带来负面的影响</li></ul></li></ul><h3 id="连续ARQ协议与停止等待协议对比"><a href="#连续ARQ协议与停止等待协议对比" class="headerlink" title="连续ARQ协议与停止等待协议对比"></a>连续ARQ协议与停止等待协议对比</h3><p><img src="/../img/ComNetworking/141.png"></p><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><ul><li><p>TCP使用流水线传输和滑动窗口协议实现高效、可靠的传输</p></li><li><p>TCP的滑动窗口是<strong>以字节为单位</strong>的</p></li><li><p>发送方A和接受方B分别维持一个<strong>发送窗口</strong>和一<strong>个接受窗口</strong></p><ul><li>发送窗口：只允许发送<strong>落入</strong>窗口内的数据，<strong>连续</strong>把窗口内的数据<strong>全部发出去</strong>。凡是已经发送过的数据，在未收到确认之前都必须<strong>暂时保留</strong>，以便在超时重传时使用<br><img src="/../img/ComNetworking/142.png"><ul><li>例子<br><img src="/../img/ComNetworking/143.png"></li></ul></li><li>接受窗口:只允许接受<strong>落入</strong>窗口内的数据<br><img src="/../img/ComNetworking/144.png"></li></ul></li><li><p>窗口与缓存的关系</p><ul><li><img src="/../img/ComNetworking/145.png"></li><li><img src="/../img/ComNetworking/146.png"></li></ul></li></ul><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><ul><li>TCP发送方在规定时间内没有收到确认就要重传已发送的报文段</li><li>但互联网环境复杂，IP数据报所选择的路由变化很大，往返时间(RTT,发出报文到收到确认到时间间隔)的变化很大，重传时间难以测定<ul><li>太短会引起很多报文段的不必要的重传，使得网络负荷增大</li><li>太长会使网络的空闲时间增大，降低传输效率</li></ul></li><li>加权往返时间<ul><li><img src="/../img/ComNetworking/147.png"></li></ul></li><li>超时重传时间RTO<ul><li><img src="/../img/ComNetworking/148.png"></li></ul></li><li>Karm算法<ul><li>TCP存在二义性，使得测量到的RRT不准确<ul><li>重传的TCP报文段使用与原报文段相同的序号</li><li>发送方收到确认后，无法得知是对哪个报文段进行的确认</li></ul></li><li>解决方法<ul><li>在计算平均往返时间RRT时，只要报文段重传了，就不采取往返时间样本</li></ul></li><li><img src="/../img/ComNetworking/149.png"></li></ul></li></ul><h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3><blockquote><p>若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，，那么能否设法<strong>只传送缺少的数据</strong>而不重传已经正确到达接受方的数据<br>在TCP首部中都增加可选字段SACK，以便报告收到的<strong>不连续的字节块的边界</strong></p></blockquote><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><blockquote><p>为什么要进行流量控制</p></blockquote><ul><li>通过确认和重传机制，可以让发送方确认接收方已正确收到数据</li><li>接收方收不到数据，则无法作出确认</li><li>大量丢包和重传，显然不是一种高效的工作方式</li></ul><h3 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h3><ul><li>流量控制:让发送方的发送速率不要太快</li><li>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制<br><img src="/../img/ComNetworking/150.png"></li><li>接受窗口为0的僵局<br><img src="/../img/ComNetworking/151.png"></li></ul><h3 id="TCP的传输效率"><a href="#TCP的传输效率" class="headerlink" title="TCP的传输效率"></a>TCP的传输效率</h3><ul><li>TCP会在三种机制下发送报文段<ol><li>缓存中存放的数据达到预先设定的最大报文段长度MSS字节时，就组装成一个TCP报文段发送出去</li><li>由发送方的应用进程指明要发送报文段(推送操作)</li><li>发送方的某个计时器期限到了，这时就把当前已有的缓存数据装入报文段(长度不超过MSS)发送出去</li></ol></li><li>糊涂窗口综合症<ul><li>每次仅发送一个字节或很少几个字节的数据时，有效数据传输效率变得很低的现象</li><li>解决方法<ul><li>Nagle算法(发送方会等待读一点数据再发送)<br><img src="/../img/ComNetworking/152.png"></li></ul></li></ul></li></ul><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><h3 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h3><ul><li>在某段时间，若网络中有许多资源同时产生拥挤的情况，网络的性能就要明显变坏，整个网络的吞吐量将输入负荷的增大而下降，这种现象称为拥塞</li><li>表现：分组延迟增大，网络吞吐量下降，甚至降为0(系统奔溃)</li><li>起因：大量分组短时间内进入网络，超过网络的处理能力<ul><li>节点缓存容量太小</li><li>链路容量不足</li><li>处理机处理速率太慢</li><li>拥塞本身会进一步加剧拥塞</li></ul></li><li>单纯靠增加某个设备的资源，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏</li><li>拥塞是一个<strong>全局问题</strong>，网络整体资源的增加肯定是有用的</li><li>但完全依赖增加资源不能解决拥塞，我们对网络资源的需求是无限的，但网络资源不是无限的</li></ul><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul><li><p>解决拥塞的方法：</p><ul><li><strong>增加资源(较少资源需求)+控制发送量(拥塞控制)</strong></li></ul></li><li><p><strong>拥塞控制</strong>就是防止过多的数据注入网络中，使网络中的路由器或链路不致过载</p></li><li><p><strong>拥塞控制的前提</strong>:网络能够承受现有的网络负荷</p></li><li><p>网络拥塞是一个非常复杂的<strong>动态</strong>问题，拥塞控制是否合理，直接影响网络性能和效率</p></li><li><p>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化，甚至发发生死锁的原因</p></li><li><p>开环控制</p><ul><li>在设计网络时，<strong>事先考虑周全</strong>，力求工作时不发生拥塞</li><li>但一旦整个系统运行起来，就不再中途进行改正</li></ul></li><li><p>闭环控制</p><ul><li>基于反馈环路的概念</li><li>根据网络<strong>当前运行状态</strong>采取相应控制措施</li><li>思路:检测网络发生拥塞的位置和时机，并采取措施进行控制，消除拥塞</li><li>采取的策略<ul><li>发生”通知拥塞发生”的分组给源站</li><li>在分组中保留表示拥塞状态的字段</li><li>周期性地发出探测分组等</li><li>选择合适的时机调整网络状态</li></ul></li></ul></li><li><p>分组的丢失是网络发生拥塞的<strong>征兆</strong>，而不是<strong>原因</strong></p></li></ul><h3 id="TCP的拥塞控制方法"><a href="#TCP的拥塞控制方法" class="headerlink" title="TCP的拥塞控制方法"></a>TCP的拥塞控制方法</h3><ul><li>TCP采用<strong>基于滑动窗口的方法</strong>进行闭环拥塞控制</li><li>发生方维持一个<strong>拥塞窗口</strong>，控制发送速率<ul><li>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化</li><li>发送端利用拥塞窗口根据网络的拥塞情况调整发送速率</li></ul></li></ul><h4 id="控制拥塞窗口变化的原则"><a href="#控制拥塞窗口变化的原则" class="headerlink" title="控制拥塞窗口变化的原则"></a>控制拥塞窗口变化的原则</h4><ul><li>网络们没有出现拥塞：拥塞窗口就可以再增大一些，以便把更多的分组发送出去，提高网络的利用率</li><li>网络出现拥塞或有可能出现拥塞：必须把拥塞窗口减小一些，以减少注入到网络中的分组数，缓解网络出现的拥塞</li></ul><h4 id="发送方判断拥塞的方法"><a href="#发送方判断拥塞的方法" class="headerlink" title="发送方判断拥塞的方法"></a>发送方判断拥塞的方法</h4><ul><li>超时计时器超时：网络已经出现了拥塞，网络的交付能力很差</li><li>收到3个重复的确认：预示网络可能会出现拥塞，网络仍有一定的交付能力</li></ul><h4 id="四种拥塞控制算法"><a href="#四种拥塞控制算法" class="headerlink" title="四种拥塞控制算法"></a>四种拥塞控制算法</h4><ul><li>假定接收方接受能力无限大：加法增大，乘法减少<ol><li>慢开始<br>  <img src="/../img/ComNetworking/153.png"></li><li>拥塞避免<br><img src="/../img/ComNetworking/154.png"></li><li>快重复<br><img src="/../img/ComNetworking/155.png"></li><li>快恢复<br><img src="/../img/ComNetworking/156.png"><blockquote><p>TCP拥塞控制举例<br><img src="/../img/ComNetworking/157.png"><br>TCP拥塞控制流程图<br><img src="/../img/ComNetworking/158.png"></p></blockquote></li></ol></li></ul><h3 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h3><p><img src="/../img/ComNetworking/159.png"></p><blockquote><p>发送窗口的上限值<br>发送窗口的上限值&#x3D;Min[rwnd,cwnd]<br>当rwnd &lt; cwnd时，是接受方的<strong>接受能力**限制发送窗口的最大值<br>当rwnd &gt; cwnd时，是</strong>网络拥塞**限制发送窗口的最大值</p></blockquote><h2 id="TCP运输连接管理"><a href="#TCP运输连接管理" class="headerlink" title="TCP运输连接管理"></a>TCP运输连接管理</h2><h3 id="运输连接的三个阶段"><a href="#运输连接的三个阶段" class="headerlink" title="运输连接的三个阶段"></a>运输连接的三个阶段</h3><ul><li>TCP是面向连接的协议</li><li>TCP连接有<strong>三个阶段</strong><br>连接建立-&gt;数据传送-&gt;连接释放</li><li>TCP的连接管理就是使TCP连接的建立和释放都能正常地进行</li></ul><h3 id="TCP的连接建立-三次握手"><a href="#TCP的连接建立-三次握手" class="headerlink" title="TCP的连接建立(三次握手)"></a>TCP的连接建立(三次握手)</h3><ul><li>要解决三个问题<ol><li>要使每一方都能够确定对方的存在</li><li>要允许双方协商一些参数(如最大窗口值，是否使用窗口扩大选项和时间戳选项以及服务质量等)</li><li>能够对运输实体资源(缓存大小，连接表中的项目)进行<strong>分配</strong></li></ol></li><li>TCP连接的建立采用<strong>客户服务器</strong>方式<ul><li><strong>主动发起</strong>连接的应用进程叫做客户</li><li><strong>被动等待</strong>连接建立的应用进程叫做服务器</li></ul></li><li>TCP建立连接的过程叫做握手<ul><li>采用三报文握手：在客户和服务器之间交换三个TCP报文段，以防止已失效的连接请求报文段突然又传送到了，因此产生TCP连接建立错误<br><img src="/../img/ComNetworking/160.png"></li></ul></li></ul><h3 id="TCP的连接释放-四次挥手"><a href="#TCP的连接释放-四次挥手" class="headerlink" title="TCP的连接释放(四次挥手)"></a>TCP的连接释放(四次挥手)</h3><ul><li>TCP的连接释放过程比较复杂</li><li>数据传输结束后，通信的<strong>双方</strong>都可以释放连接</li><li>TCP连接释放的过程是<strong>四报文段握手</strong><br><img src="/../img/ComNetworking/161.png"></li><li>时间等待计时器<br><img src="/../img/ComNetworking/162.png"></li><li>保活计时器<br><img src="/../img/ComNetworking/163.png"></li></ul><blockquote><p>TCP四个计时器</p><ul><li>超时重传计时器</li><li>持续计时器(0窗口报文探测计时器)</li><li>时间等待计时器(2MSL关闭连接)</li><li>保活计时器</li></ul></blockquote><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><h3 id="概叙-5"><a href="#概叙-5" class="headerlink" title="概叙"></a>概叙</h3><ul><li>许多应用层软件经常直接使用<strong>域名系统</strong>DNS，但计算机的用户只是间接而不是直接使用域名系统</li><li>互联网采用层次结构的命名树作为主机的名字，并使用<strong>分布式</strong>的域名系统DNS</li><li>名字到IP地址的解析是有若干个域名服务器程序完成的。域名服务器在专设的结点上运行，运行该程序的机器称为<strong>域名服务器</strong></li></ul><h3 id="互联网的域名结构"><a href="#互联网的域名结构" class="headerlink" title="互联网的域名结构"></a>互联网的域名结构</h3><ul><li>互联网采用了层次树状结构的命名方法</li><li>任何一个连接在互联网上的主机或路由器，都有一个<strong>唯一</strong>的层次结构的名字，即<strong>域名</strong></li><li>域名对的地址结构有标号序列组成，各标号之间用<strong>点</strong>隔开<br>  ….三级域名.二级域名.顶级域名</li><li>各标号分别代表级别的域名</li><li>域名只是个<strong>逻辑</strong>概念</li></ul><h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><ul><li>一个服务器所负责管辖的范围叫做<strong>区</strong></li><li>各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有节点必须是能够连通的</li><li>每一区设置相应的<strong>权限域名服务器</strong>，用来保存该区中的所有主机的域名IP地址的映射</li></ul><p>DNS域名服务器四种类型 </p><ul><li>根域名服务器：知道所有顶级域名服务器的IP地址<ul><li><strong>根域名服务器共有13套装置，不是13个机器</strong></li></ul></li><li>顶级域名服务器：管理该顶级域名服务器注册的所有二级域名<ul><li>负责管理在该顶级域名服务器注册的所有二级域名</li></ul></li><li>权限域名服务器：负责一个区的域名服务器</li><li>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器</li></ul><p>工作过程：</p><ol><li>主机访问网站，先向DNS服务器发送DNS查询请求</li><li>如果访问的网站域名后缀跟请求的DNS服务器解析的域名不同，则向根域名服务器请求让根域名服务器找寻对应的DNS服务器并把解析结果返回(例如DNS为.com的域名服务器，主机访问.cn的网站，因此.com会向根域名服务器请求)</li><li>将解析后的IP地址返回给主机，主机或域名服务器进行缓存</li><li>主机访问IP地址来访问方网站</li></ol><p>域名解析过程：</p><ol><li>递归查询：靠别人，也就是该DNS服务器没有该结果，就向其他DNS服务器请求，例如向根域名服务器，如果根域名服务器也没有则根域名服务器向顶级域名服务器请求</li><li>迭代查询：靠自己，如果本地域名服务器查询不到，然后本地域名服务器就向根域名服务器发送请求，如果还没有，则由本地域名服务器向其他服务器发送请求。</li><li>高速缓存：为了提高查询效率，则添加了高速缓存，也就是查询过一次，则域名服务器将该查询结果进行缓存，这样就减少请求次数，需要定期更新(增加时间减少网络开销，减少时间提高域名转换的准确性)</li></ol><h2 id="DHCP动态主机配置"><a href="#DHCP动态主机配置" class="headerlink" title="DHCP动态主机配置"></a>DHCP动态主机配置</h2><p>概念：</p><ul><li>动态主机配置协议DHCP是应用层协议，使用客户&#x2F;服务器方式，客户端和服务端通过广播方式进行交互，基于UDP。</li><li>DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址</li><li>支持移动用户加入网络，支持在用地址续租</li></ul><p>请求过程：</p><ul><li>主机广播发送DHCP发送报文，找到网络中的DHCP服务器，服务器获得一个IP地址</li><li>DHCP服务器广播发送DHCP提供报文，服务器拟分配给主机一个IP地址及相关配置，先到先得</li><li>主机广播发送DHCP请求报文，主机向服务器请求提供IP地址</li><li>DHCP服务器广播发送DHCP确认报文，正式将IP地址分配给主机</li></ul><h2 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h2><p>概念：</p><ul><li>FTP协议提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力</li><li>FTP是基于客户&#x2F;服务器(C&#x2F;S)的协议，基于TCP进行传输的</li><li>用户通过一个客户机程序连接至远程计算机上运行的服务器程序</li><li>依照FTP协议提供服务，进行文件传送的计算机就是FTP服务器</li><li>连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端</li></ul><p>FTP使用两个TCP连接：<br><img src="/../img/ComNetworking/164.png"></p><ul><li>TCP控制连接：传送文件操作命令(删除、下载、上传等)，使用服务器21端口，连接始终保持</li><li>TCP数据连接：用来传输数据的(下载、上传等)，连接保持一会，有两种模式<blockquote><p>主动模式：服务端从20端口主动向客户端发起连接。如果服务器有防火墙需要打开21和20端口<br>被动模式：**服务端在指定范围内的某个端口被动等待客户端发起连接(端口&gt;1024)**。如果服务器有防火墙只打开21和20端口，FTP不能下载和上传数据</p></blockquote></li></ul><p>FTP传输模式：</p><ul><li>文本模式：ASCII模式，以文本序列传输数据</li><li>二进制模式：Binary模式，以二进制序列传输数据</li></ul><h2 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h2><p>概念：</p><ul><li>telnet是基于TCP的远程终端协议，默认端口为23</li><li>用户用TELNET就可在其所在地通过TCP连接注册(即登录)到远地的另一台主机上(使用主机名或IP地址)</li><li>基于客户服务器方式的协议，传输的格式使用NVT</li></ul><h2 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h2><p>概念：</p><ul><li><p>HTTP协议定义了浏览器(万维网客户进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器<br>具体过程：<br><img src="/../img/ComNetworking/165.png"></p><ol><li>浏览器分析URL</li><li>浏览器向DNS请求解析IP地址</li><li>DNS解析出IP地址</li><li>浏览器与服务器建立TCP连接</li><li>浏览器发出取文件命令</li><li>服务器响应</li><li>释放TCP连接</li><li>浏览器显示</li></ol></li></ul><p>特点：</p><ul><li>http 1.0是无状态的，http 1.1是持续连接的</li><li>HTTP采用TCP作为传输层协议，但HTTP协议本身是无连接的(通信双方在交换HTTP报文之前不需要先建立HTTP连接)</li></ul><p>HTTP的连接方式：</p><ol><li>非持久连接<br><img src="/../img/ComNetworking/166.png"></li><li>持久连接<blockquote><p>两种工作方式：<br>非流水线方式：收到响应后再发出请求<br>流水线方式：连续发送，只花费RTT时间</p></blockquote></li></ol><p><img src="/../img/ComNetworking/167.png"></p><p><strong>HTTP报文结构：</strong></p><ul><li>HTTP报文是面向文本的，因此在报文中的每一个字段都是一些ASCII码串</li></ul><ol><li>请求报文<br><img src="/../img/ComNetworking/168.png"></li><li>响应报文<br><img src="/../img/ComNetworking/169.png"></li></ol><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p><strong>电子邮件系统组成结构：</strong><br><img src="/../img/ComNetworking/170.png"></p><ul><li>用户代理就是用户与电子邮件系统的接口，是电子邮件客户端软件。<br>简单邮件传送协议SMTP：</li><li>SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息</li><li>负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器</li><li>SMTP规定了14条命令(几个字母)和21种应答信息(三位数字代码+简单文字说明)</li><li>SMTP协议是基于TCP连接以及C&#x2F;S方式的协议，端口号为25<br><img src="/../img/ComNetworking/171.png"></li></ul><p>SMTP缺点：</p><ol><li>SMTP不能传送可执行文件或者其他二进制对象</li><li>SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字</li><li>SMTP服务器会拒绝超过一定长度的邮件</li></ol><p>MIME：</p><ul><li>可以将邮件传送的附件类型码放进SMTP协议数据报中</li><li>使得接收用户浏览器知道用什么插件解析<br><img src="/../img/ComNetworking/172.png"></li></ul><p>邮局协议POP3：</p><ul><li>基于TCP连接和C&#x2F;S方式的协议，端口号110</li><li>用于接收邮件的协议</li><li>工作方式：1.下载并保存(在服务器)，2.下载并删除</li></ul><p>网际报文存取协议IMAP：</p><ul><li>当用户PC上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上</li><li>IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读邮件中的某一个部分(先看正文，有wifi的时候再下载附件)</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统</title>
    <link href="/2024/10/15/os-b/"/>
    <url>/2024/10/15/os-b/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>什么是操作系统？</p></blockquote><p>操作系统（Operating Ststem，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p><blockquote><p>操作系统在系统中的位置</p></blockquote><p><img src="/../img/osb/1.png"></p><blockquote><p>操作系统的功能和目标</p></blockquote><p>1.系统资源的管理者</p><ul><li>文件管理</li><li>内存管理</li><li>处理机（CPU）管理</li><li>设备（计算机硬件，例如摄像头）管理</li></ul><p>2.用户和计算机硬件之间的接口</p><p><img src="/../img/osb/2.png"></p><p>3.对硬件机器的拓展</p><blockquote><p>操作系统的四个特征</p></blockquote><p>1.并发</p><p>并发是指两个或多个事件在同一时间间隔内发生。这些事件在宏观上是同时发生的，在微观上是交替发生的。</p><p>易混淆的概念——并行：两个或多个事件在同一时刻同时发生</p><p>2.共享</p><p>共享即资源共享，是指系统中的资源内存中多个并发执行的进程共同使用。</p><p><img src="/../img/osb/3.png"></p><p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)</p><p>生活实例:</p><ul><li>互斥共享方式:使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。</li><li>同时共享方式:使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</li></ul><p>3.虚拟</p><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><p><img src="/../img/osb/4.png"><br>4.异步</p><p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><ul><li>只有系统拥有并发性，才有可能导致异步性。</li></ul><h2 id="操作系统的运行机制和体系结构"><a href="#操作系统的运行机制和体系结构" class="headerlink" title="操作系统的运行机制和体系结构"></a>操作系统的运行机制和体系结构</h2><p>指令<br><img src="/../img/osb/5.png"><br>CPU<br><img src="/../img/osb/6.png"><br>程序<br><img src="/../img/osb/7.png"><br>操作系统的内核<br>由于内核划分功能的不同，内核分为大内核和微内核。<br><img src="/../img/osb/8.png"><br>大内核和微内核的优缺点<br><img src="/../img/osb/9.png"><br>类比:</p><ul><li>操作系统的体系结构问题与企业的管理问题很相似。</li><li>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接</li><li>大内核:企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高;缺点是组织结构混乱，难以维护。</li><li>微内核:随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护;缺点是效率低。</li></ul><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h3><p>中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p><ol><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。</li><li>对于不同的中断信号，会进行不同的处理。</li><li>有了中断，才能实现多道程序并发执行。</li><li>“用户态→核心态”是通过中断实现的，并且中断是唯一途径。“核心态→用户态”的切换是通过执行一个特权指令，将程序状态字（ PSW）的标志位设置为 “用户态”。</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>中断信号的来源来自CPU内部称为内中断，外部称为外中断。</li></ul><p><img src="/../img/osb/10.png"></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。<br><img src="/../img/osb/11.png"></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I&#x2F;o操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p><h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h3><p>编程语言（c,java）中里边有很多库函数，其实它们（不是所有的库函数）就是将系统调用封装起来，隐藏一些细节，使上层进行系统调用更加方便。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>系统调用发生在用户态，对系统调用的处理发生在核心态。</li><li>执行陷入指令（自陷指令或访管指令）会处理内中断，使处理器（CPU）从用户态进入核心态。</li></ul><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的定义，组成，组织方式，特征"><a href="#进程的定义，组成，组织方式，特征" class="headerlink" title="进程的定义，组成，组织方式，特征"></a>进程的定义，组成，组织方式，特征</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序： 就是指令序列</p><p>引入多道程序（CPU可以并发执行多个程序）之后，为了方便操作系统进行管理，引入了进程，进程实体的概念。</p><p><strong>PCB，程序段，数据段三部分构成了进程实体（也叫作进程映像）</strong>。一般情况下，我们把进程实体简称为进程。</p><p>例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB.</p><p><strong>PCB是进程存在的唯一标识。</strong><br><img src="/../img/osb/12.png"></p><h3 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h3><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p><p>注: 进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。</p><p>相当于java中的链表和数组。</p><p><img src="/../img/osb/13.png"></p><h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><h2 id="进程的状态和转换"><a href="#进程的状态和转换" class="headerlink" title="进程的状态和转换"></a>进程的状态和转换</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>进程是程序的一次执行。在这个过程中，进程的状态会有各种变化。为了方便各个进程的管理，操作系统将进程划分为几个状态。<br><img src="/../img/osb/14.png"><br>除此之外，进程还有两种状态。<br><img src="/../img/osb/15.png"></p><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p><img src="/../img/osb/16.png"></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><blockquote><p>含义</p></blockquote><p><strong>进程控制就是要实现进程状态转换。</strong></p><blockquote><p>实现</p></blockquote><p><strong>进程控制由原语实现。</strong>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，<strong>在执行过程中不可被中断。</strong></p><p>原语采用 “关中断指令” 和 “开中断指令” 来实现。 注意： 原语运行在核心态。<br><img src="/../img/osb/17.png"><br>那么原语是如何实现进程状态的转换呢？</p><ol><li>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<br>  a.所有的进程控制原语一定都会修改进程状态标志<br>  b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>  c.某进程开始运行前必然要恢复期运行环境</li><li>将PCB插入合适的队列</li><li>分配&#x2F;回收资源</li></ol><p>具体实现如图所示：<br><img src="/../img/osb/18.png"></p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><blockquote><p>含义</p></blockquote><p>进程通信就是进程之间的信息交换。</p><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p><p>操作系统提供了三种方法：共享存储，消息传递，管道通信。</p><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p><img src="/../img/osb/19.png"></p><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>1.管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p><p>2.各进程要互斥地访问管道。</p><p>3.数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取后，管道变空，此时读进程的read()系统调用将被阻塞。</p><p>5．数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。<br><img src="/../img/osb/20.png"></p><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息” 两个原语进行数据交换。</p><p>类似于Http协议。</p><h2 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>有的进程需要同时做很多事，例如用QQ来进行聊天，发送文件等，而传统的进程只能串行执行一系列程序。因此，引入“线程”，来增加并发度。</p><ul><li>可以把线程理解为轻量级的进程。</li><li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</li><li>引入线程后，进程作为除CPU之外的系统资源的分配单元。<br><img src="/../img/osb/21.png"></li></ul><h3 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h3><p>1.用户级线程</p><ul><li>用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换)</li><li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</li><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明)</li><li>可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”。</li></ul><p>2.内核级线程</p><ul><li>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li><li>可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。<br><strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></li></ul><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><blockquote><p>多对一模型</p></blockquote><ul><li>多对一模型:多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</li><li>优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li></ul><p><img src="/../img/osb/22.png"></p><blockquote><p>一对一模型</p></blockquote><ul><li>一对一模型:一个用户级线程映射到一个内核级线程。</li><li>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li></ul><p><img src="/../img/osb/23.png"></p><blockquote><p>多对多模型</p></blockquote><ul><li>多对多模型:n用户级线程映射到m个内核级线程(n &gt;&#x3D;m)。每个用户进程对应m个内核级线程。</li><li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li></ul><p><img src="/../img/osb/24.png"></p><h2 id="处理机调度的概念和层次"><a href="#处理机调度的概念和层次" class="headerlink" title="处理机调度的概念和层次"></a>处理机调度的概念和层次</h2><blockquote><p>含义</p></blockquote><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。</p><p>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p><p>调度分为三个层次，分别为高级调度，中级调度，初级调度。</p><h3 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h3><ul><li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</li><li>高级调度（作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB)，以使它（们）获得竞争处理机的权利。</li><li>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，调出的时机必然是作业运行结束才调出。</li></ul><p><img src="/../img/osb/25.png"></p><h3 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h3><ul><li><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。</p></li><li><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p></li><li><p>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p></li><li><p>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p></li><li><p><img src="/../img/osb/26.png"></p></li></ul><h3 id="补充知识：进程的七状态模型"><a href="#补充知识：进程的七状态模型" class="headerlink" title="补充知识：进程的七状态模型"></a>补充知识：进程的七状态模型</h3><ul><li>暂时被调到外存等待的进程状态称为挂起状态。</li><li>挂起状态又可以进一步细分为就绪挂起，堵塞挂起两种状态。</li></ul><p><img src="/../img/osb/27.png"></p><h3 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h3><ul><li>低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</li><li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li><li>进程调度的频率很高，一般几十毫秒一次。</li></ul><p><img src="/../img/osb/28.png"></p><h3 id="三种调度的联系和对比"><a href="#三种调度的联系和对比" class="headerlink" title="三种调度的联系和对比"></a>三种调度的联系和对比</h3><p><img src="/../img/osb/29.png"></p><h2 id="进程调度的时机，切换过程和方式"><a href="#进程调度的时机，切换过程和方式" class="headerlink" title="进程调度的时机，切换过程和方式"></a>进程调度的时机，切换过程和方式</h2><h3 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h3><p><img src="/../img/osb/30.png"><br>临界资源： 一个时间段内只允许一个进程使用的资源。各进程需要互斥的访问临界资源。</p><p>临界区：访问临界资源的那段代码。</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列。</p><h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><p>非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p><blockquote><p>优点</p></blockquote><p>实现简单,系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p><blockquote><p>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p></blockquote><p>优点</p><ul><li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</li></ul><h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><p>“狭义的进程调度”与“进程切换”的区别:</p><ul><li>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</li><li>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</li></ul><p><strong>广义的进程调度包含了选择一个进程和进程切换两个步骤。</strong><br>进程切换的过程主要完成了:</p><ol><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</li></ol><p>注意 : <strong>进程切换是有代价的</strong>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><ul><li>CPU利用率： CPU”忙碌”的时间占总时间的比例。</li><li>系统吞吐量：单位时间内完成作业的数量。<br><img src="/../img/osb/31.png"></li><li>周转时间：是指从作业被提交给系统开始，到作业完成为止的时间间隔。</li></ul><p>（作业）周转时间&#x3D;作业完成时的时间-作业提交时间</p><p>平均周转时间&#x3D;各作业周转时间之和&#x2F;作业数</p><p>由于在周转时间相同的情况下，运行时间不同的作业，给用户的感觉是不一样的，所以提出了带权周转时间的概念。<br><img src="/../img/osb/32.png"></p><ul><li>等待时间：指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</li></ul><p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p><p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p><ul><li>响应时间：指从用户提交请求到首次产生响应所用的时间。</li></ul><h2 id="调度算法-1"><a href="#调度算法-1" class="headerlink" title="调度算法(1)"></a>调度算法(1)</h2><h3 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务(FCFS)"></a>先来先服务(FCFS)</h3><p><img src="/../img/osb/34.png"></p><h3 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先(SJF)"></a>短作业优先(SJF)</h3><p><img src="/../img/osb/35.png"></p><h3 id="高响应比优先-HRRN"><a href="#高响应比优先-HRRN" class="headerlink" title="高响应比优先(HRRN)"></a>高响应比优先(HRRN)</h3><p><img src="/../img/osb/36.png"></p><h3 id="三种算法对比"><a href="#三种算法对比" class="headerlink" title="三种算法对比"></a>三种算法对比</h3><p><img src="/../img/osb/37.png"><br>注:这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。<strong>因此这三种算法一般适合用于早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。而适合用于交互式系统的调度算法将在下个小节介绍…</p><h2 id="调度算法-2"><a href="#调度算法-2" class="headerlink" title="调度算法(2)"></a>调度算法(2)</h2><h3 id="时间片轮转调度-RR"><a href="#时间片轮转调度-RR" class="headerlink" title="时间片轮转调度(RR)"></a>时间片轮转调度(RR)</h3><p><img src="/../img/osb/38.png"></p><ul><li>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li><li>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</li><li>一般来说，设计时间片要让切换进程的开销占比不超过1%。</li></ul><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p><img src="/../img/osb/39.png"><br><img src="/../img/osb/40.png"></p><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p><img src="/../img/osb/41.png"></p><ul><li>通过下边的例子来加深理解<br><img src="/../img/osb/42.png"></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这<strong>三种算法适合用于交互式系统</strong>。(比如UNIX使用的就是多级反馈队列调度算法)</p><h2 id="进程同步与进程互斥"><a href="#进程同步与进程互斥" class="headerlink" title="进程同步与进程互斥"></a>进程同步与进程互斥</h2><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><ul><li>通过进程通信——管道通信的例子来了解什么是进程同步。<br><img src="/../img/osb/43.png"><br>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。如何解决这种异步问题，就是“进程同步”所讨论的内容。<blockquote><p>含义</p></blockquote></li></ul><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><ul><li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。</li><li>许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li><li>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。</li><li>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。<br><img src="/../img/osb/44.png"><br>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:<br><img src="/../img/osb/45.png"></li></ul><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p><ul><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿)</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ul><h2 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h2><h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p>算法思想:每个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p><blockquote><p>代码实现<br><img src="/../img/osb/46.png"><br>解释</p></blockquote><p>turn的初值为0，即刚开始只允许0号进程进入临界区。</p><p>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换 P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在 P0访问临界区期间即时切换回P1，P1依然会卡在⑤。只有P0在退出区将turn改为1后，P1才能进入临界区。</p><p>因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”</p><p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。</p><p>也就是说，对于临界区的访问，一定是按P0→P1→P0→P1→……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</p><p>因此，<strong>单标志法存在的主要问题是:违背“空闲让进”原则。</strong></p><h3 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h3><p>算法思想:设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] &#x3D;ture”意味着0号进程 P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[li]设为true，之后开始访问临界区。</p><p>若按照①⑤②⑥③⑦….的顺序执行，P0和P1将会同时访问临界区。因此，双标志先检查法的主要问题是:违反“忙则等待”原则。<br><img src="/../img/osb/47.png"><br>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p><h3 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h3><p><img src="/../img/osb/48.png"></p><h3 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h3><p>算法思想:双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。<br><img src="/../img/osb/49.png"></p><ul><li>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。</li><li>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</li></ul><h2 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p><img src="/../img/osb/50.png"></p><h3 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h3><p><img src="/../img/osb/51.png"></p><h3 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h3><p><img src="/../img/osb/52.png"></p><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><h3 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h3><ul><li>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li><li>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来表示系统中某种资源的数量，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</li><li>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。</li><li>一对原语: wait(S)原语和 signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量s其实就是函数调用时传入的一个参数。</li></ul><p>wait、signal原语常简称为P、V操作（来自荷兰语proberen和 verhogen)。因此，做题的时候常把wait(S)、 signal(S)两个操作分别写为P(S)、V(S)。</p><h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p><p>与普通整数变量的区别：对信号量的操作只有三种，初始化，P操作，V操作。</p><p>下面以打印机为例：<br><img src="/../img/osb/53.png"></p><h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p><img src="/../img/osb/54.png"><br>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><h2 id="用信号量实现进程互斥，同步，前驱关系"><a href="#用信号量实现进程互斥，同步，前驱关系" class="headerlink" title="用信号量实现进程互斥，同步，前驱关系"></a>用信号量实现进程互斥，同步，前驱关系</h2><h3 id="信号量机制实现进程互斥"><a href="#信号量机制实现进程互斥" class="headerlink" title="信号量机制实现进程互斥"></a>信号量机制实现进程互斥</h3><ol><li>分析并发进程的关键活动，划定临界区（如:对临界资源打印机的访问就应放在临界区)</li><li>设置互斥信号量mutex，初值为1</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)<br><img src="/../img/osb/55.png"><br>注意： 对不同的临界资源（如摄像头，打印机）需要设置不同的互斥信号量。</li></ol><p>P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</p><h3 id="信号量机制实现进程同步"><a href="#信号量机制实现进程同步" class="headerlink" title="信号量机制实现进程同步"></a>信号量机制实现进程同步</h3><p>进程同步：要让各并发进程按要求有序的进行。</p><p>那么如何实现呢？</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码)</li><li>设置同步信号量s,初始为0</li><li>在“前操作”之后执行v(S)</li><li>在“后操作”之前执行P(S)</li></ol><p>下面通过一个例子来解释，要求：进程2的代码4必须在进程1的代码2之后执行。<br><img src="/../img/osb/56.png"></p><h3 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h3><p>进程P1中有句代码S1，P2中有句代码S2 …P… P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行:</p><p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作)，因此，</p><p>1．要为每一对前驱关系各设置一个同步变量<br>2．在“前操作”之后对相应的同步变量执行V操作<br>3.在“后操作”之前对相应的同步变量执行Р操作<br><img src="/../img/osb/57.png"></p><h2 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)</p><ul><li>生产者、消费者共享一个初始为空、大小为n的缓冲区。</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li><li>缓冲区是临界资源，各进程必须互斥地访问。<br><img src="/../img/osb/33.png"></li></ul><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><img src="/../img/osb/58.png"></p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p><img src="/../img/osb/59.png"></p><h3 id="能够改变相邻P，V的顺序"><a href="#能够改变相邻P，V的顺序" class="headerlink" title="能够改变相邻P，V的顺序"></a>能够改变相邻P，V的顺序</h3><p><img src="/../img/osb/60.png"></p><h2 id="多生产者——多消费者"><a href="#多生产者——多消费者" class="headerlink" title="多生产者——多消费者"></a>多生产者——多消费者</h2><p>问题描述<br>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。<br><img src="/../img/osb/61.png"></p><h3 id="如何实现-1"><a href="#如何实现-1" class="headerlink" title="如何实现"></a>如何实现</h3><p><img src="/../img/osb/62.png"><br>问题：可不可以不使用问题信号量？</p><p>结论:即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</p><p>原因在于:本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻,最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p><p>如果盘子（缓冲区）数量为2，可能会出现两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</li><li>建议:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</li></ol><h2 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)。<br><img src="/../img/osb/63.png"></p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p><img src="/../img/osb/64.png"></p><h2 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求:</p><p>①允许多个读者可以同时对文件执行读操作;<br>②只允许一个写者往文件中写信息;<br>③任一写者在完成写操作之前不允许其他读者或写者工作;<br>④写者执行写操作前，应让已有的读者和写者全部退出。<br><img src="/../img/osb/65.png"></p><h3 id="如何实现-2"><a href="#如何实现-2" class="headerlink" title="如何实现"></a>如何实现</h3><p><img src="/../img/osb/66.png"></p><ul><li>潜在的问题：只要读进程还在读，写进程就要一直堵塞等待，可能会饿死。因此在这种算法中，读进程优先。下面来实现“ 先来先服务”算法，这样就不会导致写进程饿死。<br><img src="/../img/osb/67.png"></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。</p><p>其核心思想在于设置了一个计数器count用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。</p><p>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。</p><p>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p><h2 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭"></a>哲学家吃饭</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。<br><img src="/../img/osb/68.png"></p><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>1.关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。<br>2.整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。<br>3.信号量设置。定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1}，用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</p><h3 id="如何实现-3"><a href="#如何实现-3" class="headerlink" title="如何实现"></a>如何实现</h3><p>如果使用下图所示的方法，则会导致死锁问题。<br><img src="/../img/osb/69.png"><br>那么如何解决呢？</p><p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的<br>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。<br>③仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。<br>下面用代码实现第三种方式。<br><img src="/../img/osb/70.png"></p><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><h3 id="为什么引入管程？"><a href="#为什么引入管程？" class="headerlink" title="为什么引入管程？"></a>为什么引入管程？</h3><p>信号量机制存在的问题 : 编写程序困难、易出错。 因此人们想设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松。1973年，Brinch Hansen首次在程序设计语言(Pascal)中引入了“管程”成分――一种高级同步机制。</p><h3 id="管程的定义和基本特征"><a href="#管程的定义和基本特征" class="headerlink" title="管程的定义和基本特征"></a>管程的定义和基本特征</h3><p>管程相当于对临界区资源进行抽象而编写的一个类。</p><p>管程是一种特殊的软件模块，有这些部分组成:</p><p>1.局部于管程的共享数据结构说明; （一个类）<br>2.对该数据结构进行操作的一组过程; （类中的方法）<br>3.对局部于管程的共享数据设置初始值的语句; （类中的变量）<br>4.管程有一个名字。 （类名）</p><p>管程的基本特征:</p><p>1.局部于管程的数据只能被局部于管程的过程所访问; （类中变量有自己的作用范围）<br>2.**一个进程只有通过调用管程内的过程才能进入管程访问共享数据; ** 这种互斥特性是由编译器来实现的。<br>3.每次仅允许一个进程在管程内执行某个内部过程。</p><h3 id="java中类似于管程的机制（单例模式）"><a href="#java中类似于管程的机制（单例模式）" class="headerlink" title="java中类似于管程的机制（单例模式）"></a>java中类似于管程的机制（单例模式）</h3><p><img src="/../img/osb/71.png"></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁“。</p><p>发生死锁后若无外力干涉,这些进程都将无法向前推进。</p><h3 id="死锁，饥饿，死循环的区别"><a href="#死锁，饥饿，死循环的区别" class="headerlink" title="死锁，饥饿，死循环的区别"></a>死锁，饥饿，死循环的区别</h3><ul><li>死锁:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li><li>饥饿:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</li><li>死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是程序员故意设计的。<br><img src="/../img/osb/72.png"></li></ul><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li><strong>互斥条件</strong>:只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源）。</li><li><strong>不剥夺条件</strong>:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li><strong>请求 和 保持条件</strong>:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li><strong>循环等待条件</strong>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul><p>注意 : 发生死锁时一定有循环等待 , 但是发生循环等待时未必死锁(<strong>循环等待是死锁的必要不充分条件</strong>)</p><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p><h3 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h3><ol><li><strong>对系统资源的竞争</strong>。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</li><li><strong>进程推进顺序非法。</strong>请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程p1又紧接着申请资源R2，而进程p2又申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li><strong>信号量的使用不当也会造成死锁。</strong>如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</li></ol><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><p>1.预防死锁。破坏死锁产生的四个必要条件中的一个或几个。<br>2.避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法)<br>3.死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</p><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p><img src="/../img/osb/73.png"></p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h3 id="什么是安全序列"><a href="#什么是安全序列" class="headerlink" title="什么是安全序列"></a>什么是安全序列</h3><p><img src="/../img/osb/74.png"><br><img src="/../img/osb/75.png"></p><ul><li>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</li><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</li><li><strong>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，则可能会发生死锁。（不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)</strong></li><li>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</li></ul><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>数据结构:</p><ul><li>长度为m的一维数组 Available表示还有多少可用资源</li><li>n*m矩阵Max表示各进程对资源的最大需求数</li><li>n*m矩阵Allocation表示已经给各进程分配了多少资源</li><li>Max - Allocation &#x3D; Need矩阵表示各进程最多还需要多少资源</li><li>用长度为m的一位数组Request表示进程此次申请的各种资源数</li></ul><h3 id="银行家算法步骤"><a href="#银行家算法步骤" class="headerlink" title="银行家算法步骤:"></a>银行家算法步骤:</h3><ul><li>检查此次申请是否超过了之前声明的最大需求数</li><li>检查此时系统剩余的可用资源是否还能满足这次请求</li><li>试探着分配，更改各数据结构</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li></ul><p><strong>安全性算法步骤:</strong><br>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。<br>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p><h2 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h2><h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><p>为了能对系统是否已发生了死锁进行检测，必须:<br>①用某种数据结构来保存资源的请求和分配信息;<br>②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。<br><img src="/../img/osb/76.png"><br>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程.<br><strong>如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列)。</strong><br>如果最终不能消除所有边，那么此时就是发生了死锁。<br><strong>死锁定理:如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。</strong></p><h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><p>一旦检测出死锁的发生，就应该立即解除死锁。<br>补充:并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程<br>解除死锁的主要方法有 :</p><ol><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li></ol><p>如何选择对哪些进程动手？</p><ol><li>进程优先级 (优先级低的)</li><li>已执行多长时间 （执行时间短的）</li><li>还要多久能完成 （时间长的进行处理）</li><li>进程己经使用了多少资源 （资源多的）</li><li>进程是交互式的还是批处理式的 （进行批处理的）</li></ol><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</strong><br><img src="/../img/osb/77.png"></p><blockquote><p>相对地址和绝对地址</p></blockquote><p><strong>编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</strong></p><p>Eg: 编译时只需确定变量x存放的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU 想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p><p><strong>相对地址又称逻辑地址，绝对地址又称物理地址。</strong></p><blockquote><p>写程序到程序运行<br><img src="/../img/osb/78.png"></p></blockquote><h2 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h2><p>操作系统对内存进行管理，那么要管理哪些内容呢？</p><ol><li>内存空间的分配和回收</li><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。</li><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换<br><img src="/../img/osb/79.png"></li><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</li></ol><p>内存保护可采取两种方法:<br>方法一:在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。<br><img src="/../img/osb/80.png"><br>方法二:采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。<br><img src="/../img/osb/81.png"></p><h2 id="覆盖和交换"><a href="#覆盖和交换" class="headerlink" title="覆盖和交换"></a>覆盖和交换</h2><p><img src="/../img/osb/82.png"></p><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>覆盖技术的思想 : 将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。</p><p>内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束)不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。<br><img src="/../img/osb/83.png"><br><img src="/../img/osb/84.png"><br>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点:对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。</p><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>交换（对换）技术的设计思想: 内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）。之前讲的中级调度（内存调度）就是为这个服务的。<br><img src="/../img/osb/85.png"></p><p>1.应该在外存（磁盘）的什么位置保存被换出的进程?</p><blockquote><p>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式（学过文件管理章节后即可理解）。总之，对换区的I&#x2F;O速度比文件区的更快。</p></blockquote><p>2.什么时候应该交换?</p><blockquote><p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</p></blockquote><p>3.应该换出哪些进程?</p><blockquote><p>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…<br>(注意:PCB会常驻内存，不会被换出外存)</p></blockquote><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><h3 id="连续分配：指为用户进程分配的必须是一个连续的内存空间。"><a href="#连续分配：指为用户进程分配的必须是一个连续的内存空间。" class="headerlink" title="连续分配：指为用户进程分配的必须是一个连续的内存空间。"></a>连续分配：指为用户进程分配的必须是一个连续的内存空间。</h3><p><img src="/../img/osb/86.png"></p><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。</p><p>内存中只能有一道用户程序，用户程序独占整个用户区空间。</p><p>优点: 实现简单 ;无外部碎片;可以采用覆盖技术扩充内存;不一定需要采取内存保护（eg:早期的 PC操作系统MS-DOS)。</p><p>缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。<br><img src="/../img/osb/87.png"></p><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p><img src="/../img/osb/88.png"><br><img src="/../img/osb/89.png"></p><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p><p>使用这种方式的话，我们需要考虑以下三个问题。</p><ol><li>系统要用什么样的数据结构记录内存的使用情况?<br><img src="/../img/osb/90.png"></li><li>当很多个空闲分区都能满足需求时,应该选择哪个分区进行分配?<br>使用动态分区算法，这个将在下一小节进行详细介绍。</li><li>如何进行分区的分配与回收操作?</li></ol><ul><li>如何分配 ———–&gt; 使用动态分区算法之后，修改数据结构即可。<br><img src="/../img/osb/91.png"></li><li>如何回收——————————-&gt; 牢记一点即可，会把相邻的空闲区域合并为一个。<br><img src="/../img/osb/92.png"></li></ul><h3 id="内部碎片和外部碎片"><a href="#内部碎片和外部碎片" class="headerlink" title="内部碎片和外部碎片"></a>内部碎片和外部碎片</h3><ul><li>动态分区分配没有内部碎片，但是有外部碎片。</li><li><strong>内部碎片</strong>，分配给某进程的内存区域中，如果有些部分没有用上。</li><li><strong>外部碎片</strong>，是指内存中的某些空闲分区由于太小而难以利用。</li><li>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些<br>进程“碎片”不能满足进程的需求。可以通过紧凑（(拼凑，Compaction)技术来解决外部碎片。</li></ul><h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h2><p>动态分区分配算法:在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?</p><h3 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h3><p>算法思想: 每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p><p>如何实现:空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表），找到大小能满足要求的第一个空闲分区。<br><img src="/../img/osb/93.png"></p><h3 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h3><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。</p><p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。<br><img src="/../img/osb/94.png"></p><h3 id="最大适应算法"><a href="#最大适应算法" class="headerlink" title="最大适应算法"></a>最大适应算法</h3><p>又称最坏适应算法(Largest Fit)</p><p>算法思想:为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表），找到大小能满足要求的第一个空闲分区。<br><img src="/../img/osb/a.png"></p><h3 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h3><p>算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>如何实现:空闲分区以地址递增的顺序排列(可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。<br><img src="/../img/osb/95.png"></p><h3 id="四种算法对比"><a href="#四种算法对比" class="headerlink" title="四种算法对比"></a>四种算法对比</h3><p><img src="/../img/osb/96.png"></p><h2 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h2><p>连续分配:为用户进程分配的必须是一个连续的内存空间。</p><p>非连续分配:为用户进程分配的可以是一些分散的内存空间。<br><img src="/../img/osb/97.png"><br><strong>基本分页存储管理的思想――把内存分为一个个相等的小分区,再按照分区大小把进程拆分成一个个小部分。</strong></p><p>将内存空间分为一个个大小相等的分区（比如:每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”(或者“内存块号”、“页帧号”、“物理块号”)页框号从0开始。</p><p>将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。</p><p>(注:进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片)</p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。</p><p>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p><p>思考： 将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换?</p><p>1.要算出逻辑地址对应的页号<br>2.要知道该页号对应页面在内存中的起始地址<br>3.要算出逻辑地址在页面内的“偏移量”</p><p>物理地址 &#x3D; 页面始址＋页内偏移量</p><p>如何计算:<br>1.页号&#x3D;逻辑地址&#x2F;页面长度(取除法的整数部分)<br>2.页内偏移量 &#x3D; 逻辑地址%页面长度（取除法的余数部分)<br>3.页面在内存中的起始位置:操作系统需要用某种数据结构记录进程各个页面的起始位置。</p><p>举例:<br>页号&#x3D;80 &#x2F; 50&#x3D; 1<br>页内偏移量&#x3D;80 % 50 &#x3D; 30<br>1号页在内存中存放的起始位置450<br><img src="/../img/osb/98.png"><br>思考: 如何知道该页号对应页面在内存中的起始地址?<br>操作系统为每一个进程创建一个页表?<br><img src="/../img/osb/99.png"></p><ul><li>如何理解每个页表项的长度是相同的，页号是“隐含的”？<br><img src="/../img/osb/100.png"></li></ul><h2 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h2><p>基本地址变换机构可以<strong>借助进程的页表将逻辑地址转换为物理地址。</strong></p><p>通常会在系统中设置一个页表寄存器(PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><ul><li>执行流程<br><img src="/../img/osb/101.png"></li><li>页表项长度，页表长度，页面大小</li></ul><p>页表长度是指这个页表中总共有几个页表项，即总共有多少页。页面大小是指一个页面占多大的存储空间。页表项长度是指每个页表项占多大的存储空间。</p><p>通过下面这个例子来理解页表项长度。</p><p>Eg:假设某系统物理内存大小为4GB，页面大小为4KB，内存总共会被分为2^32&#x2F; 2^12&#x3D;2^20个内存块，因此内存块号的范围应该是0~2^20 - 1。因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节才够(每个字节8个二进制位，3个字节共24个二进制位)。每个块号用三个字节来表示。<br><img src="/../img/osb/102.png"></p><h2 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p><strong>时间局部性</strong>:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</p><p><strong>空间局部性</strong>:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)</p><p>上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢?</p><h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>快表，又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><p>执行流程<br><img src="/../img/osb/103.png"></p><h2 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h2><p>两级页表的出现主要是为了解决单级页表的问题。那么单级页表有什么问题呢？</p><p>问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</p><p>问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p><p>1.解决问题一</p><p>我们可以回想以下当初是如何解决进程必须连续的问题 ？<br><img src="/../img/osb/104.png"><br>我们可以把页表放在不同的页框中，再用一个表来记录各个各个子页表所在位置，我们把这个表叫做页目录表（外层页表，顶级页表）。</p><p>2.解决问题二<br><img src="/../img/osb/105.png"></p><h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><ol><li>若采用多级页表机制，则各级页表的大小不能超过一个页面</li><li>两级页表的访存次数分析（假设没有快表机构）<ul><li>第一次访存:访问内存中的页目录表</li><li>第二次访存:访问内存中的二级页表</li><li>第三次访存:访问目标内存单元</li></ul></li></ol><p><strong>N级页表访问一个逻辑地址需要N+1次访问内存。</strong></p><h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><p>分段</p><p>进程的地址空间:按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程)，每段从0开始编址。</p><p>内存分配规则 : 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。<br><img src="/../img/osb/106.png"></p><ul><li>分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。<br><img src="/../img/osb/107.png"><br>**段号的位数决定了每个进程最多可以分几个段。</li></ul><p>段内地址位数决定了每个段的最大长度是多少。**</p><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p><img src="/../img/osb/108.png"></p><h3 id="段内寻址"><a href="#段内寻址" class="headerlink" title="段内寻址"></a>段内寻址</h3><p><img src="/../img/osb/109.png"></p><h3 id="分段，分页对比"><a href="#分段，分页对比" class="headerlink" title="分段，分页对比"></a>分段，分页对比</h3><ul><li>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</li><li>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li><li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li><li>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</li><li>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li><li><strong>分段比分页更容易实现信息的共享和保护。</strong></li></ul><h2 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h2><h3 id="分页，分段的优缺点"><a href="#分页，分段的优缺点" class="headerlink" title="分页，分段的优缺点"></a>分页，分段的优缺点</h3><p><img src="/../img/osb/110.png"><br>既然两者都有优缺点，那么可不可以把他们结合起来呢？答案当然是可以的。如下图所示。<br><img src="/../img/osb/111.png"></p><h3 id="段页式管理的逻辑结构"><a href="#段页式管理的逻辑结构" class="headerlink" title="段页式管理的逻辑结构"></a>段页式管理的逻辑结构</h3><p><img src="/../img/osb/112.png"><br>段号的位数决定了每个进程最多可以分几个段<br>页号位数决定了每个段最大有多少页<br>页内偏移量决定了页面大小、内存块大小是多少</p><h3 id="段内寻址-1"><a href="#段内寻址-1" class="headerlink" title="段内寻址"></a>段内寻址</h3><p><img src="/../img/osb/113.png"></p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="传统存储管理方式的特征和缺点"><a href="#传统存储管理方式的特征和缺点" class="headerlink" title="传统存储管理方式的特征和缺点"></a>传统存储管理方式的特征和缺点</h3><ul><li>一次性:作业必须一次性全部装入内存后才能开始运行。这会造成两个问题:①作业很大时，不能全部装入内存，导致大作业无法运行;②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</li><li>驻留性:一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。<br><img src="/../img/osb/114.png"></li></ul><h3 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h3><p>基于局部性原理（忘记的话，可以到第8节查看），在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。<br>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。<br>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。<br>易混知识点:<br><strong>虚拟内存的最大容量是由计算机的地址结构（ CPU寻址范围）确定的<br>虚拟内存的实际容量&#x3D; min(内存和外存容量之和，CPU寻址范围)</strong><br>如: 某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB.<br>则虚拟内存的最大容量为2^32B&#x3D; 4GB 。 虚拟内存的实际容量&#x3D;min (2^32B,512MB+2GB)&#x3D; 2GB+512MB<br>虚拟内存有一下三个主要特征:</p><ul><li>多次性:无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li>对换性:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ul><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</strong><br><img src="/../img/osb/115.png"></p><h2 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h2><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，</p><ol><li>操作系统需要知道每个页面是否已经调入内存;</li><li>如果还没调入，那么也需要知道该页面在外存中存放的位置。</li><li>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面;</li><li>有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</li></ol><p>因此页表会增加四个字段来上面的信息。<br><img src="/../img/osb/116.png"></p><h3 id="缺页中断机制"><a href="#缺页中断机制" class="headerlink" title="缺页中断机制"></a>缺页中断机制</h3><p>假设此时要访问逻辑地址 &#x3D; (页号，页内偏移量）&#x3D; (0，1024)</p><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。</p><p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断</p><p>一条指令在执行期间，可能产生多次缺页中断。(如: copy AtoB，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)<br><img src="/../img/osb/117.png"></p><h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><p><img src="/../img/osb/118.png"></p><h3 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h3><p>①只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。<br>②和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。<br>③需要用某种“页面置换算法”来决定一个换出页面（下节内容)<br>④换入&#x2F;换出页面都需要启动慢速的I&#x2F;o操作，可见，如果换入&#x2F;换出太频繁，会有很大的开销。<br>⑤页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a>最佳置换算法(OPT)</h3><p>最佳置换算法(OPT):<strong>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</p><p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。<br><img src="/../img/osb/119.png"></p><h3 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a>先进先出置换算法(FIFO)</h3><p>先进先出置换算法(FIFO):每次选择淘汰的页面是最早进入内存的页面</p><p>实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p><p>Belady异常―一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>只有FIFO算法会产生Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差。<br><img src="/../img/osb/120.png"></p><h3 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h3><p>最近最久未使用置换算法(LRU):每次淘汰的页面是最近最久未使用的页面。</p><p>实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。<br><img src="/../img/osb/121.png"></p><h3 id="时钟置换算法-NRU"><a href="#时钟置换算法-NRU" class="headerlink" title="时钟置换算法(NRU)"></a>时钟置换算法(NRU)</h3><p>最佳置换算法性能最好，但无法实现;先进先出置换算法实现简单，但算法性能差;最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p><p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，NotRecently Used)</p><p>简单的CLOCK 算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)<br><img src="/../img/osb/122.png"></p><h3 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h3><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;o操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。<br>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;o操作。这就是改进型的时钟置换算法的思想。修改位&#x3D;0，表示页面没有被修改过;修改位&#x3D;1，表示页面被修改过。<br>为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1)表示一个页面近期被访问过，且被修改过。</p><p>算法规则: 将所有可能被置换的页面排成一个循环队列<br>第一轮:从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位<br>第二轮:若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0<br>第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0，0）的帧用于替换。本轮扫描不修改任何标志位<br>第四轮:若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。<br>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描<br><img src="/../img/osb/123.png"></p><h3 id="五种算法对比"><a href="#五种算法对比" class="headerlink" title="五种算法对比"></a>五种算法对比</h3><p><img src="/../img/osb/124.png"></p><h2 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h2><h3 id="页面分配，置换策略"><a href="#页面分配，置换策略" class="headerlink" title="页面分配，置换策略"></a>页面分配，置换策略</h3><ul><li><p>驻留集:指请求分页存储管理中给进程分配的物理块的集合。</p></li><li><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p><blockquote><ol><li>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际上用于进程推进的时间很少。</li><li>驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</li></ol></blockquote></li><li><p>固定分配:操作系统为每个进程分配一组固定数目的物理块，在进程运行期间大小不变。即，驻留集大小不变。</p></li><li><p>可变分配:先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变</p></li><li><p>局部置换:发生缺页时只能选进程自己的物理块进行置换。</p></li><li><p>全局置换:可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。<br><img src="/../img/osb/125.png"></p></li></ul><p>下面来分别介绍这几种方式。</p><ul><li><p>固定分配局部置换:系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是:很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)</p></li><li><p>可变分配全局置换:刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程;若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页都将获的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是进程中任意一个进程的页，因此被选中的这个进程物理块会减少，缺页率会增加。</p></li><li><p>可变分配局部置换： 刚开始会为每个进程分配一定数量的物理块，当某进程发生缺页时，只允许从该进程自己的物理块中选出一个换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当，反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p></li><li><p>可变分配全局置换:只要缺页就给分配新物理块</p></li><li><p>可变分配局部置换:要根据发生缺页的频率来动态地增加或减少进程的物理块</p></li></ul><h3 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h3><ol><li><p>预调页策略:根据局部性原理（主要是空间局部性），一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。它是运行前调入。</p></li><li><p>请求调页策略:进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘l&#x2F;o操作，因此I&#x2F;o开销较大。它是运行时调入。</p></li></ol><h3 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h3><p><img src="/../img/osb/126.png"></p><ol><li><p>系统拥有足够的对换区空间:页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</p></li><li><p>系统缺少足够的对换区空间:凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。<br><img src="/../img/osb/127.png"></p></li><li><p>UNIX方式:运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。<br><img src="/../img/osb/128.png"></p></li></ol><h3 id="抖动现象，工作集"><a href="#抖动现象，工作集" class="headerlink" title="抖动现象，工作集"></a>抖动现象，工作集</h3><ul><li>抖动:刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。</li><li>产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够)。</li><li>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</li><li>为了研究为应该为每个进程分配多少个物理块，Denning提出了进程“工作集”的概念。</li><li>驻留集:指请求分页存储管理中给进程分配的内存块的集合。</li><li>工作集:指在某段时间间隔里，进程实际访问页面的集合。</li></ul><p>一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。<br><img src="/../img/osb/129.png"></p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul><li><p>文件――就是一组有意义的信息&#x2F;数据集合。</p></li><li><p>一个文件有哪些属性？</p></li></ul><ol><li>文件名:由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。</li><li>标识符:一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</li><li>类型:指明文件的类型</li><li>位置:文件存放的路径（让用户使用)、在外存中的地址(操作系统使用，对用户不可见)</li><li>大小:指明文件大小创建时间、上次修改时间文件所有者信息</li><li>保护信息:对文件进行保护的访问控制信息</li></ol><ul><li>文件分为有结构文件和无结构文件。<br><img src="/../img/osb/130.png"></li><li>操作系统向上（用户和应用程序）提供的功能<br><img src="/../img/osb/131.png"></li></ul><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p><img src="/../img/osb/132.png"></p><p>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。</p><p>无结构文件:文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如:Windows操作系统中的.txt文件。</p><p>有结构文件:由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如:数据库表文件。一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID)</p><p>我们主要研究有结构文件。<br><img src="/../img/osb/133.png"></p><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><p>顺序文件:文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储（相当于数组）或链式存储（相当于链表）。</p><p>顺序存储又可以分为串结构和顺序结构。<br><img src="/../img/osb/134.png"></p><p>那么这几种存储方式可以快速找到第i个记录对应的地址呢？<br><img src="/../img/osb/135.png"></p><p>结论:定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取;若能再保证记录的顺序结构，则可实现快速检索(即根据关键字快速找到对应记录)</p><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>思考：对于可变长记录文件，要找到第i个记录，必须先顺序第查找前i-1个记录,但是很多应用场景中又必须使用可变长记录。如何解决这个问题?</p><p>这时我们可以建立一张索引表来快速找到第i个记录。如图所示：<br><img src="/../img/osb/136.png"><br><strong>索引表本身是定长记录的顺序文件</strong>。因此可以快速找到第i个记录对应的索引项。</p><p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。</p><p>每当要增加&#x2F;删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。</p><p>另外，可以用不同的数据项建立多个索引表。如:学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了。(Eg: SQL就支持根据某个数据项建立索引的功能)</p><h3 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h3><p>思考索引文件的缺点:每个记录对应一个索引表项，因此索引表可能会很大。比如:文件的每个记录平均只占8字节，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。</p><p>那么如何解决呢？</p><p>我们可以建立一个索引顺序文件。</p><p>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是:并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。</p><p>在本例中，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，分组内的记录不需要按关键字排序。<br><img src="/../img/osb/137.png"></p><h3 id="多级索引顺序文件"><a href="#多级索引顺序文件" class="headerlink" title="多级索引顺序文件"></a>多级索引顺序文件</h3><p>为了进一步提高检索效率，可以为顺序文件建立多级索引表。</p><p>例如，对于一个含10^6个记录的文件，可先为该文件建立一张低级索引表，每100个记录为一组，故低级索引表中共有10000个表项(即10000个定长记录)，再把这10000个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有100个表项。<br><img src="/../img/osb/138.png"></p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><img src="/../img/osb/139.png"><br>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件。如图所示<br><img src="/../img/osb/140.png"></p><h3 id="文件控制块（FCB）"><a href="#文件控制块（FCB）" class="headerlink" title="文件控制块（FCB）"></a>文件控制块（FCB）</h3><ul><li>目录文件中的一条记录就是一个“文件控制块（FCB)</li></ul><p>FCB的有序集合称为“文件目录”，一个FCB就是一个文件目录项。</p><p>FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读&#x2F;可写、禁止访问的用户名单等)，使用信息（如文件的建立时间、修改时间等）。</p><p>最重要，最基本的还是文件名、文件存放的物理地址。</p><h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><p><img src="/../img/osb/141.png"></p><h3 id="二级目录结构"><a href="#二级目录结构" class="headerlink" title="二级目录结构"></a>二级目录结构</h3><p><img src="/../img/osb/142.png"></p><h3 id="多级目录结构（树形目录结构）"><a href="#多级目录结构（树形目录结构）" class="headerlink" title="多级目录结构（树形目录结构）"></a>多级目录结构（树形目录结构）</h3><p><img src="/../img/osb/143.png"><br>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。</p><h3 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h3><p><img src="/../img/osb/144.png"><br>可以用不同的文件名指向同一个文件，甚至可以指向同一个目录(共享同一目录下的所有内容）。</p><p>需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。</p><p>只有共享计数器减为0时，才删除结点。</p><p>注意:共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</p><h3 id="索引结点（对FCB的改进）"><a href="#索引结点（对FCB的改进）" class="headerlink" title="索引结点（对FCB的改进）"></a>索引结点（对FCB的改进）</h3><p><img src="/../img/osb/145.png"><br>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p><p>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。相比之下内存索引结点中需要增加一些信息，比如:文件是否被修改、此时有几个进程正在访问该文件等。</p><h2 id="文件分配方式（文件物理结构）"><a href="#文件分配方式（文件物理结构）" class="headerlink" title="文件分配方式（文件物理结构）"></a>文件分配方式（文件物理结构）</h2><p><img src="/../img/osb/146.png"><br>在介绍这些分配方式之前，先介绍一下什么是文件块，磁盘块。</p><p>在内存管理中，进程的逻辑地址空间被分为一个一个页面。</p><p>同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”。</p><p>于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。</p><p>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射。<br><img src="/../img/osb/147.png"></p><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p><strong>连续分配方式要求每个文件在磁盘上占有一组连续的块</strong>。如图所示</p><p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB)</p><p><strong>物理块号&#x3D;起始块号＋逻辑块号</strong></p><p>当然，还需要检查用户提供的逻辑块号是否合法（逻辑块号≥长度就不合法)、</p><p>优点:支持顺序访问和直接访问（即随机访问)；连续分配的文件在顺序访问时速度最快</p><p>缺点:不方便文件拓展;存储空间利用率低，会产生磁盘碎片<br><img src="/../img/osb/148.png"></p><h3 id="链接分配——隐式链接"><a href="#链接分配——隐式链接" class="headerlink" title="链接分配——隐式链接"></a>链接分配——隐式链接</h3><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p><p>从逻辑块号到物理块号的转变<br>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项(FCB)</p><p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推。</p><p>因此，读入i号逻辑块，总共需要i+1次磁盘l&#x2F;O。</p><p>结论:采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。<br><img src="/../img/osb/149.png"></p><h3 id="链接分配——显式链接"><a href="#链接分配——显式链接" class="headerlink" title="链接分配——显式链接"></a>链接分配——显式链接</h3><p>把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表（FAT，File Allocation Table)。如图所示</p><p>注意:一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。</p><p>从逻辑块号到物理块号的转变<br>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项( FCB)</p><p>从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。逻辑块号转换成物理块号的过程不需要读磁盘操作。</p><p>结论:采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问i号逻辑块时，并不需要依次访问之前的 0~i-1号逻辑块)，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p><p>显然，显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。<br><img src="/../img/osb/150.png"></p><h3 id="两种链接分配方式总结"><a href="#两种链接分配方式总结" class="headerlink" title="两种链接分配方式总结"></a>两种链接分配方式总结</h3><p>隐式链接――除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p><ul><li>优点:很方便文件拓展，不会有碎片问题，外存利用率高。</li><li>缺点:只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul><p>显式链接――把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表（FAT，FileAllocation Table)。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p><ul><li>优点:很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li><li>缺点:文件分配表的需要占用一定的存储空间。</li></ul><h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><p>索引分配允许文件离散地分配在各个磁盘块中，<strong>系统会为每个文件建立一张索引表</strong>，索引表中记录了文件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表――建立逻辑页面到物理页之间的映射关系)。<strong>索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</strong></p><ul><li>从逻辑块号到物理块号的转变</li></ul><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项（FCB)</p><p>从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可知道i号逻辑块在外存中的存放位置。</p><p>可见，索引分配方式可以支持随机访问。文件拓展也很容易实现(只需要给文件分配一个空闲块，并增加一个索引表项即可)</p><p>但是索引表需要占用一定的存储空间<br><img src="/../img/osb/151.png"></p><ul><li>如果一个文件的索引表太大，一个磁盘块放不下，那么如何解决呢？</li></ul><p>可以用以下三种方式解决。</p><p>①链接方案:如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。<br><img src="/../img/osb/152.png"></p><p>②多层索引:建立多层索引（原理类似于多级页表)。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。<br><img src="/../img/osb/153.png"></p><p>③混合索引:多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引（指向两层索引表)。<br><img src="/../img/osb/154.png"></p><blockquote><p>总结</p></blockquote><p>①链接方案 : 如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。缺点:若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到i号索引块，必须先依次读入0~i-1号索引块，这就导致磁盘I&#x2F;O次数过多，查找效率低下。</p><p>②多层索引:建立多层索引(原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作。缺点:即使是小文件，访问一个数据块依然需要K+1次读磁盘。</p><p>③混合索引:多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引(指向两层索引表)。优点:对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p><h3 id="三种分配方式总结"><a href="#三种分配方式总结" class="headerlink" title="三种分配方式总结"></a>三种分配方式总结</h3><p><img src="/../img/osb/155.png"></p><h2 id="对空闲磁盘块的管理（文件存储空间管理）"><a href="#对空闲磁盘块的管理（文件存储空间管理）" class="headerlink" title="对空闲磁盘块的管理（文件存储空间管理）"></a>对空闲磁盘块的管理（文件存储空间管理）</h2><p><img src="/../img/osb/156.png"></p><h3 id="文件卷"><a href="#文件卷" class="headerlink" title="文件卷"></a>文件卷</h3><p>存储空间的划分:将物理磁盘划分为一个个文件卷(逻辑卷、逻辑盘)。所谓的文件卷就相当于电脑上的C盘，D盘等。<br><img src="/../img/osb/157.png"></p><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>为一个磁盘创建一个表，来存储空闲磁盘块的位置。</p><p>如何分配磁盘块 : 与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p><p>如何回收磁盘块:与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况―—①回收区的前后都没有相邻空闲区;②回收区的前后都是空闲区;③回收区前面是空闲区;④回收区后面是空闲区。总之，回收时需要注意表项的合并问题。<br><img src="/../img/osb/158.png"></p><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>空闲链表发分为空闲盘块链和空闲盘区链。<br><img src="/../img/osb/159.png"></p><h4 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h4><ul><li>操作系统保存着链头、链尾指针。</li><li>如何分配:若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。</li><li>如何回收:回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</li><li>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作。<br><img src="/../img/osb/160.png"></li></ul><h4 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h4><ul><li>操作系统保存着链头、链尾指针。</li><li>如何分配:若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</li><li>如何回收:若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</li><li>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高<br><img src="/../img/osb/161.png"></li></ul><h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><p>位示图:每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中一个字的字长是16位，字中的每一位对应一个盘块。因此可以用(字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号)</p><p>(字号,位号)&#x3D;(i j) 的二进制位对应的盘块号 b&#x3D; ni + j</p><p>b号盘块对应的字号i &#x3D; b&#x2F;n，位号j &#x3D; b%n。</p><p>如何分配:若文件需要K个块，</p><p>①顺序扫描位示图，找到K个相邻或不相邻的“0”;</p><p>②根据字号、位号算出对应的盘块号，将相应盘块分配给文件;</p><p>③将相应位设置为“1”。</p><p>如何回收:</p><p>①根据回收的盘块号计算出对应的字号、位号;</p><p>②将相应二进制位设为“0”。<br><img src="/../img/osb/162.png"></p><h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了成组链接法对磁盘空闲块进行管理。<br>文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致。如图所示。<br><img src="/../img/osb/163.png"></p><ul><li>超级块中存储的内容<br><img src="/../img/osb/164.png"></li><li>如何分配?<br>Eg :需要100个空闲块<br>①检查第一个分组的块数是否足够。100&#x3D;100，是足够的。</li></ul><p>②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中。</p><p>Eg :需要1个空闲块<br>①检查第一个分组的块数是否足够。1&lt;100，因此是足够的。</p><p>②分配第一个分组中的1个空闲块，并修改相应数据</p><ul><li>如何回收?<br>Eg :假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块。</li></ul><p>Eg : 假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</p><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>进行Create系统调用时，需要提供的几个主要参数:</p><ol><li><p>所需的外存空间大小（如:一个盘块，即1KB)</p></li><li><p>文件存放路径（“D:&#x2F;Demo”)</p></li><li><p>文件名（这个地方默认为“新建文本文档.txt”)</p></li></ol><p>操作系统在处理Create系统调用时，主要做了两件事:</p><p>1.在外存中找到文件所需的空间（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间)<br>2.根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:&#x2F;Demo目录），在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>进行Delete系统调用时，需要提供的几个主要参数:</p><p>1.文件存放路径（“D:&#x2F;Demo”)</p><p>2.文件名（“test.txt”)</p><p>操作系统在处理Delete系统调用时，主要做了几件事:</p><p>1．根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</p><p>2．根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理)</p><p>3.从目录表中删除文件对应的目录项。</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数:<br>1．文件存放路径（“D:&#x2F;Demo”)</p><p>2.文件名（ “test.txt”)</p><p>3．要对文件的操作类型（如:r只读;rw读写等)</p><p>操作系统在处理open系统调用时，主要做了几件事:</p><p>1．根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。</p><p>2．将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。<br><img src="/../img/osb/165.png"></p><ul><li>需要注意的是，有两张打开文件表，一个是进程自带的，另一个是系统的（只有一张）。<br><img src="/../img/osb/166.png"></li></ul><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>进程使用完文件后，要“关闭文件”。<br>操作系统在处理Close系统调用时，主要做了几件事:</p><p>1.将进程的打开文件表相应表项删除</p><p>2.回收分配给该文件的内存空间等资源</p><p>3.系统打开文件表的打开计数器count 减1，若count &#x3D;0，则删除对应表项。</p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>进程使用read系统调用完成写操作。</p><p>需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可)，</p><p>还需要指明要读入多少数据（如:读入1KB）、</p><p>指明读入的数据要放在内存中的什么位置。</p><p>操作系统在处理read 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>进程使用write系统调用完成写操作，</p><p>需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），</p><p>还需要指明要写出多少数据（如:写出1KB)、</p><p>写回外存的数据放在内存中的什么位置</p><p>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><h3 id="基于索引节点的共享方式（硬链接）"><a href="#基于索引节点的共享方式（硬链接）" class="headerlink" title="基于索引节点的共享方式（硬链接）"></a>基于索引节点的共享方式（硬链接）</h3><p>知识回顾:索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。<br><img src="/../img/osb/167.png"></p><p>索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。<br>若count &#x3D;2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1。<br>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。当count &#x3D;0时系统负责删除文件。</p><h3 id="基于符号链的共享方式（软链接）"><a href="#基于符号链的共享方式（软链接）" class="headerlink" title="基于符号链的共享方式（软链接）"></a>基于符号链的共享方式（软链接）</h3><p>当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。类似于快捷方式。<br><img src="/../img/osb/168.png"></p><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><h3 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h3><p>为文件设置一个“口令”(如: abc112233），用户请求访问该文件时必须提供“口令”。</p><p>口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件。</p><p>优点:保存口令的空间开销不多，验证口令的时间开销也很小。</p><p>缺点:正确的“口令”存放在系统内部，不够安全。</p><h3 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h3><p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。<br>Eg:一个最简单的加密算法――异或加密。<br>假设用于加密&#x2F;解密的“密码”为“01001”。<br><img src="/../img/osb/169.png"></p><p>优点:保密性强，不需要在系统中存储“密码”。</p><p>缺点:编码&#x2F;译码，或者说加密&#x2F;解密要花费一定时间。</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>在每个文件的FCB（或索引结点）中增加一个访问控制列表(Access-Control List, ACL)，该表中记录了各个用户可以对该文件执行哪些操作。如图所示：<br><img src="/../img/osb/170.png"></p><p>精简的访问列表:以“组”为单位，标记各“组”用户可以对文件执行哪些操作。如:分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="/../img/osb/171.png"></p><h2 id="文件的层次结构"><a href="#文件的层次结构" class="headerlink" title="文件的层次结构"></a>文件的层次结构</h2><p><img src="/../img/osb/172.png"></p><p>用一个例子来辅助记忆文件系统的层次结构:</p><p>假设某用户请求删除文件“D:&#x2F;工作目录&#x2F;学生信息.xlsx”的最后100条记录。</p><ol><li>用户需要通过操作系统提供的接口发出上述请求一用户接口。</li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项――文件目录系统</li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限―一存取控制模块（存取控制验证层)</li><li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址――逻辑文件系统与文件信息缓冲区</li><li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址――物理文件系统</li><li>要删除这条记录，必定要对磁盘设备发出请求――设备管理程序模块</li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收――辅助分配模块。</li></ol><h1 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I&#x2F;O管理"></a>I&#x2F;O管理</h1><h2 id="I-O设备的概念"><a href="#I-O设备的概念" class="headerlink" title="I&#x2F;O设备的概念"></a>I&#x2F;O设备的概念</h2><ul><li>“I&#x2F;O” 就是“输入&#x2F;输出”(Input&#x2F;Output)</li><li>I&#x2F;O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</li></ul><h2 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I&#x2F;O控制器"></a>I&#x2F;O控制器</h2><h3 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h3><ul><li>CPU无法直接控制l&#x2F;O设备的机械部件，因此I&#x2F;O设备还要有一个电子部件作为CPU和I&#x2F;O设备机械部件之间的“中介”，用于实现CPU对设备的控制。</li><li>这个电子部件就是I&#x2F;O控制器，又称设备控制器。CPU可控制I&#x2F;o控制器，又由I&#x2F;O控制器来控制设备的机械部件。</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><img src="/../img/osb/189.png"></p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="/../img/osb/189.png"></p><h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h2><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><ul><li>完成一次读&#x2F;写操作的流程图(以读操作为例)<br><img src="/../img/osb/190.png"></li><li>流程图<br><img src="/../img/osb/191.png"></li></ul><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><ul><li>由于程序直接控制方式CPU利用率低，忙等，所以提出了中断驱动方式。<br><img src="/../img/osb/192.png"><br><img src="/../img/osb/193.png"></li></ul><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><ul><li><p>虽然中断驱动方式解决了程序直接控制方式的问题，但是每一次只能读&#x2F;写一个字，导致CPU频繁切换，耗费了很多时间。于是人们又发明了DMA方式。<br><img src="/../img/osb/194.png"></p></li><li><p>DMA控制器<br><img src="/../img/osb/195.png"><br><img src="/../img/osb/196.png"></p></li></ul><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><ul><li>通道控制方式是为了解决DMA方式连续存储的问题<br><img src="/../img/osb/197.png"><br><img src="/../img/osb/198.png"></li></ul><h3 id="四种方式总结"><a href="#四种方式总结" class="headerlink" title="四种方式总结"></a>四种方式总结</h3><p><img src="/../img/osb/199.png"></p><h2 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I&#x2F;O软件层次结构"></a>I&#x2F;O软件层次结构</h2><h3 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h3><p><img src="/../img/osb/200.png"></p><h3 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h3><ul><li>用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与I&#x2F;o操作相关的库函数对设备进行操作。</li><li>用户层软件将用户请求翻译成格式化的I&#x2F;o请求，并通过“系统调用”请求操作系统内核的服务。<br><img src="/../img/osb/201.png"></li></ul><h3 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h3><p>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>主要功能：</p><ol><li>向上层提供统一的调用接口（如read&#x2F;write系统调用)</li><li>设备的保护。（原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。）</li><li>差错处理（设备独立性软件需要对一些设备的错误进行处理）</li><li>设备的分配与回收</li><li>数据缓冲区管理（可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异）</li><li>建立逻辑设备名到物理设备名的映射关系;根据设备类型选择调用相应的驱动程序</li></ol><p>用户或用户层软件发出I&#x2F;o操作相关系统调用的系统调用时，需要指明此次要操作的I&#x2F;o设备的逻辑设备名（eg:去学校打印店打印时，需要选择打印机1&#x2F;打印机2&#x2F;打印机3，其实这些都是逻辑设备名)</p><p>设备独立性软件需要通过“逻辑设备表（LUT，Logical UnitTable）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。如图所示：<br><img src="/../img/osb/202.png"></p><p>操作系统系统可以采用两种方式管理逻辑设备表(LUT) :<br>第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</p><p>第二种方式，为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</p><h3 id="驱动设备"><a href="#驱动设备" class="headerlink" title="驱动设备"></a>驱动设备</h3><p>思考:为何不同的设备需要不同的设备驱动程序?</p><p>不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p><p><img src="/../img/osb/203.png"></p><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>当I&#x2F;o任务完成时，I&#x2F;o控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下:<br><img src="/../img/osb/204.png"> </p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="/../img/osb/205.png"></p><h2 id="I-O核心子系统"><a href="#I-O核心子系统" class="headerlink" title="I&#x2F;O核心子系统"></a>I&#x2F;O核心子系统</h2><h3 id="知识总览-1"><a href="#知识总览-1" class="headerlink" title="知识总览"></a>知识总览</h3><p><img src="/../img/osb/206.png"></p><ul><li>这些功能在哪些层次上实现呢？<br><img src="/../img/osb/207.png"></li></ul><h3 id="I-O调度"><a href="#I-O调度" class="headerlink" title="I&#x2F;O调度"></a>I&#x2F;O调度</h3><p>I&#x2F;O调度:<strong>用某种算法确定一个好的顺序来处理各个I&#x2F;o请求。</strong><br>如:磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。</p><p>当多个磁盘I&#x2F;o请求到来时，用某种调度算法确定满足I&#x2F;o请求的顺序。</p><p>同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定IV&#x2F;o调度顺序。</p><h3 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h3><p>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限（如:只读、读和写等）。<br>在UNIx系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。(参考“文件保护”小节)</p><h2 id="假脱机技术（SPOOLing技术）"><a href="#假脱机技术（SPOOLing技术）" class="headerlink" title="假脱机技术（SPOOLing技术）"></a>假脱机技术（SPOOLing技术）</h2><h3 id="脱机技术"><a href="#脱机技术" class="headerlink" title="脱机技术"></a>脱机技术</h3><ul><li>手工操作阶段:主机直接从l&#x2F;o设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。因此在批处理阶段引入了脱机输入&#x2F;输出技术（用磁带完成).</li></ul><p>Tips:为什么称为“脱机”？一脱离主机的控制进行的输入&#x2F;输出操作。<br><img src="/../img/osb/208.png"></p><h3 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h3><p>“假脱机技术”，又称“SPOOLing 技术”，用软件的方式模拟脱机技术。SPOQLing系统的组成如下:</p><ul><li>“输入井”模拟脱机输入时的磁带，用于收容I&#x2F;o设备输入的数据</li><li>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据</li><li>“输入进程”模拟脱机输入时的外围控制机</li><li>“输出进程”模拟脱机输出时的外围控制机<br><img src="/../img/osb/209.png"></li></ul><p>要实现SPOOLing 技术，必须要有多道程序技术的支持。系统会建立“输入进程”和“输出进程”。</p><h2 id="设备的分配和回收"><a href="#设备的分配和回收" class="headerlink" title="设备的分配和回收"></a>设备的分配和回收</h2><h3 id="知识总览-2"><a href="#知识总览-2" class="headerlink" title="知识总览"></a>知识总览</h3><p><img src="/../img/osb/210.png"></p><h3 id="设备分配时考虑的因素"><a href="#设备分配时考虑的因素" class="headerlink" title="设备分配时考虑的因素"></a>设备分配时考虑的因素</h3><p><img src="/../img/osb/211.png"></p><h3 id="固有属性"><a href="#固有属性" class="headerlink" title="固有属性"></a>固有属性</h3><p>设备的固有属性可分为三种:独占设备、共享设备、虚拟设备。</p><p>独占设备—— 一个时段只能分配给一个进程（如打印机)<br>共享设备――可同时分配给多个进程使用（如磁盘)，各进程往往是宏观上同时共享使用设备，而微观上交替使用。<br>虚拟设备――采用SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机）</p><h3 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h3><p>先来先服务，优先级高者优先，短任务优先…….</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>从进程运行的安全性上考虑，设备分配有两种方式:</p><p><strong>安全分配方式</strong>:为进程分配一个设备后就将进程阻塞，本次I&#x2F;O完成后才将进程唤醒。(eg:考虑进程请求打印机打印输出的例子)</p><ul><li>一个时段内每个进程只能使用一个设备</li><li>优点:破坏了“请求和保持”条件，不会死锁</li><li>缺点:对于一个进程来说，CPU和I&#x2F;o设备只能串行工作</li></ul><p><strong>不安全分配方式</strong>:进程发出I&#x2F;o请求后，系统为其分配I&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;o请求。只有某个l&#x2F;o请求得不到满足时才将进程阻塞。</p><ul><li>一个进程可以同时使用多个设备</li><li>优点:进程的计算任务和I&#x2F;o任务可以并行处理，使进程迅速推进</li><li>缺点:有可能发生死锁(死锁避免、死锁的检测和解除)</li></ul><h3 id="静态分配和动态分配"><a href="#静态分配和动态分配" class="headerlink" title="静态分配和动态分配"></a>静态分配和动态分配</h3><ul><li>静态分配:进程运行前为其分配全部所需资源，运行结束后归还资源。破坏了“请求和保持”条件，不会发生死锁</li><li>动态分配:进程运行过程中动态申请设备资源</li></ul><h3 id="设备分配中的数据结构"><a href="#设备分配中的数据结构" class="headerlink" title="设备分配中的数据结构"></a>设备分配中的数据结构</h3><p>“设备、控制器、通道”之间的关系:<br><img src="/../img/osb/212.png"></p><ul><li>**设备控制表（DCT)**：系统为每个设备配置一张DCT，用于记录设备情况<br><img src="/../img/osb/213.png"></li><li><strong>控制器控制表(COCT)</strong>:每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。<br><img src="/../img/osb/214.png"></li><li>**通道控制表（CHCT)**：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。<br><img src="/../img/osb/215.png"></li><li><strong>系统设备表(SDT)</strong>:记录了系统中全部设备的情况，每个设备对应一个表目。<br><img src="/../img/osb/216.png"></li></ul><h3 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h3><p>①根据进程请求的物理设备名查找SDT（注:物理设备名是进程请求分配设备时提供的参数)</p><p>②根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</p><p>③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</p><p>④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</p><p>注∶只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可后动&#x2F;O设备进行数据传送。</p><p>缺点:<br>①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</p><p>②若换了一个物理设备，则程序无法运行</p><p>③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</p><p>改进方法:建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名<br><img src="/../img/osb/217.png"></p><h3 id="设备分配步骤的改进"><a href="#设备分配步骤的改进" class="headerlink" title="设备分配步骤的改进"></a>设备分配步骤的改进</h3><p>①根据进程请求的逻辑设备名查找SDT(注:用户编程时提供的逻辑设备名其实就是“设备类型”)</p><p>②查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT)中新增一个表项。</p><p>③根据DCT找到cOCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</p><p>④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。<br><img src="/../img/osb/218.png"></p><ul><li>逻辑设备表<br><img src="/../img/osb/219.png"></li></ul><h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><h3 id="知识总览-3"><a href="#知识总览-3" class="headerlink" title="知识总览"></a>知识总览</h3><p><img src="/../img/osb/220.png"></p><h3 id="含义和作用"><a href="#含义和作用" class="headerlink" title="含义和作用"></a>含义和作用</h3><blockquote><p>含义</p></blockquote><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p><p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本)</p><p>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</p><blockquote><p>作用<br><img src="/../img/osb/221.png"></p></blockquote><h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p>假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。如图所示<br><strong>注意:当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</strong><br><img src="/../img/osb/222.png"></p><ul><li>处理一块数据的平均时间<br><img src="/../img/osb/223.png"></li></ul><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块)。</p><ul><li><p>假设T&gt;C+M<br><img src="/../img/osb/224.png"></p></li><li><p>假设T&lt;C+M<br><img src="/../img/osb/225.png"></p></li></ul><p>**结论:采用双缓冲策略，处理一个数据块的平均耗时为Max (T,C+M)**。</p><h3 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h3><p>将多个大小相等的缓冲区链接成一个循环队列。<br>注:以下图示中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。<br><img src="/../img/osb/226png"></p><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池由系统中共用的缓冲区组成。</p><p>这些缓冲区按使用状况可以分为:空缓冲队列、装满输入数据的缓冲队列(输入队列)、装满输出数据的缓冲队列（输出队列）。</p><p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区:用于收容输入数据的工作缓冲区(hin)、用于提取输入数据的工作缓冲区（sin)、用于收容输出数据的工作缓冲区(hout） 、用于提取输出数据的工作缓冲区(sout)。<br><img src="/../img/osb/227.png"></p><h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><ul><li><p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p></li><li><p>磁盘的盘面被划分成一个个磁道。这样的一个“圈”就是一个磁道。</p></li><li><p>一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同（如1KB)。<br><img src="/../img/osb/173.png"></p></li><li><p>所有盘面中相对位置相同的磁道组成柱面。<br><img src="/../img/osb/174.png"></p></li><li><p>可用(柱面号，盘面号，扇区号）来定位任意一个“磁盘块”。</p></li><li><p>可根据该地址读取一个“块”<br>①根据“柱面号”移动磁臂，让磁头指向指定柱面;<br>②激活指定盘面对应的磁头;<br>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写。</p></li><li><p>磁盘分类<br><img src="/../img/osb/175.png"></p></li></ul><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h3 id="一次磁盘读-写操作需要的时间"><a href="#一次磁盘读-写操作需要的时间" class="headerlink" title="一次磁盘读&#x2F;写操作需要的时间"></a>一次磁盘读&#x2F;写操作需要的时间</h3><p><img src="/../img/osb/176.png"></p><ul><li><p>寻找时间(寻道时间)Ts:在读&#x2F;写数据前，将磁头移动到指定磁道所花的时间。<br>①启动磁头臂是需要时间的。假设耗时为s;<br>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则:<br>寻道时间Ts &#x3D; s + m*n</p></li><li><p>延迟时间T:通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r(单位:转&#x2F;秒，或转&#x2F;分），则平均所需的延迟时间T&#x3D;(1&#x2F;2)*(1&#x2F;r)&#x3D; 1&#x2F;2r。</p></li></ul><p>1&#x2F;r就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以1&#x2F;2</p><ul><li>传输时间Tt:从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读&#x2F;写的字节数为b，每个磁道上的字节数为N。则:<br>传输时间Tt &#x3D; (1&#x2F;r)*(b&#x2F;N) &#x3D; b&#x2F;(rN)</li></ul><p>每个磁道要可存N字节的数据，因此b字节的数据需要b&#x2F;N个磁道才能存储。而读&#x2F;写一个磁道所需的时间刚好又是转一圈所需要的时间1&#x2F;r。</p><ul><li>总的平均存取时间 T&#x3D;Ts+ 1&#x2F;2r + b&#x2F;(rN)</li></ul><p>延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间。但是操作系统的磁盘调度算法会直接影响寻道时间。</p><h3 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h3><ul><li>根据进程请求访问磁盘的先后顺序进行调度。<br><img src="/../img/osb/177.png"></li></ul><h3 id="最短寻找时间优先（SSTF）"><a href="#最短寻找时间优先（SSTF）" class="headerlink" title="最短寻找时间优先（SSTF）"></a>最短寻找时间优先（SSTF）</h3><p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)<br><img src="/../img/osb/178.png"></p><h3 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h3><p>SSTF算法会产生饥饿的原因在于:磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法（SCAN)的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。<br><img src="/../img/osb/179.png"></p><h3 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h3><p>扫描算法（SCAN)中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。LOOK调度算法就是为了解决这个问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。(边移动边观察，因此叫LOOK)。<br><img src="/../img/osb/180.png"></p><h3 id="循环扫描算法（C—SCAN）"><a href="#循环扫描算法（C—SCAN）" class="headerlink" title="循环扫描算法（C—SCAN）"></a>循环扫描算法（C—SCAN）</h3><p>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。<br><img src="/../img/osb/181.png"></p><h3 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h3><p>C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。<br><img src="/../img/osb/182.png"></p><h3 id="减少延迟时间的方法"><a href="#减少延迟时间的方法" class="headerlink" title="减少延迟时间的方法"></a>减少延迟时间的方法</h3><p><img src="/../img/osb/183.png"></p><p>假设要连续读取橙色区域的2、3、4扇区:<br>磁头读取一块的内容（也就是一个扇区的内容）后，需要一小段时间处理，而盘片又在不停地旋转<br>因此，如果2、3号扇区相邻着排列，则读完2号扇区后无法连续不断地读入3号扇区<br>必须等盘片继续旋转，3号扇区再次划过磁头，才能完成扇区读入。</p><p>结论:磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”。<br><img src="/../img/osb/184.png"></p><h3 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h3><p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。如图所示。<br><img src="/../img/osb/185.png"></p><h3 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a>磁盘地址结构的设计</h3><p>思考:为什么磁盘的物理地址是（柱面号，盘面号，扇区号)，而不是(盘面号，柱面号，扇区号)？</p><p>答:读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间</p><p>注：不是很理解</p><h3 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h3><p><img src="/../img/osb/186.png"><br><img src="/../img/osb/187.png"></p><h2 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h2><h3 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h3><p>磁盘初始化:<br>Step 1:进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)</p><p>Step 2:将磁盘分区，每个分区由若干柱面（磁道）组成（即分为我们熟悉的C盘、D盘、E盘)</p><p>step 3:进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表)<br><img src="/../img/osb/188.png"></p><h3 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h3><ul><li><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。</p></li><li><p>初始化程序可以放在ROM(只读存储器）中。ROM中的数据在出厂时就写入了，并且以后不能再修改 。</p></li></ul><p>初始化程序程序（自举程序）放在ROM中存在什么问题?万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改。如何解决呢?</p><ul><li><p>ROM中只存放很小的“自举装入程序”。开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化</p></li><li><p>完整的自举程序放在磁盘的启动块(即引导块&#x2F;启动分区)上，启动块位于磁盘的固定位置。</p></li><li><p>拥有启动分区的磁盘称为启动磁盘或系统磁盘（c:盘)</p></li></ul><h3 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h3><ul><li><p>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它。</p></li><li><p>对于简单的磁盘，可以在逻辑格式化时（建立文件系统时)对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如:在FAT表上标明。（在这种方式中，坏块对操作系统不透明)</p></li><li><p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。<br>在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。<br>会保留一些“备用扇区”，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。**</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统</title>
    <link href="/2024/10/08/os/"/>
    <url>/2024/10/08/os/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>框架图<br><img src="/../img/os/os.png"></p><h2 id="解释什么是操作系统"><a href="#解释什么是操作系统" class="headerlink" title="解释什么是操作系统"></a>解释什么是操作系统</h2><p>计算机简易构图<br><img src="/../img/os/simpleComputer.png"><br>操作系统是运用在硬件上的一层软件<br>工具使得操作系统更加完善<br><strong>四种观点</strong></p><ul><li>从外部看os<ul><li>用户使用环境：计算机用户使用计算机系统的接口，为计算机用户提供了方便的工作环境</li><li>虚拟机的观点：os是建立在计算机硬件平台上的虚拟机器，提供了许多硬件更强或者没有的功能</li></ul></li><li>从内部看os<ul><li>资源管理观点:os是计算机系统中各类资源的管理者，负责分配，回收以及控制系统中的软硬件资源</li><li>作业组织观点：os是计算机系统流程的组织者，协调各个应用软件的运行次序</li></ul></li></ul><p>软件工程的特点：需求分析-&gt;系统设计-&gt;编码实现-&gt;产品升级<br>软件系统需求：</p><ul><li>软件系统能提供的服务</li><li>软件系统在提供这些服务，需要满足的限制条件</li><li>软件系统具有适应某些变化的能力</li></ul><p>第一个需求是后两个系统需求存在的基础，称为软件功能性需求，后两个是系统的非功能性需求</p><h2 id="os系统功能性需求"><a href="#os系统功能性需求" class="headerlink" title="os系统功能性需求"></a>os系统功能性需求</h2><ul><li>计算机用户需要用户命令：所有用户命令所构成的集合常被称为os的用户接口或者叫命令接口</li><li>应用软件需要系统调用：系统调用所构成的集合被称为程序接口或应用程序接口（API)</li></ul><p><img src="/../img/os/functional.png"><br>用户命令：指计算机用户要求计算机系统为其工作的指示<br>命令表示形式：</p><ul><li>字符形式</li><li>菜单形式</li><li>图形形式</li></ul><p>命令使用方式：</p><ul><li>脱机使用：不受该系统的控制</li><li>联机使用</li></ul><h3 id="os系统非功能性需求"><a href="#os系统非功能性需求" class="headerlink" title="os系统非功能性需求"></a>os系统非功能性需求</h3><ul><li>性能和效率<br>吞吐量：单位时间内完成的工作量<br>响应时间<br>分时系统用户数的支持量</li><li>公平性</li><li>可靠性</li><li>安全性</li><li>可伸缩性</li><li>可扩展性</li><li>可移植性</li></ul><h2 id="重要的基本概念"><a href="#重要的基本概念" class="headerlink" title="重要的基本概念"></a>重要的基本概念</h2><h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p><strong>概念</strong>：计算机用户在一次上机过程中要求计算机系统为其所做工作的集合；作业中每项相对独立的工作称为作业步<br><strong>基本类型</strong></p><ul><li>脱机作业： 计算机用户不能在此类作业被计算机系统处理时改变已定义好的作业步（交互性差）</li><li>联机作业： 计算机用户可以在此类作业被计算机系统处理时随时改变其作业步</li></ul><h4 id="线序和进程"><a href="#线序和进程" class="headerlink" title="线序和进程"></a>线序和进程</h4><p><strong>概念</strong></p><ul><li>线程：程序的一次相对独立的运行过程；线程是系统调度的最小单位</li><li>进程：系统分配资源的基本对象，系统中拥有资源的最小实体</li></ul><p>线程归属于某些进程，线程是可以使用进程里面的资源，调度是看线程的调度</p><h4 id="虚拟存储和文件"><a href="#虚拟存储和文件" class="headerlink" title="虚拟存储和文件"></a>虚拟存储和文件</h4><p>概念：</p><ul><li>虚拟存储：进程的逻辑地址空间，os对计算机系统中多级物理存储体系进行高度抽象的结果<br>虚拟存储可以将实际空间虚拟扩大，就是将外存一部分虚拟成内存使用</li><li>文件：命了名的字节流，对计算机系统中种类繁多的外部设备进行高度抽象的结果</li></ul><p>道：指运行在系统里面的进程数量和进程<br>批处理：有一批作业等待进去内存</p><h4 id="单批道处理系统"><a href="#单批道处理系统" class="headerlink" title="单批道处理系统"></a>单批道处理系统</h4><p><strong>描述</strong>：内存里面始终只有一道程序驻留在里面，占用了处理器，占用现在计算机资源<br>处理器必须等待I&#x2F;O指令才能往前推进<br><strong>特点</strong>：效率低</p><h4 id="多批道处理系统"><a href="#多批道处理系统" class="headerlink" title="多批道处理系统"></a>多批道处理系统</h4><p>描述：一个系统允许多道程序同时准备运行，当正在运行的那道程序因为某种原因暂时停止运行，系统将自动启动另外一道程序运行，一旦原因消除时，它在将在某个时候重启继续运行<br>允许多道程序同时准备运行实际上指内存还要排队</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>同步是操作系统里面是协调，保证一个等待I&#x2F;O进程能收到信号</p><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>有些资源是互斥资源，不能让两个进程或者两个任务同时运行这个资源<br>比如买飞机票，没有互斥机制，可能会出现一张票属于多个人<br>进程之间互相干扰，可能会对结果有影响</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>一个重要引起原因是竞争资源，各个进程都在抢资源，无法继续运行</p><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>是一个多道系统，在系统内部的内存空间里面是存在多道任务的，增加了每个任务的时间上的限制，非常合适交互系统，时间到了，需要中断进程，消耗资源，<br>作业在系统里面排队，排队以后按照分时的机制来实现服务</p><h4 id="多道和分时系统之间比较"><a href="#多道和分时系统之间比较" class="headerlink" title="多道和分时系统之间比较"></a>多道和分时系统之间比较</h4><p>多道批处理系统：处理器的利用效率高，需要作业语言控制相应的命令<br>分时系统：响应时间短，用终端来提交响应的命令</p><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h2><h3 id="程序的执行顺序与并发执行"><a href="#程序的执行顺序与并发执行" class="headerlink" title="程序的执行顺序与并发执行"></a>程序的执行顺序与并发执行</h3><p>程序的执行顺序：</p><ul><li>程序顺序执行：顺序性、封闭性，可再现性</li><li>程序并发执行：间断性、非封闭性，不可再性</li><li>程序并行执行条件（Bernstein条件）<br>两个进程之间读取变量之间不应该有交集<br>读这个进程里面的数据然后再去修改他，和另外的进程的读和修改，必须得先完成前者得读，修改，再去完成第二件事得读与修改</li></ul><h3 id="进程得概念与进程得并发执行"><a href="#进程得概念与进程得并发执行" class="headerlink" title="进程得概念与进程得并发执行"></a>进程得概念与进程得并发执行</h3><p>进程通常也叫做任务</p><h4 id="概念：进程是程序再一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位"><a href="#概念：进程是程序再一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位" class="headerlink" title="概念：进程是程序再一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位"></a>概念：进程是程序再一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位</h4><p>是可并发执行的程序再一个数据集合上运行的过程<br>进程是可以被跟踪得到 —— 用他的执行指令的序列<br>进程的特点</p><ul><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li></ul><p>进程结构</p><ul><li>程序</li><li>数据</li><li>PCB（控制程序的执行）</li></ul><p>进程的状态：</p><ul><li>进程的并发执行</li><li>进程的2状态</li><li>进程的5状态</li><li>进程状态转换图</li></ul><h4 id="程序的并发执行的理解"><a href="#程序的并发执行的理解" class="headerlink" title="程序的并发执行的理解"></a>程序的并发执行的理解</h4><p>例子：假设内存中有3个进程ABC，他们的程序代码已经全部装入内存，若A,C进程需要执行12条指令，且B进程执行到第四条指令必须等待I&#x2F;O。如何追踪他们的执行过程？</p><ul><li>分派程序：将处理器分配给一个进程</li><li>程序计算器：记载当前执行到哪个程序的第几条指令<br><img src="/../img/os/bingfa.png"><br>先是A执行六条语句，时钟中断然后执行调度程序，然后到B的执行，B四条语句后中断，然后执行调度程序，然后到C程序执行，也是执行六条语句，时钟到了，然后中断，轮着执行。<br><strong>总结与问题</strong><br>A,B,C三个程序交替执行<br>调度程序是属于应用程序还是系统程序？<br>是系统程序，按双模型来理解，就是有进程之间的切换</li></ul><h3 id="进程的两状态和五状态"><a href="#进程的两状态和五状态" class="headerlink" title="进程的两状态和五状态"></a>进程的两状态和五状态</h3><h4 id="两状态"><a href="#两状态" class="headerlink" title="两状态"></a>两状态</h4><ul><li>执行</li><li>非执行<br><strong>状态转换图</strong><br><img src="/../img/os/2zhuangtaizhuan.png"><br>注：</li><li>并非所有进程只要在非执行处于就绪状态，有的需要阻塞等待I&#x2F;O完成</li><li>非执行又可以分成就绪和阻塞状态</li></ul><h4 id="五状态"><a href="#五状态" class="headerlink" title="五状态"></a>五状态</h4><ul><li>执行：占用处理机</li><li>就绪：准备执行</li><li>阻塞：等待某事件发生才能执行</li><li>新状态：进程已经创建，还未被os接纳为可执行进程</li><li>退出：又叫做僵死状态，因停止或取消，被os从执行状态释放<br><strong>五状态转换图</strong><br>！<a href="../img/os/5zhuangtai.png"></a><br><strong>五队列转换图</strong><br>！<a href="../img/os/5duilie.png"></a><blockquote><p>要根据不同的事件进入不同的阻塞队列</p></blockquote></li></ul><h3 id="对交换技术"><a href="#对交换技术" class="headerlink" title="对交换技术"></a>对交换技术</h3><p>概念：</p><ul><li>将内存中暂时不能运行的进程，或暂时不用的数据和程序，交换到外存，以腾空足够的内存空间，吧已具备运行条件的进程，或 进程所需要的数据和程序，交换到内存里</li></ul><h3 id="进程的挂起状态"><a href="#进程的挂起状态" class="headerlink" title="进程的挂起状态"></a>进程的挂起状态</h3><p><strong>原因</strong>： </p><ul><li>处理器比I&#x2F;O速度快很多，所有进程都在等I&#x2F;O ——处理器空闲</li><li>操作系统挂起程序来释放空间</li><li>周期性执行的工具软件</li><li>交互式用户请求</li><li>时钟中断</li></ul><p><strong>特征：</strong></p><ul><li>不能立即执行</li><li>可能是等待某事情发生，若是阻塞条件独立与挂起条件，即使阻塞结束，但是程序还是不能执行</li><li>使之挂起的进程为：自身，其父程序，os</li><li>只有挂起它的进程才能是它的由挂起状态转变为其他状态</li></ul><p><strong>挂起与阻塞的区别：</strong></p><ul><li>挂起是基于交换技术的，只有当数据和程序回来，才解除挂起<br>问题：</li><li>是否只能挂起阻塞进程？<br>不一定，优先挂起阻塞进程，可以提高性能</li><li>如何激活一个挂起程序？<br>数据和程序返回来，其实就是一个I&#x2F;O过程</li></ul><p><strong>四种状态组合</strong></p><ul><li>就绪</li><li>阻塞</li><li>就绪，挂起：进程在外存，只要调入内存即可执行</li><li>阻塞，挂起：进程在外存，等待事件<blockquote><p>注：<br>处理机可调度执行的进程由两种：</p><ul><li>新创建的进程</li><li>或换入一个以前挂起的进程<br>通常为避免增加系统的负载，系统会换入一个以前挂起的进程执行</li></ul></blockquote></li></ul><h3 id="具有挂起状态的进程转换"><a href="#具有挂起状态的进程转换" class="headerlink" title="具有挂起状态的进程转换"></a>具有挂起状态的进程转换</h3><p><strong>状态转换图</strong><br><img src="/../img/os/7zhuangtai.png"><br><strong>从阻塞，挂起状态变到就绪，挂起？</strong><br>操作系统来执行这个转变，状态在PCB里面</p><h3 id="操作系统如何管理进程所用的资源"><a href="#操作系统如何管理进程所用的资源" class="headerlink" title="操作系统如何管理进程所用的资源"></a>操作系统如何管理进程所用的资源</h3><p>os如何感知进程，控制进程及其所用的资源资源？<br>用表记录进程和资源的当前的状态</p><ul><li>内存表</li><li>I&#x2F;O表</li><li>文件表</li><li>进程表</li></ul><h4 id="内存表"><a href="#内存表" class="headerlink" title="内存表"></a>内存表</h4><ul><li>进程的分配情况</li><li>外存分配情况</li><li>访问共享内存区的保护属性</li><li>管理虚拟存储需要的信息</li></ul><h4 id="I-O表"><a href="#I-O表" class="headerlink" title="I&#x2F;O表"></a>I&#x2F;O表</h4><ul><li>设备的状态是可用还是已分配</li><li>设备的操作状态信息</li><li>I&#x2F;O传输时候的源和目的地</li></ul><h4 id="文件表"><a href="#文件表" class="headerlink" title="文件表"></a>文件表</h4><ul><li>有哪些文件</li><li>文件外存的位置（磁盘）</li><li>文件的当前状态</li><li>文件的属性</li><li>文件管理系统</li></ul><h4 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h4><ul><li>进程的位置（PCB,程序，数据的位置）</li><li>管理进程的属性（ID,状态，内存的位置）</li></ul><p>内存的位置：</p><ul><li>一组程序（局部和全局变量，常量，堆栈）</li><li>PCB（所有的进程的属性）</li><li>进程映像</li></ul><p>进程映像：把一个进程逻辑上的所有信息合起来</p><ul><li>用户数据</li><li>用户进程</li><li>堆栈：存放系统及过程调用地地址，参数</li><li>PCB:OS感知进程，控制进程的数据结构</li></ul><h3 id="os内核功能"><a href="#os内核功能" class="headerlink" title="os内核功能"></a>os内核功能</h3><ul><li>资源管理功能<ul><li>进场创建金额终止，调度，状态转换，同步和通信，管理PCB</li><li>为进程分配地址空间，对换、段&#x2F;页管理</li><li>缓存管理、为进程分配I&#x2F;O通道和设备</li></ul></li><li>支撑功能<ul><li>中断处理</li><li>时钟管理</li><li>原语的操作,不可中断</li><li>统计资源的使用情况</li><li>监测</li></ul></li></ul><p><strong>进程原语</strong></p><ul><li>进程切换</li><li>创建与终止</li><li>阻塞与唤醒</li><li>挂起与激活</li></ul><h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><p><strong>原因：</strong></p><ul><li>时钟中断</li><li>I.O中断</li><li>存储访问失效（虚拟内存）</li><li>陷阱</li><li>管理程序调入<br><strong>操作过程</strong></li><li>保存下上文</li><li>更新PCB</li><li>把PCB移到相应队列</li><li>选另外一程序执行（调度）</li><li>把当前选中的进程的PCB修改</li><li>内存管理的数据结构要进行修改</li><li>恢复被选中进程的执行现场（把PCB相应的数据读到相应的寄存器里面）</li></ul><p><strong>进程切换和模式切换的区别</strong><br><strong>进程切换</strong>：作用于进程之间的一种操作。当分派程序收回当前程序的CPU并准备把它分派非某个就绪进程时，该操作将被引用<br><strong>模式切换</strong>:是进程内部所引用的一种操作，当进程映像所包含的程序引用核心子系统所提供的系统调用时，该操作被引用，不涉及到进程切换<br>进程切换的时候一定涉及模式切换，但是模式切换不一定涉及到进程切换</p><h3 id="进程创建与终止"><a href="#进程创建与终止" class="headerlink" title="进程创建与终止"></a>进程创建与终止</h3><h4 id="什么时候创建进程？"><a href="#什么时候创建进程？" class="headerlink" title="什么时候创建进程？"></a>什么时候创建进程？</h4><ul><li>提交新的批处理</li><li>用户注册</li><li>提供一些服务例如像打印</li><li>进程创造新的进程</li></ul><p><strong>步骤：</strong></p><ol><li>为进程分配一个唯一标示标号ID：住进程表增加一个新的表项</li><li>为进程分配空间：用户地址空间，用户栈空间，PCB空间。若共享已有空间，则建立相应的链接</li><li>初始化PCB：进程标识，处理机状态信息，进程状态</li><li>建立链接：若调度队列是链表，则新进程插入到就就绪或（就绪，挂起）链表</li><li>建立或扩展其他数据结构</li></ol><h4 id="什么时候终止进程"><a href="#什么时候终止进程" class="headerlink" title="什么时候终止进程"></a>什么时候终止进程</h4><ul><li>批作业遇到终止指令</li><li>用户注销</li><li>程序退出</li><li>出现条件错误</li></ul><p>终止的原因：</p><ul><li>正常结束</li><li>超时终止</li><li>内存不足</li><li>越界访问</li><li>企图使用未允许的数据，或操作方式错</li><li>计算错，如除零，或企图存储硬件允许的最大数</li><li>超时等待某件事件发生</li><li>文件多次重试依旧无法读写文件，或操作无效</li><li>企图执行不存在的指令</li><li>企图执行特权指令</li><li>数据类型不符，或未初始化</li></ul><p>步骤：</p><ol><li>根据被终止进程的标识符ID，找到其PCB,读出该进程的状态</li><li>若该进程为执行状态，则终止其执行，调度新的进程执行</li><li>若该进程有子孙进程，则立即终止其所有子孙进程</li><li>将该进程的全部资源，归还给其父进程，或归还给系统</li><li>将被终止进程（的PCB）从所在的队列中移出，等待其他程序来搜集信息</li></ol><h3 id="进程的阻塞与唤醒、挂起与激活"><a href="#进程的阻塞与唤醒、挂起与激活" class="headerlink" title="进程的阻塞与唤醒、挂起与激活"></a>进程的阻塞与唤醒、挂起与激活</h3><h4 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h4><p><strong>原因</strong>：</p><ul><li>请求系统服务</li><li>启动某种操作：如I&#x2F;O、</li><li>新数据尚位到达</li><li>无新工作可做</li></ul><h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><p>概念：当阻塞进程期待的事情发生后，有关进程调用唤醒原语，将等待该事情的进程唤醒。状态变为Ready，插入就绪队列。<br>当一个程序阻塞了，一定有一个时间将它唤醒，如果不唤醒，进程就永远死在那</p><h4 id="挂起原语"><a href="#挂起原语" class="headerlink" title="挂起原语"></a>挂起原语</h4><p>描述：当出现挂起事件，系统利用挂起原语将指定的进程或阻塞状态进程挂起。进程从内存换到外存，状态改变</p><h4 id="激活原语"><a href="#激活原语" class="headerlink" title="激活原语"></a>激活原语</h4><p>当激活事件发生后，系统利用激活原语将指定进程激活。进程从外存换入到内存，状态改变</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程综述"><a href="#线程综述" class="headerlink" title="线程综述"></a>线程综述</h4><p>描述：</p><ul><li>不再分配资源</li><li>有相应的执行状态（执行，就绪，退出）</li><li>中断的时候也会保存上下文</li><li>有执行堆栈</li><li>少量的局部变量存储空间</li><li>共享进程的资源（通过指针的方式）</li></ul><p>线程的优点：</p><ul><li>花费时间比进程更少</li><li>终极时间也比进程更少</li><li>同一线程内的两个线程切换，花费时间更短</li><li>线程共享进程的资源，它们之间的通信不会去激发操作系统内核</li><li>挂起一个进程等于挂起所有的线程</li></ul><h4 id="线程状态与线程分类"><a href="#线程状态与线程分类" class="headerlink" title="线程状态与线程分类"></a>线程状态与线程分类</h4><p>描述：</p><ul><li>线程的状态：执行，就绪，阻塞</li><li>也有线程转换图</li></ul><p>线程分类</p><ul><li>用户线程<ul><li>在应用程序完成程序的管理</li><li>内核不知道这些线程的存在</li><li>描述此类线程的数据结构以及控制此类线程的原语都在核外子系统实现</li></ul></li><li>内核线程<ul><li>线程的上下文都是由操作系统内核完成</li><li>调度基于内核</li><li>描述此类线程的数据结构以及控制此类线程都在核心子系统中实现</li></ul></li><li>组合线程（有用户和内核）</li></ul><p>线程与进程的对照关系</p><ul><li>1:1：单线程单进程，例如传统的UNIX</li><li>M:1: 单进程对多线程，例如windows NT,Linux</li><li>1:M：多进程单线程</li><li>M:M: 多进程多线程</li></ul><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>总体概述：</p><ul><li>调度类型</li><li>调度准则</li><li>调度算法</li><li>实时调度</li></ul><h3 id="调度类型："><a href="#调度类型：" class="headerlink" title="调度类型："></a>调度类型：</h3><p>调度类型：</p><ul><li>按os类型划分：<ul><li>批处理调度，分时调度，实时调度，多处理机调度</li></ul></li><li>按调度层次划分<ul><li>长程调度：从外存把作业通过创建进程到内存去</li><li>中程调度：</li><li>短程调度：发生在内存之间</li></ul></li></ul><p><img src="/../img/os/diaodu.png"></p><h4 id="长度调度"><a href="#长度调度" class="headerlink" title="长度调度"></a>长度调度</h4><p>概念:又称为高级调度、作业调度，被调度作业或用户创建进程，分配必要地系统资源，并将新创建地进程插入就绪队列，等待短程调度<br>特点：</p><ul><li>决定哪些作业或者程序进入到内存去（取决于调度算法）</li><li>选多少个进入内存，系统的负载平衡（多道程序的度，系统整个性能）</li></ul><p>什么时候发生？</p><ul><li>作业中止</li><li>处理器空闲了</li></ul><h4 id="中程调度"><a href="#中程调度" class="headerlink" title="中程调度"></a>中程调度</h4><p>概念：又称为中级调度，他调度换出到磁盘的进程进入内存，准备执行<br>中程调度配合对换技术使用的<br>其目标是为了提高内存的利用率和系统吞吐量<br>在多道程序允许的情况下，从外存选择一个挂起状态的进程调度到内存（换入）</p><h4 id="短程调度"><a href="#短程调度" class="headerlink" title="短程调度"></a>短程调度</h4><p>概念：又称低级调度，进程调度，调度内中的就绪进程执行<br>决定就绪队列中哪一个进程将获得处理机<br>调度的次数是最多的<br>什么时候发生短程调度？</p><ul><li>时钟中断</li><li>I&#x2F;O中断</li><li>操作系统调用</li><li>信号</li></ul><h3 id="调度的目标："><a href="#调度的目标：" class="headerlink" title="调度的目标："></a>调度的目标：</h3><ul><li>响应时间<ul><li>指从用户提交请求到首次产生响应所用的时间。常用于评价分时系统的性能</li></ul></li><li>周转时间<ul><li>从指作业提交给系统开始，到作业完成为止的这段时间间隔，常用于批评批处理系统的性能</li></ul></li><li>系统吞吐量</li><li>单位时间内系统所完成的作业数</li><li>用于评价批处理系统的性能</li><li>处理机利用率</li><li>公平性（对各类进程公平）</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>非剥夺方式：<br>概念：一个进程一旦被执行，一种是自己终止进程，主动释放处理器，另外一种有I&#x2F;O指令，自己主动放弃CPU的执行<br>主要用于批系统<br>优点：降低了进程的周转时间</p><p>剥夺方式<br>概念：当前的执行进程可以被强制中断<br>优点：可以及时处理优先级高的进程<br>主要用于实时性要求比较高的实时系统以及性能要求比较高的批处理系统和分时系统</p><p>例子：有五个进程描述如下：<br>进程    到达时刻  服务时间<br>P1       0        3<br>P2       2        6<br>P3       4        4<br>P4       6        5<br>P5       8        2</p><p><img src="/../img/os/zhouzhuan.png"></p><h4 id="先来先服务算法（FCFS"><a href="#先来先服务算法（FCFS" class="headerlink" title="先来先服务算法（FCFS)"></a>先来先服务算法（FCFS)</h4><p><img src="/../img/os/FCFS.png"></p><ul><li>步骤：</li><li>所有进程都进入到就绪队列里</li><li>当当前进程结束后，下一个队列中最先进来的进程执行</li><li>属于非剥夺方式</li><li>短进程会等待非常长的时间（给进程给优先级）</li><li>对于计算型进程有利，对I&#x2F;O型进程也不利（多就绪队列）</li><li>实际使用<ul><li>一般都是与其他调度算法混合使用 </li><li>系统可以按照不同优先级维护多个就绪队列，每个队列内部执行FCFS算法调度</li></ul></li></ul><h4 id="轮转调度-RR"><a href="#轮转调度-RR" class="headerlink" title="轮转调度(RR)"></a>轮转调度(RR)</h4><p>概念：兼顾各个进程都能够得到一些服务，给所有进程一个固定长的时间片，时间到，中止进程，执行下一个进程<br>虚拟轮转调度： 改进轮转调度时，考虑对I&#x2F;O型的进程，希望他获得更快的调度，所以有两个就绪队列，由于超时被中断的回到原队列，而I&#x2F;O型进程会阻塞，去到另外一个就绪队列，这个队列优先级更高<br>时间片原则：估计系统交互式提交的任务，是在一个时间片内完成70%~80%</p><h4 id="短进程优先-SJF"><a href="#短进程优先-SJF" class="headerlink" title="短进程优先(SJF)"></a>短进程优先(SJF)</h4><p>概念：优先做短进程或者是剩余时间最短者优先</p><h4 id="高响应比优先-HRRN"><a href="#高响应比优先-HRRN" class="headerlink" title="高响应比优先(HRRN)"></a>高响应比优先(HRRN)</h4><p><img src="/../img/os/xiangyingbi.png"><br>根据时间来提高优先级，对于短进程，服务时间短响应比高，对于长进程，等待时间长，相应比高<br>工程上很难实现</p><h4 id="反馈调度-FB"><a href="#反馈调度-FB" class="headerlink" title="反馈调度(FB)"></a>反馈调度(FB)</h4><p><img src="/../img/os/FB.png"><br>设置多个就绪队列，每个队列的时间片都可以相同或不同</p><h3 id="实时系统与实时任务"><a href="#实时系统与实时任务" class="headerlink" title="实时系统与实时任务"></a>实时系统与实时任务</h3><p>描述：指能及时响应外部事件的请求，并在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行地计算机系统（系统判断这个是不是正确的，不仅要看逻辑计算结果是否正确，还要依赖产生结果的时间）<br>特点：</p><ul><li>切换很快</li><li>实时任务小</li><li>对外部响应和外部中断很快</li><li>文件存储速度很快</li><li>对事件或者任务地延迟有一个定数的</li><li>报警和超时处理</li></ul><p>实时进程调度的剥夺方式<br>可以用的调度算法：</p><ul><li>基于时间片的轮转调度法<ul><li>响应时间在秒级</li><li>一般实时信息处理系统</li></ul></li><li>基于优先级非剥夺调度方法：为实时任务赋予较高的优先级，将它插入就绪队列对手，只要执行任务在释放处理器，，则立马执行该实时任务<ul><li>响应时间一般在数百毫秒至数秒范围</li><li>多用于多道批处理系统，也可以用于要求不太严格的实时系统</li></ul></li><li>基于优先级非剥夺调度方法：当实时任务到达以后，可以在时钟后中断时，剥夺正在执行的低优先级进程的执行，调度执行高优先级的任务</li><li>立即剥夺调度法：要求操作系统具有快速响应外部事件的能力，一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺其执行，把处理级分配给请求中断的紧迫任务</li></ul><h3 id="实时调度算法"><a href="#实时调度算法" class="headerlink" title="实时调度算法"></a>实时调度算法</h3><ul><li>静态表驱动调度算法</li><li>用于调度周期性实时任务</li><li>按照任务周期到底时间，执行时间，完成截止时间以及任务优先级，制订调度表，调度实时任务</li><li>最早截止时间优先调度法</li><li>静态优先级调度算法：对任务的限定时间赋予优先级</li><li>动态计划调度法：系统为新的任务和正在执行的任务动态创造一张表</li><li>动态最大努力调度法：任务到达时，系统根据属性赋予优先级，优先级高的先调度</li></ul><h2 id="进程并发"><a href="#进程并发" class="headerlink" title="进程并发"></a>进程并发</h2><p>临界资源：只能互斥使用的资源，例如打印机<br>临界区：访问临界资源的那段代码</p><h3 id="硬件方式实现互斥"><a href="#硬件方式实现互斥" class="headerlink" title="硬件方式实现互斥"></a>硬件方式实现互斥</h3>]]></content>
    
    
    
    <tags>
      
      <tag>计算机操系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++学习</title>
    <link href="/2024/09/19/c++Study/"/>
    <url>/2024/09/19/c++Study/</url>
    
    <content type="html"><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>c++将内存大方向划分为4个区域</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局本部变量等</li><li>堆区：有程序员分配和释放，结束时有操作系统回收</li></ul><p><strong>内存四区的意义</strong><br>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</p><p><strong>代码区：</strong><br>存放cpu的机器指令<br>代码区是共享的<br>代码区是只读的</p><p><strong>全局区：</strong><br>全局变量和变量存放在此<br>还包含了常量区，字符串常量和其他常量也存放在这<br>该区数据在程序结束后有操作系统释放</p><p><strong>结论：</strong></p><ul><li>代码区和全局区都是程序运行前</li><li>代码区的特点是共享和只读</li><li>全局区中存放全局变量，静态变量，常量</li><li>常量区中存放const修饰的全局常量和字符串常量</li></ul><p><strong>栈区</strong><br>由编译器自动分配释放，存放函数的参数值，局本部变量等<br>不要返回局部变量的地址，栈区开辟的数据编译器会自动释放</p><p><strong>堆区</strong><br>有程序员分配和释放，结束时有操作系统回收<br>在c++中主要利用new在堆区中开辟内存<br>指针本质上也是局部变量，放在栈上，指针保存的数据是放在堆区的</p><p><strong>结论</strong></p><ul><li>栈区和堆区都是程序运行后</li><li>堆区数据是由管理员开辟和释放</li><li>堆区数据利用new关键字进行开辟内春</li></ul><h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><p>堆区数据是由管理员开辟和释放，释放用利用操作符delete</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std<br> //1在堆区创建整数<br>int * func()&#123;<br>    //new返回该数据类型的指针<br>    int * p = new int (10);<br>    retrun p;<br>&#125;<br>int tesr01&#123;<br>    int *p = func();<br>    count &lt;&lt; *p &lt;&lt; endl;  //10<br>    count &lt;&lt; *p &lt;&lt; endl;  //10<br>    count &lt;&lt; *p &lt;&lt; endl;  //10<br>    //堆区数据是由管理员开辟和释放<br>    //想释放数据，利用关键字delete<br>    delete p;<br>    count &lt;&lt; *p &lt;&lt; endl; // 内存已经被释放，再次访问就是非法操作，会报错<br>&#125;<br>    //2.在堆区开辟利用new开辟数组<br>void test2&#123;<br>    <br>    ingt* arr = new int[10];<br>    for(int i =0; i&lt; 10; i++)<br>        arr[i] = i + 1;<br>     ingt* arr = new int[10];<br>    for(int i =0; i&lt; 10; i++)<br>        cout &lt;&lt; arr[i] &lt;&lt; endl; <br>    //释放数组时，要加[]才可以<br>    delete[] arr；<br>&#125;<br>int mian()&#123;<br>    test01();<br>    test02();<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h2><p><strong>作用</strong>:给变量起别名<br><strong>语法</strong>:数据类型 &amp;别名 &#x3D; 原名</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"># include &lt;iostream&gt;<br>using namespace std<br>int main()&#123;<br>    int &amp;b = a;<br>    b =20 ;<br>    cout &lt;&lt; a &lt;&lt; endl; //输出等于20<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h2><ul><li>引用必须要初始化<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs [c++]bush">int &amp;b; //这样是错误的<br></code></pre></td></tr></table></figure></li><li>引用初始化后就不可以更改了</li></ul><h2 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h2><p><strong>作用</strong>: 函数传参时，可以利用引用的技术让形参修饰实参<br><strong>优秀</strong>:可以简化指针修改实参</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br><br>//引用传递<br>void myswap(int &amp;a,int &amp;b)&#123;<br>    int temp=a;<br>    a=b;<br>    b=temp;<br>&#125;<br><br>int main()&#123;<br>    int a=10;<br>    int b=20;<br>    myswap(a,b);  //引用传递，形参会修饰实参的<br>    cout&lt;&lt;&quot;a= &quot;&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;&quot;b= &quot;&lt;&lt;b&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h2><p><strong>作用</strong>：引用是可以作为函数的返回值存在的<br><strong>注意</strong>：不要返回局部变量引用<br><strong>用法</strong>：函数调用作为左值</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br><br>//不要返回局部变量引用<br>int&amp; test01()&#123;<br>    int a=10;//局部变量存放在栈区<br>    return a;<br>&#125;<br>//函数的调用可以作为左值<br>int&amp; test02()&#123;<br>    static int a=10; //静态变量，存放在全局区，全局区上的数据在程序结束后系统释放<br>    return a;<br>&#125;<br><br>int main()&#123;<br>    int &amp;ref=test01(); //非法操作<br>    cout&lt;&lt;&quot;ref= &quot;&lt;&lt;ref&lt;&lt;endl;//第一次结果正确是编译器做了保留<br>    cout&lt;&lt;&quot;ref= &quot;&lt;&lt;ref&lt;&lt;endl;//第二次结果错误是因为a的内存已经释放<br>    int &amp;ref2=test02();<br>    cout&lt;&lt;&quot;ref2= &quot;&lt;&lt;ref2&lt;&lt;endl;//输出10<br>    cout&lt;&lt;&quot;ref2= &quot;&lt;&lt;ref2&lt;&lt;endl;<br>    test02()=1000; //如果函数的返回值是引用，这个函数的调用可以作为左值  相当于 &amp;a = 1000;<br>    cout&lt;&lt;&quot;ref2= &quot;&lt;&lt;ref2&lt;&lt;endl;//输出1000<br>    cout&lt;&lt;&quot;ref2= &quot;&lt;&lt;ref2&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><p><strong>本质</strong>：引用的本质在C++内部实现是一个指针常量</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br><br>//发现是引用，转换为int* const ref=&amp;a;<br>void func(int&amp; ref)&#123;<br>    ref=100;//ref是引用，转换为*ref=100<br>&#125;<br><br>int main()&#123;<br>    int a=10;<br>    //自动转换为int* const ref=&amp;a;指针常量是指针指向不可改，也说明为什么引用不可更改<br>    int&amp; ref=a;<br>    ref=20; //内部发现ref是引用，自动帮我们转换为：*ref=20;<br>    cout&lt;&lt;&quot;a:&quot;&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;&quot;ref:&quot;&lt;&lt;ref&lt;&lt;endl;<br>    func(a);<br>    return 0;<br>&#125;<br>总结：C++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了<br></code></pre></td></tr></table></figure><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p><strong>作用</strong>：常量引用主要用来修饰形参，防止误操作<br>在函数形参列表中，可以加const修饰形参，防止形参改变实参</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br>//打印数据函数<br>void showValue(const int &amp;val)&#123;<br>    //val=1000;   如果没加上const，外面的a也会更改<br>    //加上了const，上段代码就会报错<br>    cout&lt;&lt;&quot;val= &quot;&lt;&lt;val&lt;&lt;endl;<br>&#125;<br><br>int main()&#123;<br>    //常量引用<br>    int &amp;ref=10;//错误，引用必须引一块合法的内存空间<br>    //加上const之后，编译器将代码修改为 int temp=10; const int &amp;ref=temp;<br>    const int &amp;ref=10;//正确<br>    //使用场景：用来修饰形参，防止误操作<br>    int a=100;<br>    showValue(a);<br>    cout&lt;&lt;&quot;a= &quot;&lt;&lt;a&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数的提高"><a href="#函数的提高" class="headerlink" title="函数的提高"></a>函数的提高</h1><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><p>在C++中，函数的形参列表中的形参是可以有默认值的。<br><strong>语法</strong>：返回值类型 函数名 (参数 &#x3D; 默认值){}<br><strong>注意事项</strong>：</p><ul><li>如果某个位置已经有了默认参数，那么从这个位置往后，从左向右的形参都必须要有默认参数</li><li>声明和实现只能有一个有默认参数<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br>int func(int a,int b=20,int c=30,)<br>//函数默认参数<br>int func(int a,int b,int c)&#123;<br>    return a+b+c;<br>&#125;<br><br>int main()&#123;<br>    cout&lt;&lt;func(10)&lt;&lt;endl;//有默认值可以只传没有默认值的形参<br>    cout&lt;&lt;func(10,30)&lt;&lt;endl;//如果自己传入数据，就用自己的数据<br>    <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h2><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置<br><strong>语法</strong>:返回值类型 函数名(数据类型){}</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br><br>void func(int a,int)&#123;<br>    cout&lt;&lt;&quot;this is func&quot;&lt;&lt;endl;<br>&#125;<br><br>//占位参数还可以默认参数<br>void func1(int a,int =10)&#123;<br>    cout&lt;&lt;&quot;this is func1&quot;&lt;&lt;endl;<br>&#125;<br><br>int main()&#123;<br>func(10,10);<br>    func1(10);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>作用：函数名可以相同，提高复用性<br>函数重载满足条件：</p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数类型不同或者个数不同或者顺序不同</li><li>注意：函数的返回值类型不可以作为函数重载的条件<br>例如：函数func返回值类型为int，而还有一个func函数返回值为void，这个时候编译器会报错！<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br>//函数重载需要在同一个作用域中<br>void func()&#123;<br>    cout&lt;&lt;&quot;func的调用&quot;&lt;&lt;endl;<br>&#125;<br><br>//个数不同<br>void func(int a)&#123;<br>    cout&lt;&lt;&quot;func(int a)的调用&quot;&lt;&lt;endl;<br>&#125;<br><br>//参数类型不同<br>void func(double a)&#123;<br>    cout&lt;&lt;&quot;func(double a)的调用&quot;&lt;&lt;endl;<br>&#125;<br><br>//顺序不同<br>void func(int a,double b)&#123;<br>    cout&lt;&lt;&quot;func(int a,double b)的调用&quot;&lt;&lt;endl;<br>&#125;<br><br>void func(double a,int b)&#123;<br>    cout&lt;&lt;&quot;func(double a,int b)的调用&quot;&lt;&lt;endl;<br>&#125;<br><br>//注意事项<br>//函数的返回值类型不能作为函数重载的条件<br>int main()&#123;<br>func();<br>    func(10);<br>    func(0.1);<br>    func(10,0.1);<br>    func(0.1,10);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h3><ul><li>引用作为函数重载条件</li><li>函数重载碰到函数默认参数<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br><br>//引用作为函数重载条件<br>void func(int &amp;a)&#123;  //int &amp;a=10;不合法<br>    cout&lt;&lt;&quot;func(int &amp;a)的调用&quot;&lt;&lt;endl;<br>&#125;<br><br>void func(const int &amp;a)&#123;  //const int &amp;a=10;合法<br>    cout&lt;&lt;&quot;func(const int &amp;a)的调用&quot;&lt;&lt;endl;<br>&#125;<br><br>//函数重载碰到默认参数,出现二义性，报错，尽量避免这种情况<br>void func2(int a,int b=10)&#123;<br>    cout&lt;&lt;&quot;func2(int a,int b)的调用&quot;&lt;&lt;endl;<br>&#125;<br><br>void  func2(int a)&#123;<br>    cout&lt;&lt;&quot;func2(int a)的调用&quot;&lt;&lt;endl;<br>&#125;<br><br>int main()&#123;<br>    int a=10;<br>    func(a);<br>    func(10);<br>    func2(10);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>C++面向对象的三大特性为：<strong>封装、继承、多态</strong><br>C++认为万事万物都皆为对象，对象上有其属性和行为</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><p>封装是C++面向对象三大特性之一<br>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制<br><strong>封装意义一</strong>：<br>在设计类的时候，属性和行为写在一起，表现事物<br><strong>语法</strong>：class 类名{ 访问权限：属性 &#x2F; 行为 };<br>类中的属性和行为，我们统一称为成员<br>属性：成员属性 成员变量<br>行为：成员函数 成员方法<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br><br>//设计一个圆类，求圆的周长<br>class Circle&#123;<br>    //访问权限<br>public:  //公共权限<br>    //属性<br>    int m_r;<br>    //行为<br>    double calculateZC()&#123;<br>        return 2*PI*m_r;<br>    &#125;<br>&#125;;<br><br>int main()&#123;<br>    //通过圆类，创建具体的圆(对象)<br>    //实例化  （通过一个类，创建一个对象的过程）<br>    Circle c1;<br>    //给圆对象的属性进行赋值<br>    c1.m_r=10;<br>    cout&lt;&lt;&quot;圆的周长为：&quot;&lt;&lt;c1.calculateZC()&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><strong>封装的意义二</strong>：</li></ul><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制<br>访问权限有三种：</p><ul><li>public 公共权限，成员类内外可以访问</li><li>protected 保护权限，成员类内可以访问，类外不可以访问，在继承中，父类的保护权限的内容，子类也可以访问</li><li>private 私有权限，成员类内可以访问，类外不可以访问，父类的私有权限的内容，子类不可以访问<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br><br>class Person&#123;<br>  //公共权限<br>public:<br>    string m_Name;<br>  //保护权限<br>protected:<br>    string m_car;<br>  //私有权限<br>private:<br>    int m_password;<br>public:<br>    void func()&#123;<br>        m_Name=&quot;张三&quot;;<br>        m_car=&quot;拖拉机&quot;;<br>        m_password=123456;<br>    &#125;<br>&#125;;<br><br>int main()&#123;<br>    Person p1;<br>    p1.m_Name=&quot;李四&quot;;<br>    p1.m_car=&quot;奔驰&quot;;  //报错，保护权限类外不可访问<br>    p1.m_password=12;  //报错，私有权限类外不可访问<br>    p1.func(); //公共权限可以访问<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h3><p>在C++中struct和class唯一的区别就在于默认的访问权限不同</p><p>区别：</p><p>struct 默认权限为公共<br>class 默认权限为私有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>using namespace std;<br><br>class C1&#123;<br>    int m_A;   //默认权限  私有<br>&#125;;<br><br>struct C2&#123;<br>    int m_A;  //默认权限  公有<br>&#125;<br><br>int main()&#123;<br>C1 c1;<br>    c1.m_A=100;  //报错<br>    C2 c2;<br>    c2.m_A=100;  //不会报错,在struct默认的权限为公共的，所以可以访问<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h3><p>优点1：将所有成员属性设置为私有，可以自己控制读写权限<br>优点2：对于写权限，我们可以监测数据的有效性</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>using namespace std;<br>class Person&#123;<br>public:<br>    void setName(string name)&#123;<br>        m_Name = name;<br>    &#125;<br>    string getName()&#123;<br>        return m_Name;<br>    &#125;<br>    private:<br>        string m_Name;<br>        int m_Age;<br>        string m_lover;<br>    &#125;<br>    <br>    int main()&#123;<br>        Preson p1;<br>        p1.setName(&quot;张三”）;<br>        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p1.getName() &lt;&lt; endl;<br>        return 0;<br></code></pre></td></tr></table></figure><h2 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h2><p>C++中的面向对象来源于生活，每个对象也会有初始化设置以及对象销毁前的清理数据的设置</p><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>对象的初始化和清理也是两个非常重要的安全问题</p><ul><li>一个对象或者变量没有初始状态，对其使用后果是未知的</li><li>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题<br>C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象的初始化和清理工作。</li></ul><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p><p>编译器提供的构造函数和析构函数是空实现</p><ul><li>构造函数：主要用于创建的对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用</li><li>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数</strong>：<br>语法：类名(){}<br>构造函数，没有返回值也不写void<br>函数名称与类名相同<br>构造函数可以有参数，因此可以发生重载<br>程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次</p><p><strong>析构函数</strong>：<br>语法：<em>类名(){}</em><br>析构函数，没有返回值也不写void<br>函数名称与类名相同，在名称前加上符号<br>析构函数不可以有参数，因此不可以发生重载<br>程序在对象销毁前会自动化调用，无须手动调用，而且只会调用一次</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br>class Preson<br>&#123;<br>public:<br>    Person()&#123;<br>    cout &lt;&lt; &quot;Preson构造函数调用&quot; &lt;&lt; endl;<br>    &#125;<br>    ~Preson()&#123;<br>    cout &lt;&lt; &quot;Preson析构函数调用&quot; &lt;&lt; endl;<br>    &#125;    <br> //构建和析构都是必须有的实现，不然编译器就会提供一个空的构造和析构函数<br> void test01()&#123;<br>    Person p;//在栈上的数据，test01执行完毕后，释放这个对象<br> &#125;<br>int main()&#123;<br>    text01();<br>    Person p; //当对象销毁掉才会使用<br>    return 0;<br>    &#125; <br>    <br></code></pre></td></tr></table></figure><h3 id="析构函数的分类及调用"><a href="#析构函数的分类及调用" class="headerlink" title="析构函数的分类及调用"></a>析构函数的分类及调用</h3><p>两种分类方式：</p><ul><li>按参数分为：有参构造和无参构造</li><li>按类型分为：普通构造和拷贝构造<br>三种调用方式：</li><li>括号法</li><li>显示法</li><li>隐式转换法<br>注意事项：</li><li>调用默认构造函数的时候不用加(),加入了括号，编译器会认为 是一个函数的声明，不会认为在创建对象</li><li>不要利用拷贝构造函数初始化匿名对象，编译器会认为Person(p3)&#x3D;&#x3D;Person p3; 造成重定义报错<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br>// 分类<br>// 按参数  有参和无参(默认)构造<br>// 按照类  普通和拷贝构造<br>class Person&#123;<br>    Person&#123;<br>        cout &lt;&lt; &quot;默认构造函数&quot; &lt;&lt; endl;<br>        &#125;<br>    Person1(int a)&#123;<br>        age = a;<br>        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;<br>        &#125;<br>    //拷贝构造函数<br>    Person(const Person &amp;p )&#123;<br>    cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;<br>        //将传入的人身上所有属性，拷贝到我身上<br>        age = p.age;<br>    &#125;<br>    <br>    ~Person()&#123;<br>        cout &lt;&lt; &quot;析构函数 &lt;&lt; endl;<br>        &#125;<br>    int a;<br>&#125;;<br>void test01()&#123;<br>    //括号法<br>    Person p; // 默认构造<br>    Person p2(10); //有参构造函数<br>    Person p3(p2); // 拷贝构造函数<br>  <br>    //显示法<br>    Person p1;<br>    Preson p2 = Person(10); //有参构造<br>    Preson p3 = Person(p2);//拷贝构造<br>    <br>    Person(10); //匿名对象 特点：当前行执行结束后，系统会立即回收掉匿名对象<br>        <br>    //隐式转换法<br>    Person p4 = 10;//相当于 Person p4 = Person(10);<br>    Person p5 = p4;//拷贝构造<br>    <br>&#125;<br>int mian()&#123;<br>    test01();<br>    retun 0;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h3><p>C++中拷贝构造函数调用时机通常有三种情况：</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值 值传递只是拷贝临时的副本</li><li>以值方式返回局部对象<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br>class Person<br>&#123;<br>public:<br>    Person()&#123;<br>     cout &lt;&lt; &quot;构造“ &lt;&lt; endl;<br>     &#125;<br>    Person( int age)&#123;<br>        cout &lt;&lt; &quot;有参构造&quot; &lt;&lt;endl;<br>        m_Age = age;<br>     &#125;<br>    Person(const Person &amp; p)<br>     &#123;<br>        m_Age = p.m_Age <br>     &#125;<br>     ~Person&#123;<br>        cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl;<br>     &#125;    <br>     int m_Age; <br>     &#125;<br>void test01()&#123;<br>    Person p1(20);<br>    Person p2(p2);<br>    &#125;<br>void doWork(Person p)&#123;<br><br>&#125;<br>void test02()&#123;<br>    Person p;<br>    doWork(p);<br>    &#125;<br>void doWork2(Person p)&#123;<br>    Person p1;<br>    return p1;//局部对象会拷贝出新对象返回<br>&#125;<br>void test03()&#123;<br>    Person p = doWork2();<br>    &#125;    <br>int mian()&#123;<br>    test01;<br>    test02;<br>    <br>&#125;     <br></code></pre></td></tr></table></figure></li></ul><h3 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h3><p>默认情况下，C++编译器至少给一个类添加3个函数</p><ul><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝<br>构造函数调用规则如下：</li><li>如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，C++不会再提供其他构造函数<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br><br>class Person&#123;<br>public:<br>    Person()&#123;<br>        cout&lt;&lt;&quot;Person默认构造函数调用&quot;&lt;&lt;endl;<br>    &#125;<br>    Person(int age)&#123;<br>        cout&lt;&lt;&quot;Person有参构造函数调用&quot;&lt;&lt;endl;<br>        m_Age=age;<br>    &#125;<br>    Person(const Person &amp;p)&#123;<br>        cout&lt;&lt;&quot;Person拷贝构造函数调用&quot;&lt;&lt;endl;<br>        m_Age=p.m_Age;<br>    &#125;<br>    ~Person()&#123;<br>        cout&lt;&lt;&quot;Person析构函数调用&quot;&lt;&lt;endl;<br>    &#125;<br>    int m_Age;<br>&#125;;<br><br>void test01()&#123;<br>Person p;<br>    p.m_Age=18;<br>    Person p2(p);<br>    cout&lt;&lt;&quot;p2的年龄为：&quot;&lt;&lt;p2.m_Age&lt;&lt;endl;<br>&#125;<br><br>int main()&#123;<br>    <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>深浅拷贝是面试的经典问题，也是一个常见的坑</p><p><strong>浅拷贝</strong>：简单的赋值拷贝操作</p><p><strong>深拷贝</strong>：在堆区重新申请空间，进行拷贝操作</p><p>浅拷贝带来的问题就是堆区的内存重复释放</p><p>浅拷贝的问题要利用深拷贝进行解决，自己写一个拷贝函数</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>using namespace std;<br>class Person&#123;<br>public:<br>    Person()&#123;<br>    cout &lt;&lt; &quot;构造&quot; &lt;&lt;endl; <br>    &#125;<br>    <br>    Person(int age,int height)&#123;<br>    m_Age = age;<br>    m_Height = new int(height);<br>    cout &lt;&lt; &quot;有参构造&quot;&lt;&lt; endl;<br>    &#125;<br>    <br>    Person(const Person &amp;p)&#123;<br>     cout &lt;&lt; &quot;拷贝” &lt;&lt; ednl;<br>     m_Age = age;<br>     //深拷贝<br>     //m_Height = new int(height); 编译器默认实现就是这行代码<br>     m_Height = new int (*p.m_Hegiht);<br>     &#125;<br>    ~Person()&#123;<br>    //析构代码，将堆区开辟数据做释放操作<br>        if(!m_Height)<br>        &#123;<br>            detele  m_Height;<br>            m_Height == NULL;<br>        &#125;<br>    cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl;<br>    &#125;<br>    <br>    int m_Age;<br>    int * m_Height;<br>    &#125;;<br>    <br>    void test01()&#123;<br>        Person p1(18,160);<br>        cout &lt;&lt; p1.m_Age &lt;&lt; *p1.m_Height &lt;&lt; endl;<br>        Person p2(p1);<br>        cout &lt;&lt; p2.m_Age &lt;&lt; *p2.m_Height &lt;&lt;endl;<br>    &#125;<br>    <br>    int mian ()&#123;<br>        test01();<br>        return 0;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong> ：如果属性在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><strong>作用</strong>：<br>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法</strong>：构造函数():属性1(值1),属性2(值2) …{}</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br><br>class Person<br>&#123;<br>public:<br>    //传统初始化操作<br>    Person(int a,int b,int c)&#123;<br>        m_A = a;<br>        m_B = b;<br>        m_C = c;<br>    &#125;<br>    <br>    //初始化列表初始化属性<br>    Person():m_A(10),m_B(20),m_C(30)&#123;<br>    &#125;<br>    Person(int a, int b, int c):m_A(a),m_B(b),m_C(c)&#123;<br>    &#125;<br><br>    int m_A;<br>    int m_B;<br>    int m_C;<br>&#125;;<br><br>void test01()&#123;<br>    person(10, 20, 30);<br>    &#125;<br>    <br>int mian()&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><p>C++类中的成员可以是另一个类的对象，我们称该成员为对象成员<br>例如：</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class A&#123;&#125;;<br>class B&#123;<br>    A a;<br>&#125;;<br></code></pre></td></tr></table></figure><p>B类中有对象作为一个成员，A为对象成员<br>那么创建B对象时，A与B的构造和析构的顺序是谁先谁后？<br>先构造A对象再构造B对象</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>using namespace std;<br><br>class Person<br>&#123;<br>public:<br>    Person(string name, string pName):m_Name(name) , m_Phone(pName)&#123;<br>    &#125;<br>    <br>    string m_Name;<br>    <br>    Phone m_Phone;<br><br>&#125;;<br>class Phone&#123;<br>public:<br>    Phone(string pName)&#123;<br>    m_PName = pName;<br>    &#125;<br>    string m_PName;<br>    string m_Phone<br>&#125;;<br>void test01&#123;<br>    Person p(&quot;张三&quot;，&quot;苹果&quot;);<br>&#125;<br><br>int mian()&#123;<br>    test01();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：当其他类对象作为本类成员，我们称该成员为对象成员，构造顺序是：先调用对象成员的构造，再调用本类构造，析构顺序与构造相反。</p></blockquote><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态成员就是在成员变量和成员函数前加上关键词static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化(必须的操作)</li></ul></li><li>静态成员函数<ul><li>所有成员共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p>静态成员变量：</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>using namespace std;<br><br>class Person<br>&#123;<br>public:<br>    //所有对象都共享一份数据<br>    //编译阶段就分配内存<br>    //类内声明，类外初始化操作<br>    static int m_A; <br>&#125;;<br>//类外初始化<br><br>int Person::m_A = 100;<br><br>void test01()&#123;<br>    Person p; // p.m_A == 100<br>    <br>    Person p2;<br>    p2.m_A = 200  // p.m_A ==200<br>&#125;<br><br>void test02()&#123;<br>    //静态成员 不属于某个对象上，所有对象都共享一份数据<br>    //因此静态成员变量有两种访问方式<br>    <br>    //通过类名进行访问<br>    Person p;<br>    cout &lt;&lt; p.m_A &lt;&lt; endl;<br>    <br>    //通过类名进行访问<br>    cout &lt;&lt; Person::m_A&lt;&lt; endl;<br>&#125;<br><br>int mian()&#123;<br>    test01;<br>    test02;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong>：静态成员变量也是有访问权限的</p></blockquote><p>静态成员函数：<br><strong>注意事项</strong>：静态成员变量也是有访问权限的</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">//静态成员函数<br>class Person&#123;<br>public:<br>    //静态成员函数<br>    static void func()&#123;<br>        m_A=100;//静态成员函数可以访问静态成员变量<br>        m_B=200;//静态成员函数不可以访问非静态成员变量,无法区分是哪个对象的属性<br>        cout&lt;&lt;&quot;static void func函数的调用&quot;&lt;&lt;endl;<br>    &#125;<br>    <br>    static int m_A;<br>    int m_B;//非静态成员变量<br>&#125;;<br><br>int Person::m_A=0;<br><br>void test01()&#123;<br>    //通过对象访问<br>    Person p;<br>    p.func();<br>    //通过类名访问<br>    Person::func();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象模型和this指针"><a href="#对象模型和this指针" class="headerlink" title="对象模型和this指针"></a>对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><p>在C++中，类内的成员变量和成员函数分开存储<br>只有非静态成员变量才属于类的对象上<br>空对象内存是一个字节</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Person&#123;<br><br>  int m_A;  // 非静态成员变量 属于类的对象上<br>  static int m_B; //静态成员变量 不属于类的对象上<br>  void func(); // 非静态成员变量 不属于类的对象上<br>  staic void func() // 非静态成员变量 不属于类的对象上<br>&#125;;  <br>Person::m_B = 0;<br>void test01()&#123;<br>&#123;<br>  Person p;<br>  // 空对象占用内存空间为1字节；<br>  // c++编译器会给每一个空对象也分配一个字节空间，是为了区分空对象占用内春的位置<br>  //每一个空对象都有一个属于自己的地址空间；<br>  cout &lt;&lt; sizeof(p) &lt;&lt; endl;<br>  &#125;<br>void test02()&#123;<br>  Person p;<br>  cout &lt;&lt; sieof(p) &lt;&lt; endl; // 字节为4<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>通过上一个章节我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p><strong>概念：</strong></p><p>C++通过提供特殊的对象指针—-this指针，来进行区分哪个对象调用哪一块代码,<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p><strong>this指针的用途：</strong></p><ul><li>解决名称冲突：当形参和成员变量同名时，可用this指针来区分</li><li>返回对象本身：在类的非静态成员函数中返回对象本身，可使用*return this</li></ul><p>使用 *this 作为返回值通常意味着返回当前对象的引用。</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Peron&#123;<br>public:<br>  Person(int age)&#123;<br>  // this指向的是被调用的成员函数所属的对象<br>    this-&gt;age = age;<br>  &#125;<br>  Person&amp; PersonAddAge(Person &amp;p)&#123;<br>    this-&gt;age += p.age;<br>    //this指p2的指针，而*this指向p2这个对象的本体<br>    return *this;<br>  &#125;<br>  PersonAddAge()<br>  int age;<br>&#125;;<br><br>void test01()<br>&#123;<br>  Person p(18);<br>&#125;<br><br>test02()&#123;<br>  Person p1(18);<br>  Person p2(18);<br>  p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针<br>如果用到this指针，需要加以判断保证代码的健壮性</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Person&#123;<br>public:<br>  void showClassName()&#123;<br>  cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;<br> &#125;<br>  void showPersonAge()&#123;<br>  //提高代码的健壮性<br>    if(this == NULL)<br>      return;<br>    cout &lt;&lt; &quot;2&quot; &lt;&lt; m1_Age &lt;&lt; endl;<br>  &#125; <br>  int m_Age;<br>  &#125;;<br>  void test01()&#123;<br>  Person *p = NULL;<br>  //正常打印<br>  p-&gt;showClassName;<br>  //报错<br>  p-&gt;showPersonAge;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><p><strong>常函数：</strong></p><ul><li>成员函数后加入const后我们称这个函数为常函数，修饰的是this的指向，让指针指向的值也不可以改变的</li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键词mutable时，在常函数和常对象中依然可以修改<br><strong>常对象：</strong></li><li>声明对象前加const后称该对象为常对象</li><li>常对象只能调用常函数</li></ul><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Person<br>&#123;<br>public:<br>  //this的本质是指针常量，指针的指向是不可以修改的<br>  //Person *const this;<br>  <br>  void showPerson() const<br>  &#123;<br>  this-&gt;m_A = 100;//这个是错误的<br>  //this = NULL; //指针的指向是不可以修改的<br>  this-&gt;m_N =100 //这个是正确的<br>  &#125;<br>  <br>  void func()&#123;&#125;<br>  int m_A <br>  mutable int m_B;<br>  &#125;;<br>  <br>void test02()&#123;<br>  const Person p;<br>  p.m_A = 100;//错误的<br>  p.m_B = 100;//正确的<br>  <br>  p.showPerson();//正确<br>  p.func(); // 报错<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术<br>友元的目的就是让一个函数或者类访问另一个类中私有成员<br>友元的关键词为 <strong>friend</strong><br>友元的三种实现：</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">Building&#123;<br>  frined void goodGay(Building *building);<br>public:<br>  Building()&#123;<br>     m_SittingRom = &quot;客厅”；<br>     m_BedRoom = “卧室”;<br>  &#125;<br>public:<br>    string m_SittingRom;<br>private:<br>    string m_BedRoom;<br>&#125;;<br><br>//全局函数<br>void goodGay(Building *building)<br>&#123;<br>   cout &lt;&lt; &quot;1&quot; &lt;&lt; builing-&gt;m_SittingRoom &lt;&lt;endl;<br>   cout &lt;&lt; &quot;2&quot; &lt;&lt; builing-&gt;m_BedRoom &lt;&lt;endl;<br>&#125;<br>void test01()&#123;<br>    Building builing;<br>    GoodGay(&amp;builing);<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"><br>Building&#123;<br>    friend class goodGay() <br>public:<br>    Building()<br>    string m_SittingRom;<br>private:<br>    string m_BedRoom;<br>&#125;;<br><br>//类外写成员函数<br>Building :: Building()&#123;<br>    <br>     m_SittingRom = &quot;客厅”；<br>     m_BedRoom = “卧室”;<br> &#125;<br><br><br>//全局函数<br>class goodGay<br>&#123;<br>  goodGay();<br>  void vist();<br>  Building * building;<br>&#125;<br><br>goodGay::goodGay()&#123;<br>  building = new Buliding;<br>&#125;<br>goodGay::vist();//参观函数，访问Building中的属性&#123;<br>   cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;<br>&#125; <br>void test01()&#123;<br>    Building builing;<br>    GoodGay(&amp;builing);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">Building&#123;<br>    friend void GoodGay::visit();<br>public:<br>    Building()<br>    string m_SittingRom;<br>private:<br>    string m_BedRoom;<br>&#125;;<br><br>//类外写成员函数<br>Building :: Building()&#123;<br>     m_SittingRom = &quot;客厅”；<br>     m_BedRoom = “卧室”;<br> &#125;<br> <br>class GoodGay&#123;<br>public: <br>    GoodGay();<br>    void vist();// 让vist可以访问Building私有成员<br>    void vist2()；// 让vist2不可以访问Building私有成员<br>    Building * builing // 让vist2不可以访问Building私有成员<br>    <br>&#125;;<br><br>GoodGay::GoodGay()&#123;<br>  builiding = new Builiding;<br>&#125;<br><br>void GoodGay::vist();&#123;<br>&#125;<br>void GoodGay::vist2();&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p><strong>运算符重载概念</strong>对已有的运算符重新定义，赋予其另一种功能，以适应不同的数据类型</p><p><strong>注意事项</strong>：运算符重载也可以发生函数重载</p><p>用<strong>operator</strong>运算符作为运算符的重载的运算符标记</p><h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p><strong>作用</strong>：实现两个自定义数据类型相加的运算</p><p>重载实现方法：</p><ul><li>通过成员函数重载+号</li><li>通过全局函数重载+号<br>用**operator+**作为加号运算符的重载的运算符标记</li></ul><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Person&#123;<br>public: <br>    //成员函数重载+号<br>    Person operator+(Person &amp;p)&#123;<br>          Person temp;<br>          temp.m_A = this-&gt;m_A + p.m_A;<br>          temp.m_B = this-&gt;m_B + p.m_B;<br>          return temp;<br>          &#125;;<br>    int m_A;<br>    int m_B;<br>&#125;;<br>Person operator+(Person &amp;p1, Person &amp;p2)&#123;<br>      Person temp;<br>      temp.m_A =  p1.m_A + p2.m_A;<br>      temp.m_A =  p1.m_A + p2.m_B;<br>      return temp;<br>      &#125;<br>Person operator+(Person &amp;p1, int num)&#123;<br>      Person temp;<br>      temp.m_A = p1.m_A + num;<br>      temp.m_B = p1.m_B + num;<br>      return temp;<br> &#125;<br> void test01()&#123;<br>    Person p1;<br>    p1.m_A=10;<br>    p1.m_B=10;<br>    Person p2;<br>    p2.m_A=10;<br>    p2.m_B=10;<br>    //本质调用<br>    Person p3=p1.operator+(p2);<br>    //简化调用<br>    Person p3=p1+p2;<br>    //运算符重载也可以发生函数重载<br>    Person p4=p1+10;<br>    cout&lt;&lt;&quot;p3.m_A= &quot;&lt;&lt;p3.m_A&lt;&lt;endl;<br>    cout&lt;&lt;&quot;p3.m_B= &quot;&lt;&lt;p3.m_B&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>对于内置的数据类型的表达式的运算符是不可能改变的</li><li>不要滥用运算符重载</li></ul></blockquote><h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p><strong>作用</strong>：可以输出自定义数据类型<br>重载实现方法：</p><ul><li>只能通过全局函数重载左移运算符<br><strong>注意事项</strong>：重载的成员函数要想访问类的私有成员，就得利用友元技术</li></ul><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Person&#123;<br>    friend ostream &amp;operator&lt;&lt;(ostream &amp;cout,Person &amp;p);<br>public:<br>    Person(int a,int b)&#123;<br>        m_A=a;<br>        m_B=b;<br>    &#125;<br>private:<br>    int m_A:<br>    int m_B;<br>&#125;;<br><br>//只能利用全局函数重载左移运算符<br>ostream &amp;operator&lt;&lt;(ostream &amp;cout,Person &amp;p)&#123;<br>    cout&lt;&lt;&quot;m_A= &quot;&lt;&lt;p.m_A&lt;&lt;&quot; m_B= &quot;&lt;&lt;p.m_B;<br>    return cout;<br>&#125;<br>/*这里声明是引用得原因是：当声明是void时，那么函数值返回值就是一个空类型得数据，<br>那么像换行时，直接&lt;&lt;endl是会报错的，之前之所以可以是因为链式链接，所以想要链式链接，就必须返回一个引用*/<br><br>void test01()&#123;<br>    Person p(10,10);<br>    cout&lt;&lt;p&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>cout是 C++ 标准库中的一个非常常用的对象</strong></p><h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><p><strong>作用</strong>：通过重载递增运算符，实现自己的整型数据类型</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class MyIntegar<br>&#123;<br>public:<br>  friend ostream &amp;operator&lt;&lt;(ostream &amp;cout,Person &amp;p);<br>  MyIntegar()&#123;<br>    m_Num = 0;<br>  &#125;<br>  //前置<br>  MyInteger&amp;  operator++()&#123;<br>    m_Num++；<br>    return *this;<br>  &#125;<br>  //operator++(int) int 表示占位参数，用于区分前后置递增<br>  void&amp;  operator++(int)&#123;<br>    //为什么不用引用：因为返回值是临时开辟的，函数结束后会自行销毁内存，这时候在引用就是非法操作<br>    MyInt temp = *this<br>    m_Num++;<br>    return temp;<br>  &#125;<br>  <br>private:<br>  int m_Num;<br>&#125;;<br>ostream&amp; operator &lt;&lt; (ostream&amp; cout, MyInterger myint); <br>void test01()&#123;<br>    MyInteger myint;<br>    cout &lt;&lt; ++myint &lt;&lt; endl;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>C++编译器至少给一个类添加4个函数<br>默认构造函数(无参，函数体为空)<br>默认析构函数(无参，函数体为空)<br>默认拷贝构造函数，对属性进行值拷贝<br>赋值运算符operator&#x3D;，对属性进行值拷贝<br>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题(堆区内存重复释放，导致程序崩溃)</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Person&#123;<br>public:<br>  Person(int age)&#123;<br>    m_Age = new(age);<br>    &#125;<br>  ~Person()&#123;<br>    if(m_Age != NULL)&#123;<br>    delete m_Age;<br>    m_Age = NULL;<br>    &#125;<br>    &#125;<br>    <br>    Person&amp; operator(Person &amp;p)&#123;<br>      //应先判断是否有属性在堆区，如果有就先释放干净，然后再深拷贝）<br>      delete m_Age;<br>      m_Age = NULL;<br>      &#125;<br>      //深拷贝<br>      m_Age = new int(*p.m_Age);<br>      return *this;<br>    &#125; <br>      <br>  int m_Age;<br>&#125;<br>void test01()&#123;<br>    Person p1(18);<br>    Person p2(20);<br>    p2 = p1;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Person&#123;<br>public:<br>    Person(string name,int age)&#123;<br>        m_Name=name;<br>        m_Age=age;<br>    &#125;<br>    bool operator==(Person &amp;p)&#123;<br>        if(this-&gt;m_Name==p.m_Name&amp;&amp;this-&gt;m_Age==p.m_Age)&#123;<br>            return true;<br>        &#125;<br>        return false;<br>    &#125;<br>    bool operator!=(Person &amp;p)&#123;<br>        if(this-&gt;m_Name!=p.m_Name&amp;&amp;this-&gt;m_Age!=p.m_Age)&#123;<br>            return false;<br>        &#125;<br>        return true;<br>    &#125;<br>    string m_Name;<br>    int m_Age;<br>&#125;;<br><br>void test01()&#123;<br>    Person p1(&quot;Tom&quot;,18);<br>    Person p2(&quot;Jerry&quot;,18);<br>    if(p1==p2)&#123;<br>        cout&lt;&lt;&quot;p1和p2是相等的&quot;&lt;&lt;endl;<br>    &#125;else&#123;<br>        cout&lt;&lt;&quot;p1和p2不相等&quot;&lt;&lt;endl;<br>    &#125;<br>    if(p1!=p2)&#123;<br>        cout&lt;&lt;&quot;p1和p2不相等&quot;&lt;&lt;endl;<br>    &#125;else&#123;<br>        cout&lt;&lt;&quot;p1和p2是相等的&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数调用运算符重载-仿函数"><a href="#函数调用运算符重载-仿函数" class="headerlink" title="函数调用运算符重载(仿函数)"></a>函数调用运算符重载(仿函数)</h3><ul><li>函数调用运算符()也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class MyPrint&#123;<br>public:<br>    //重载函数调用运算符<br>    void operator()(string test)&#123;<br>        cout&lt;&lt;test&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br>void test01()&#123;<br>    MyPrint myprint;<br>    //由于使用非常像函数调用，因此称为仿函数<br>    myprint(&quot;hello world&quot;);<br>&#125;<br><br>//仿函数非常灵活，没有固定的写法<br>class MyAdd&#123;<br>public:<br>    int operator()(int num1,int num2)&#123;<br>        return num1+num2;<br>    &#125;<br>&#125;;<br><br>void test02()&#123;<br>    MyAdd myadd;<br>    int ret=myadd(100,100);<br>    cout&lt;&lt;&quot;ret= &quot;&lt;&lt;ret&lt;&lt;endl;<br>    <br>    //匿名函数对象<br>    cout&lt;&lt;MyAdd()(100,100)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>继承是面向对象的三大特性之一</strong></p><p>我们发现，定义一些类时，下级别的成员除了拥有上一级的共性，还有自己的特性</p><p>这个时候我们就考虑利用继承的技术，减少重复代码</p><h3 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h3><p><strong>语法</strong>：class 子类:继承方式 父类类名</p><p>子类 也成为派生类</p><p>父类 也称为基类</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">公共类<br>class BasePage&#123;<br>public:<br>  void header()&#123;<br>    cout &lt;&lt; &quot;header&quot;  &lt;&lt; endl;<br>   &#125;<br>   void footer()&#123;<br>    cout &lt;&lt; &quot;footer&quot; &lt;&lt; endl;<br>    &#125;<br>class Java::public BasePage&#123;   <br>public:<br>  void content()&#123;<br>    cout &lt;&lt; &quot;content&quot; &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br>class Python::public  BasePage&#123;<br>public:<br>  void content()&#123;<br>    cout &lt;&lt; &quot;content&quot; &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br>class Cpp:public BasePage&#123;<br>public:<br>    void content()&#123;<br>        cout&lt;&lt;&quot;C++学科视频&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br>void test01()&#123;<br>    cout&lt;&lt;&quot;Java下载视频页面如下：&quot;&lt;&lt;endl;<br>    Java ja;<br>    ja.header();<br>    ja.footer();<br>    ja.content();<br>    cout&lt;&lt;&quot;python下载视频页面如下：&quot;&lt;&lt;endl;<br>    Python py;<br>    py.header();<br>    py.footer();<br>    py.content();<br>    cout&lt;&lt;&quot;C++下载视频页面如下：&quot;&lt;&lt;endl;<br>    Cpp cpp;<br>    cpp.header();<br>    cpp.footer();<br>    cpp.content();<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><p>继承的好处：可以减少重复的代码</p><p>派生类中的成员，包含两大部分：</p><ul><li>一类是从基类继承过来的，从基类继承过来的表现其共性</li><li>一类是自己增加的成员，新增的成员体现其个性</li></ul></blockquote><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承方式一共有三种：</p><ul><li>公共继承</li><li>父类的公共权限到子类依然是公共权限</li><li>父类的保护权限到子类中依然是保护权限</li><li>父类中的私有权限成员子类访问不到</li><li>保护继承</li><li>父类中公共成员到子类中，变为保护权限</li><li>父类中保护成员到子类中，依然为保护权限</li><li>父类中的私有权限成员子类访问不到</li><li>私有继承</li><li>父类的公共成员到子类变为私有成员</li><li>父类的保护成员到子类变为私有成员</li><li>父类中的私有权限成员子类访问不到</li></ul><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Base1&#123;<br>public:<br>  int m_A;<br>protected:<br>  int m_B;<br>private:<br>  int m_C;<br>&#125;;<br><br>//公共继承<br>class Son1:public Base1&#123;<br>public:<br>      void func()&#123;<br>          m_A = 10;// 父类的公共权限到子类依然是公共权限<br>          m_B = 10; // 父类的保护权限到子类依旧是保护权限<br>          // m_C =10;//父类中的私有权限成员子类访问不到<br>          &#125;<br>      &#125;<br>&#125;;<br><br>//保护继承<br>class Son2:protected Base1&#123;<br>public:<br>    void func()&#123;<br>        m_A = 100;// 变成保护权限<br>        m_B = 100;//变成保护权限<br>        //m_C = 100;//私有成员 访问不到<br>        &#125;<br>&#125;；<br>//私有继承<br>class Son3:private Base1&#123;<br>public:<br>    m_A=100;  //父类的公共成员到子类变为私有成员<br>    m_B=100;  //父类的保护成员到子类变为私有成员<br>    //m_C=10; //父类中的私有权限成员子类访问不到<br>&#125;;<br><br>void test01()&#123;<br>    Son1 s1;<br>    Son2 s2;<br>    Son3 s3;<br>    s1.m_A=100;<br>    //s1.m_B=100;  保护权限类外不能访问<br>    //s2.m_A=1000; 保护权限类外不能访问<br>    //s3.m_A=1000; //私有权限类外不能访问<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><p>父类的所有非静态成员属性，子类都继承下来</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Base&#123;<br>public:<br>    int m_A;<br>protected:<br>    int m_B;<br>private:<br>    int m_C;<br>&#125;;<br><br>class Son:public Base&#123;<br>public:<br>   int m_D;<br>&#125;;<br><br>void test01()&#123;<br>  cout&lt;&lt; sizeof(Son) &lt;&lt; endl;<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：父类的私有属性也被子类继承下来了，只是访问不到，但是依然存在于子类中</p></blockquote><h3 id="继承中的构造和析构顺序"><a href="#继承中的构造和析构顺序" class="headerlink" title="继承中的构造和析构顺序"></a>继承中的构造和析构顺序</h3><p>总结：父类的私有属性也被子类继承下来了，只是访问不到，但是依然存在于子类中</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs [c++[">class Base&#123;<br>public:<br>    Base()&#123;<br>        cout&lt;&lt;&quot;Base构造函数&quot;&lt;&lt;endl;<br>    &#125;<br>    ~Base()&#123;<br>        cout&lt;&lt;&quot;Base析构函数&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br>class Son:public Base&#123;<br>public:<br>    Son()&#123;<br>        cout&lt;&lt;&quot;Base构造函数&quot;&lt;&lt;endl;<br>    &#125;<br>    ~Son()&#123;<br>        cout&lt;&lt;&quot;Base析构函数&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><br>void test01()&#123;<br>    //Base b;<br>    Son s;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><p>先构造父类，再构造子类，析构顺序与构造顺序相反</p></blockquote><h3 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h3><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加作用域<br>访问父类同名成员语法：</li></ul><p>子类实例对象.父类名称::要调用的父类同名成员</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Base&#123;<br>public:<br>    Base()&#123;<br>      m_A = 100;<br>    &#125;<br>    void func()&#123;<br>        cout &lt;&lt; &quot;base-func&quot; &lt;&lt; endl;<br>     &#125;<br>     void func(int a)&#123;<br>        cout &lt;&lt; &quot;base-func(int)调用“ &lt;&lt; endl;<br>    &#125;<br>     int m_A;<br>&#125;;<br><br>class Son:public Base&#123;<br>public:<br>      Son()&#123;<br>        m_A = 200;<br>      &#125;<br>     <br>      void func()&#123;<br>        cout&lt;&lt;&quot;Son-func函数调用&quot;&lt;&lt;endl;<br>      &#125;<br>      <br>      void func(int a)&#123;<br>        cout&lt;&lt;&quot;Son-func(int)函数调用&quot;&lt;&lt;endl;<br>    &#125;<br>    int m_A;<br>    &#125;;<br>     void test01()&#123;<br>    Son s;<br>    cout&lt;&lt;&quot;Son 下m_A&quot;&lt;&lt;s.m_A&lt;&lt;endl;<br>    cout&lt;&lt;&quot;Base 下m_A&quot;&lt;&lt;s.Base::m_A&lt;&lt;endl;<br>&#125;<br>    void test02()&#123;<br>        Son s;<br>        s.func();<br>        s.Base::func();<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：</p><ul><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ul></blockquote><h3 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h3><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加作用域</li></ul><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Base&#123;<br>public:<br>    static int m_A;<br>    static void func()&#123;<br>        cout&lt;&lt;&quot;Base-static func的调用&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br>int Base::m_A=100;<br><br>class Son:public Base&#123;<br>public:<br>    static int m_A;<br>    static void func()&#123;<br>        cout&lt;&lt;&quot;Son-static func的调用&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;;<br>int Son::m_A=200;<br><br>//同名静态成员属性<br>void test01()&#123;<br>    Son s;<br>    //1.通过对象访问静态成员<br>    cout&lt;&lt;&quot;Son m_A=&quot;&lt;&lt;s.m_A&lt;&lt;endl;<br>    cout&lt;&lt;&quot;Base m_A=&quot;&lt;&lt;s.Base::m_A&lt;&lt;endl;<br>    //2.通过类名访问静态成员<br>    cout&lt;&lt;&quot;通过类名访问静态成员&quot;&lt;&lt;endl;<br>    cout&lt;&lt;&quot;Son m_A=&quot;&lt;&lt;Son::m_A&lt;&lt;endl;<br>    cout&lt;&lt;&quot;Base m_A=&quot;&lt;&lt;Son::Base::m_A&lt;&lt;endl;<br>&#125;<br><br>//同名静态成员函数<br>void test02()&#123;<br>    Son s;<br>    s.func();<br>    s.Base::func();<br>    Son::func();<br>    Son::Base::func();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：<br>同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式(通过对象和通过类名)</p></blockquote><h3 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h3><p>c++中允许一个类继承多个类<br>语法：<br>class 子类:继承方式 父类1,继承方式 父类2…<br>注意事项：</p><ul><li>多继承可能会引发父类中有同名成员出现，需要加作用域区分</li><li>C++实际开发中不建议用多继承</li></ul><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"><br>class Base1&#123;<br>public:<br>    Base()&#123;<br>        m_A=100;<br>    &#125;<br>    int m_A;<br>&#125;;<br><br>class Base2&#123;<br>public:<br>    Base2()&#123;<br>        m_A=200;<br>    &#125;<br>    int m_A;<br>&#125;;<br><br>class Son:public Base1,public Base2&#123;<br>public:<br>    Son()&#123;<br>        m_C=300;<br>        m_D=400;<br>    &#125;<br>    int m_C;<br>    int m_D;<br>&#125;;<br><br>void test01()&#123;<br>    Son s;<br>    cout&lt;&lt;&quot;sizeof Son=&quot;&lt;&lt;sizeof(s)&lt;&lt;endl;<br>    cout&lt;&lt;&quot;m_A=&quot;&lt;&lt;s.Base1::m_A&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p><strong>概念</strong>：</p><p>两个派生类继承同一个基类，又有某个类同时继承着两个派生类，这种继承被称为菱形继承，或者钻石继承</p><p><strong>问题</strong>：</p><p>同名成员产生二义性，并且继承两个派生类的类会继承两份来自同一个基类的数据(资源浪费)，但是实际只需要一份就行了</p><p><strong>解决方法</strong>：</p><p>利用虚继承解决菱形继承的问题，语法：class 子类:virtual public 父类{};,则父类被称为虚基类,进行了虚继承(底层利用虚基类指针，让两个类都指向同一份数据)，则继承的数据是共享的，更改两份继承下来的数据就是更改一份数据。</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [c++[">菱形继承<br>概念：<br><br>两个派生类继承同一个基类，又有某个类同时继承着两个派生类，这种继承被称为菱形继承，或者钻石继承<br><br>问题：<br><br>同名成员产生二义性，并且继承两个派生类的类会继承两份来自同一个基类的数据(资源浪费)，但是实际只需要一份就行了<br><br>解决方法：<br><br>利用虚继承解决菱形继承的问题，语法：class 子类:virtual public 父类&#123;&#125;;,则父类被称为虚基类,进行了虚继承(底层利用虚基类指针，让两个类都指向同一份数据)，则继承的数据是共享的，更改两份继承下来的数据就是更改一份数据。<br><br></code></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h3><p>多态分为两类：</p><ul><li><p>静态多态：函数重载和运算符重载属于静态多态，复用函数名</p></li><li><p>动态多态：派生类和虚函数(加virtual关键词)实现运行时多态</p></li><li><p>静态多态和动态多态的区别：</p></li><li><p>静态多态的函数地址早绑定 - 编译阶段确定函数地址</p></li><li><p>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</p></li></ul><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Animal&#123;<br>public:<br>    //虚函数，加入virtual关键词<br>    virtual void speak()&#123;<br>        cout&lt;&lt;&quot;动物在说话&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br>class Cat:public Animal&#123;<br>public:<br>    void speak()&#123;<br>        cout&lt;&lt;&quot;小猫在说话&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br>//没加virtual关键词,地址早绑定，在编译阶段就确定函数地址<br>//如果想执行让猫说话，则函数地址不能提前绑定，需要晚绑定<br>void doSpeak(Animal &amp;animal)&#123;<br>    animal.speak();<br>&#125;<br><br>void test01()&#123;<br>    Cat cat;<br>    doSpeak(cat);//执行动物在说话<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>虚函数<br><strong>虚函数的主要特点</strong>：</p><ul><li>动态绑定：虚函数的调用是在运行时（而非编译时）解析的。这意味着函数调用将根据对象的实际类型来确定调用哪个版本的函数。</li><li>基类声明：虚函数通常在基类中声明，并在派生类中重写。</li><li>覆盖机制：派生类可以覆盖（Override）基类的虚函数。</li><li>基类指针或引用：可以通过基类的指针或引用来调用虚函数，此时会根据指针或引用指向的对象的实际类型来调用相应的函数。</li></ul></blockquote><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期扩展以及维护<blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态的优点很多</p></blockquote></li></ul><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容<br>因此可以将虚函数改为纯虚函数<br><strong>语法</strong>：virtual 返回值类型 函数名 (参数列表) &#x3D; 0;<br>当类中有了纯虚函数，这个类也成为抽象类<br>抽象类特点：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Base&#123;<br>  virtual void func() = 0;<br>  &#125;;<br>  class Son:public Base&#123;<br>  public:<br>      void func()&#123;<br>          cout &lt;&lt; &quot;Son func&quot; &lt;&lt; endl;<br>          &#125;<br>  &#125;;<br>  <br>  void test01()&#123;<br>    //Base b; 抽象类无法实例化对象<br>    Son s;// 如果没有重写父类的纯虚函数，则该子类也为抽象类<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="虚析构和纯析构"><a href="#虚析构和纯析构" class="headerlink" title="虚析构和纯析构"></a>虚析构和纯析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码<br><strong>解决方式</strong>：将父类中的析构函数改为虚析构或者纯虚析构<br><strong>虚析构和纯虚析构共性</strong>:</p><ul><li>可以解决父类指针释放子类对象的问题</li><li>都需要有具体的函数实现<br><strong>虚析构和纯虚析构区别</strong>：</li><li>如果是纯虚析构，该类属于抽象类，无法实例化对象<br><strong>虚析构语法:</strong> virtual <del>类名(){}<br><strong>纯虚析构语法：</strong><br>virtual ~类名()&#x3D;0; 类外：类名::</del>类名(){}<br><strong>注意事项</strong>:需要声明，也需要具体的实现代码(在类外实现)，有了纯虚析构函数之后，这个类也属于抽象类，无法实例化对象<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Animal&#123;<br>public:<br>   Animal()&#123;<br>      cout &lt;&lt; &quot;Animal构造函数&quot; &lt;&lt; endl;<br>    &#125;<br>    ////利用虚析构可以解决父类指针释放子类对象时不干净的问题<br>   virtual ~Animal()&#123; <br>      cout&lt;&lt;&quot;Animal析构函数&quot; &lt;&lt; endl;<br>    &#125;<br>    //纯虚析构函数<br>    virtual ~Animal() = 0;<br>    virtual void speak() = 0;<br>&#125;;<br>Animal::~Animal()&#123;<br>  cout &lt;&lt; &quot;Animal纯虚析构&quot; &lt;&lt; endl;<br>  &#125;;<br>  <br>class Cat: public Animal&#123;<br>public:  <br>    virtual void speak()&#123;<br>            cout &lt;&lt; *m_Name &lt;&lt; &quot;cat&quot;&lt;&lt; ednl;<br>      &#125;<br>      Cat(string name)&#123;<br>        cout &lt;&lt; &quot;构造&quot; &lt;&lt; ednl;<br>        m_Name = new string(name);<br>      &#125;;<br>      ~Cat()&#123;<br>          if(m_Name != NULL) &#123;<br>            cout &lt;&lt; &quot;析构函数&quot; &lt;&lt;endl;<br>            delete m_Name;<br>            m_Name = NULL;<br>            &#125;<br>      &#125;<br>      string *m_Name;<br>&#125;;<br><br>void test01()&#123;<br>      Animal *animal new Cat(&quot;Tom&quot;);<br>      animal-&gt;speak();<br>      //父类指针在析构时候不会调用析构函数，导致子类如果有堆区属性，会出现内存泄漏<br></code></pre></td></tr></table></figure><blockquote><blockquote><p><strong>总结</strong><br>虚析构或纯虚析构就是用来解决通过父类指针释放的子类对象<br>如果子类中没有堆区数据，可以不写虚析构或纯虚析构函数<br>拥有纯虚析构函数的类也属于抽象类</p></blockquote></blockquote></li></ul><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过文件可以将数据持久化</p><p>C++中对文件操作需要包含头文件****</p><p>文件类型分为两种：</p><ul><li>文本文件 - 文件以文本的ASCII码形式存储在计算机中</li><li>二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们<br>操作文件的三大类：</li><li>ofstream：写操作</li><li>ifstream：读操作</li><li>fstream：读写操作</li></ul><h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件步骤如下： </p><ol><li>包含头文件 <figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;fstream&gt;<br></code></pre></td></tr></table></figure></li><li>创建流对象<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">ofstream ofs;<br></code></pre></td></tr></table></figure></li><li>打开文件<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">ofs.open(&quot;文件路径&quot;，打开方式);<br></code></pre></td></tr></table></figure></li><li>写数据<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">ofs &lt;&lt; &quot;写入数据&quot;; <br></code></pre></td></tr></table></figure></li><li>关闭文件<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">ofs.close();<br></code></pre></td></tr></table></figure><strong>文件打开方式</strong>：</li></ol><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意</strong>文件打开方式可以配合使用，利用*|*操作符<br>例如：用二进制方式写文件ios::binary|ios::out</p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>读文件与写文件步骤相似，但是读取方式相对于比较多<br>读文件步骤如下：</p><ol><li>包含头文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs [c++]bush">#include &lt;fstream&gt;<br></code></pre></td></tr></table></figure></li><li>创建流对象：<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">ifstream ifs;<br></code></pre></td></tr></table></figure></li><li>打开文件并判断文件是否打开成功<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">ifs.open(&quot;文件路径&quot;,打开方式);<br></code></pre></td></tr></table></figure></li><li>读数据<br>四种方式读取</li><li>关闭文件<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">```<br>```[c++] bush<br>#include &lt;iostream&gt;<br>#include &lt;fstream&gt;<br>#include &lt;string&gt;<br>using namespace std;<br><br>int main() &#123;<br>    ifstream ifs;<br>    ifs.open(&quot;test.txt&quot;,ios::in);<br>    if(!ifs.is_open())&#123;<br>        cout&lt;&lt;&quot;文件打开失败&quot;&lt;&lt;endl;<br>        return 0;<br>    &#125;<br>    //读数据<br>    //第一种<br>//    char buf[1024]=&#123;0&#125;;<br>//    while(ifs&gt;&gt;buf)&#123;<br>//        cout&lt;&lt;buf&lt;&lt;endl;<br>//    &#125;<br><br>    //第二种<br>//    char buf[1024]=&#123;0&#125;;<br>//    while(ifs.getline(buf,sizeof(buf)))&#123;<br>//        cout&lt;&lt;buf&lt;&lt;endl;<br>//    &#125;<br><br>    //第三种<br>//    string buf;<br>//    while (getline(ifs,buf))&#123;<br>//        cout&lt;&lt;buf&lt;&lt;endl;<br>//    &#125;<br><br>    //第四种,不推荐<br>    char c;<br>    while((c=ifs.get())!=EOF)&#123;  //EOF end of file<br>        cout&lt;&lt;c;<br>    &#125;<br>    ifs.close();<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong></p><ul><li>读文件可以利用ifstream，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close关闭文件</li></ul></blockquote></li></ol><h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>以二进制的方式对文件进行读写操作<br>打开方式要指定为iso::binary</p><h3 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h3><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型：ostream&amp; write(const char * buffer,int len);</p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;fstream&gt;<br>using namespace std;<br><br>class Person&#123;<br>public:<br>    char m_Name[64];<br>    int m_Age;<br>&#125;;<br><br>void test01() &#123;<br>    ofstream ofs(&quot;test1.txt&quot;,ios::out|ios::binary);<br>//    ofs.open(&quot;test1.txt&quot;,ios::out|ios::binary);<br>    Person p=&#123;&quot;张三&quot;,18&#125;;<br>    //要把数据地址转化成const char*<br>    ofs.write((const char*)&amp;p,sizeof(Person));<br>    ofs.close();<br>&#125;<br><br>int main() &#123;<br>    test01();<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h3><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：istream&amp; read(char *buffer,int len);</p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;fstream&gt;<br>using namespace std;<br><br>class Person&#123;<br>public:<br>    char m_Name[64];<br>    int m_Age;<br>&#125;;<br><br>void test01()&#123;<br>    ifstream ifs(&quot;test1.txt&quot;,ios::in|ios::binary);<br>    if(!ifs.is_open())&#123;<br>        cout&lt;&lt;&quot;文件打开失败&quot;&lt;&lt;endl;<br>        return;<br>    &#125;<br>    Person p;<br>    ifs.read((char*)&amp;p, sizeof(Person));<br>    cout&lt;&lt;p.m_Name&lt;&lt;&quot;  &quot;&lt;&lt;p.m_Age&lt;&lt;endl;<br>    ifs.close();<br>&#125;<br><br>int main() &#123;<br>    test01();<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p><strong>概念</strong>:<br>模板就是建立通用的模具，大大提高复用性<br><strong>特点</strong>：</p><ul><li>模板不可以直接使用，它只是一个框架</li><li>模板的通用并不是万能的</li></ul><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul><li>C++另一种编程思想称为泛型编程，主要利用的技术就是模板</li><li>C++提供两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></li></ul><h3 id="函数模板语法"><a href="#函数模板语法" class="headerlink" title="函数模板语法"></a>函数模板语法</h3><p><strong>作用</strong>：<br>建立一个通用函数，其返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表<br><strong>语法：</strong></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">template&lt;typename T&gt; //template&lt;class T&gt; 两个效果都一样<br>函数声明或定义<br></code></pre></td></tr></table></figure><p><strong>解释</strong>：<br>template — 声明创建模板<br>typename — 表现其后面的符号是一种数据类型，可以用class代替<br>T — 通用的数据类型，名称可以替换，通常为大写字母</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">template&lt;typename T&gt;<br>void mySwap(T &amp;a, T &amp;B)&#123;<br>  T temp = a;<br>  a = b;<br>  b = temp;<br>&#125;<br><br>void test01()&#123;<br>    // 利用函数模板<br>    //两种方式使用函数模板<br>    //1.自动类型推导<br>    mySwap(a,b);<br>    //2.显示指定类型<br>    mySwap&lt;int&gt;(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数模板注意事项"><a href="#函数模板注意事项" class="headerlink" title="函数模板注意事项"></a>函数模板注意事项</h3><p><strong>注意事项</strong>：</p><ul><li>自动类型推导，必须推到出一致的数据类型T，才可以使用</li><li>模板必须要确定出T的数据类型，才可以使用<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">template&lt;class T&gt;<br>void mySwap(T &amp;a, T &amp;b)<br>&#123;<br>      T  temp = a;<br>      a = b;<br>      b = temp;<br>&#125;<br><br>void test01()<br>&#123;<br>    int a = 10;<br>    int b = 20;<br>    char c = &#x27;c&#x27;;<br>    <br>    mtSwap(a,b);<br>    mtSwap(a,c);//报错，推导不出一样的T类型   <br>&#125;<br><br>template&lt;class T&gt;<br>void func()&#123;<br>    cout &lt;&lt; &quot;func&quot; &lt;&lt; endl;<br>&#125;<br><br>void test02()&#123;<br><br>    func();//报错，没有类型<br>    func&lt;int&gt;();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><p><strong>普通函数和函数模板的区别</strong>：</p><ul><li>普通函数调用时可以发生自动类型转换(隐式类型转换)</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">int myAdd(int a, int b)&#123;<br>      return a + b;<br>&#125;<br>void test01()&#123;<br><br>    int a = 10;<br>    int b = 10;<br>    char c = &#x27;c&#x27; <br>    cout &lt;&lt; myAdd(a,c) &lt;&lt; endl; //普通函数调用时可以发生自动类型转换(隐式类型转换)<br>&#125;<br>template&lt;class T&gt;<br>T myAdd002(T a, T b)&#123;<br>    int a = 10;<br>    char c = &#x27;c&#x27;;<br>    cout &lt;&lt;myAdd002(a,c) &lt;&lt; endl;//报错，函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换<br>    cout &lt;&lt; myAdd02&lt;int&gt;(a,c)&lt;&lt; endl;//正确<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：<br>建议使用指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p></blockquote></li></ul><h3 id="普通函数和函数模板的调用规则"><a href="#普通函数和函数模板的调用规则" class="headerlink" title="普通函数和函数模板的调用规则"></a>普通函数和函数模板的调用规则</h3><p><strong>调用规则如下</strong>：</p><ul><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">void myPrint(int a, int b)&#123;<br>     cout &lt;&lt; &quot;普通&quot; &lt;&lt; endl;<br> &#125;<br>template&lt;class T&gt;<br>void myPrint(T a, T b)&#123;<br>      cout &lt;&lt; &quot;模板&quot; &lt;&lt;  endl;<br>&#125;<br>template&lt;class T&gt;<br>void myPrint(T a, T b, T c)&#123;<br>      cout &lt;&lt; &quot;重载模板&quot; &lt;&lt;  endl;<br>&#125;<br>void test001()&#123;<br>      int a = 10;<br>      int b = 20;<br>      <br>      myPrint(a,b); //打印了普通，如果只有函数声明，没有函数实现的话，程序会报错<br>      //通过空模板参数列表，强制调用函数模板<br>      myPrint&lt;&gt;(a,b);<br>      <br>      myPrint&lt;&gt;(a,b, 100); //打印了重载函数<br>      <br>      //如果函数模板可以产生更好的匹配，优先调用函数模板<br>      char c1 = &quot;a&quot;;<br>      char c2 = &quot;b&quot;;<br>      myPrint(a,b); // 函数模板<br>      <br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：既然有了函数模板，最好就不要提供同名普通函数，否则容易出现二义性</p></blockquote></li></ul><h3 id="模板的局限性以及具体化"><a href="#模板的局限性以及具体化" class="headerlink" title="模板的局限性以及具体化"></a>模板的局限性以及具体化</h3><p><strong>局限性</strong>：<br>-模板的通用性并不是万能的</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">template&lt;class T&gt;<br>void f(T a,T b)&#123;<br>    a=b;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了<br>再例如：</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">template&lt;class T&gt;<br>void f(T a,T b)&#123;<br>    if(a&gt;b)&#123;<br>        ....<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，如果T的数据类型传入是像Person这样自定义的数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供了模板的重载，可以为这些特定的类型提供具体化的模板</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Person&#123;<br>public:<br>  Person(string name, int age)<br>  &#123;<br>      this-&gt;m_Name = name;<br>      this-&gt;m_Age = age;<br>      &#125;<br>template&lt;class T&gt;<br>bool myCompare(T &amp;a, T &amp;b)<br>&#123;<br>      if(a == b)<br>        return ture;<br>      else<br>        return false;<br>&#125;<br><br>//利用具体化的版本实现代码，具体化优先调用<br>template&lt; &gt; bool myCompare(Person &amp;p1, Person &amp;p2)&#123;<br>      if(p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)<br>        return ture;<br>      else<br>        retrun fals;<br><br>void test01()&#123;<br>        int a = 10;<br>        int b = 20; <br>        <br>        bool ret MyCompare(a,b);<br>      if(ret)<br>          cout &lt;&lt; &quot;ture&quot; &lt;&lt;endl;<br>      else<br>          cout &lt;&lt; &quot;flase&quot; &lt;&lt;ednl;<br><br>&#125;<br>void test02()&#123;<br>      Perosn p1(&quot;Tom&quot;, 10);<br>      Person p2(&quot;Tom&quot;, 10);<br>      <br>      bool ret = myComare(p1, p2);<br>      if(p1 == p2)<br>        return 1;<br>      else<br>        return 0;<br></code></pre></td></tr></table></figure><blockquote><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul></blockquote><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>作用：</p><ul><li>建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表<br>语法:template<class T><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">template&lt;class nametype, class agetype&gt;<br>class Person&#123;<br>public: <br>    Person(nametype name, agetype age)&#123;<br>        this-&gt;m_name = name;<br>        this-&gt;m_age = age;<br>        &#125;<br>    void show()&#123;<br>        cout &lt;&lt; this-&gt;name &lt;&lt; this-&gt;age &lt;&lt; endl;<br>    &#125;<br>    nametype m_name;<br>    agetype m_age;<br>    &#125;;<br><br>void test01()&#123;<br>    Person01()&#123;<br>        Person&lt;string,int&gt; p1(&quot;孙悟空&quot;, 999);       <br>   &#125;<br></code></pre></td></tr></table></figure>类模板与函数模板区别<br>区别：</li><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">template&lt;class nametype ,class agetype = int &gt;<br>class Person&#123;<br>public:<br>    Person(nametype name, agetype age)&#123;<br>        this-&gt;m_name = name;<br>        this-&gt;m_age = age;<br>        &#125;<br>        void show()&#123;<br>            cout &lt;&lt; this-&gt;m_name &lt;&lt; this-&gt;m_age&lt;&lt; endl;<br>            &#125;<br>        nametype m_name;<br>        agetype m_age;<br>        &#125;<br><br>void test01()&#123;<br>  Person p(&quot;孙悟空&quot; ,999); // 报错，类模板是没有自动类型推导的<br>  Person p1&lt;string ,int&gt; p1(&quot;孙悟空&quot;，999);<br>  Person p1&lt;string&gt;p1(&quot;孙悟空&quot;, 999)//模板类默认为int类型，所以可以不用写int<br>  p1.show();<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong></p><ul><li>类模板使用只能用显示指定类型方式</li><li>类模板中的模板参数列表可以有默认参数</li></ul></blockquote></li></ul><h3 id="类模板中成员函数创建时机"><a href="#类模板中成员函数创建时机" class="headerlink" title="类模板中成员函数创建时机"></a>类模板中成员函数创建时机</h3><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">class Person1&#123;<br>public:<br>    void show1()&#123;<br>        cout&lt;&lt;&quot;person1show&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br>class Person2&#123;<br>public:<br>    void show2()&#123;<br>        cout&lt;&lt;&quot;person2show&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br>template&lt;class T&gt;<br>class myclass&#123;<br>public:<br>    T obj;<br>    //类模板中成员函数<br>    void func1()&#123;<br>        obj.show1();<br>    &#125;<br>    void func2()&#123;<br>        obj.show2();<br>    &#125;<br>&#125;;<br><br>void test01()&#123;<br>    myclass&lt;Person1&gt;m;<br>    m.func1();<br>    //m.func2();<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h3><p>类模板实例化出的对象，向函数传参的方式<br>三种传参方式：</p><ul><li>指定传入的类型 — 直接显示对象的数据类型</li><li>参数模板化 — 将对象中的参数变为模板进行传递</li><li>整个类模板化 — 将这个对象类型模板化进行传递<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">temp;ate&lt;class T1,class T2&gt;<br>class Person&#123;<br>public:<br>&#123;<br>    Person(T1 name, T2 age)&#123;<br>     this-&gt;m_Name = name;<br>     this-&gt;m_Age = age;<br>     &#125;  <br>     void show()&#123;<br>      cout &lt;&lt; this-&gt;m_Mame &lt;&lt; this-&gt;m_Age &lt;&lt; endl; <br>      &#125;;<br>      <br>      T1 m_Name;<br>      T2 m_Age;<br>      &#125;<br>//指定传入类型<br>void print1(Person&lt;string,int&gt;&amp;p)&#123;<br>          p.show<br>&#125;<br><br><br>void test01()&#123;<br>        Person p1&lt;string ,int&gt; p(&quot;孙悟空&quot;，999);<br>        print(p)<br>&#125;<br>//参数模板化<br>template&lt;class T1, T2&gt;<br>void print2(Person&lt;T1, T2&gt; &amp;p)&#123;<br>         p.show();<br>         cout&lt;&lt;&quot;T1的类型为：&quot;&lt;&lt;typeid(T1).name()&lt;&lt;endl; //看推导出来的T1是什么类型<br>&#125;<br>//类模板化<br>template&lt;class T&gt;<br>void print3&lt;class T&gt;<br>&#123;<br>          p,show()<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛的是第一种：指定传入的类型</li></ul></blockquote></li></ul><h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需要变为类模板<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs [c++&#125;">template&lt;class T&gt;<br>class Base&#123;<br>   T m;<br>   &#125;<br> <br>class Son:public Base&lt;int&gt;&#123;<br>   <br>&#125;<br><br>template &lt;class T1,class T2&gt;<br>class Son2: public Base&lt;T2&gt;&#123;<br>   T1 obj;<br>&#125;;<br><br>Void  tes01()&#123;<br>      Son S1;<br>      Son&lt;int, char&gt; S2<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">template&lt;class T1, class T2&gt;<br>class Person&#123;<br>public:<br>    Person(T1 name , T2 age);<br>    void show();<br>    T1 m_Name;<br>    T2 m_Age;    <br>&#125;;<br>template&lt;class T1, class T2&gt;<br>Person&lt;T1,T2&gt;::Person(T1 name , T2 age)&#123;<br>      this-&gt;m_Name = name;<br>      this-&gt;m_Age = age;<br>&#125;<br><br>Person&lt;T1,T2&gt;::void show()&#123;<br>cout  &lt;&lt; this-&gt;m_Name &lt;&lt; this-&gt;m_Age &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：类模板中成员函数类外实现时，需要加入模板的参数列表</p></blockquote><h3 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h3><p>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到<br><strong>解决方法</strong>：</p><ul><li>直接包含.cpp源文件</li><li>将声明和实现写到同一个文件中，并更改后缀名为.hpp,hpp是约定的名称，并不是强制</li></ul><p><strong>分文件编写的.h写法</strong>：</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#pragma once  //防止重复<br>#include &lt;iostream&gt;<br>using namespace std;<br></code></pre></td></tr></table></figure><p>示例：<br>&#x2F;&#x2F;第一种解决方法<br>Person.h代码：</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#pragma once <br>#include &lt;iostream&gt;<br>using namespace std;<br>#include &lt;string&gt;<br><br>template&lt;class T1,class T2&gt;<br>class Person&#123;<br>public:<br>    Person(T1 name,T2 age);<br>    void show();<br>    T1 m_name;<br>    T2 m_age;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Person.cpp代码:</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#pragma once <br>#include &lt;iostream&gt;<br>using namespace std;<br>#include &lt;string&gt;<br><br>template&lt;class T1,class T2&gt;<br>class Person&#123;<br>public:<br>    Person(T1 name,T2 age);<br>    void show();<br>    T1 m_name;<br>    T2 m_age;<br>&#125;;<br></code></pre></td></tr></table></figure><p>main.cpp代码</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &quot;Person.cpp&quot;<br><br>void test01()&#123;<br>    Person&lt;string,int&gt;P(&quot;tom&quot;,20);<br>    P.show();<br>&#125;<br><br>int main()&#123;<br>    test01();<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种解决方法<br>将.h和.cpp中的内容写到一起，将后缀名改为.hpp文件<br>.hpp被称为类模板<br>Person.hpp</p><figure class="highlight plaintext"><figcaption><span>bsuh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#pragma once <br>#include &lt;iostream&gt;<br>using namespace std;<br>#include &lt;string&gt;<br><br>template&lt;class T1,class T2&gt;<br>class Person&#123;<br>public:<br>    Person(T1 name,T2 age);<br>    void show();<br>    T1 m_name;<br>    T2 m_age;<br>&#125;;<br><br>template&lt;class T1,class T2&gt;<br>Person&lt;T1,T2&gt;::Person(T1 name,T2 age)&#123;<br>    this-&gt;m_name=name;<br>    this-&gt;m_age=age;<br>&#125;<br><br>template&lt;class T1,class T2&gt;<br>void Person&lt;T1,T2&gt;::show()&#123;<br>    cout&lt;&lt;&quot;name: &quot;&lt;&lt;this-&gt;m_name&lt;&lt;&quot;age= &quot;&lt;&lt;this-&gt;m_age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>类模板与友元<br>类模板模板配合友元函数的类内和类外实现<br><strong>全局函数类外实现</strong> - 直接在类内声明友元即可<br><strong>全局函数类外实现</strong> - 需要提前让编译器知道全局函数的存在</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">//类外实现，需要让编译器提前知道Person类的存在<br>template&lt;class T1,class T2&gt;<br>class Person;<br><br>//通过全局函数打印Person信息<br>template&lt;class T1,class T2&gt;<br>class Person&#123;<br>    //全局函数类内实现<br>    friend void print(Person&lt;T1,T2&gt;p)&#123;<br>        cout&lt;&lt;&quot;name: &quot;&lt;&lt;p.m_name&lt;&lt;&quot;age= &quot;&lt;&lt;p.m_age&lt;&lt;endl;<br>    &#125;<br>    //全局函数类外实现<br>    //需要加空模板参数列表<br>    //如果全局函数是类外实现的话，需要提前让编译器知道全局函数的存在<br>    friend void print1&lt;&gt;(Person&lt;T1,T2&gt;p);<br>public:<br>    Person(T1 name,T2 age)&#123;<br>        this-&gt;m_name=name;<br>        this-&gt;m_age=age;<br>    &#125;<br>private:<br>    T1 m_name;<br>    T2 m_age;<br>&#125;;<br><br>template&lt;class T1,class T2&gt;<br>void print(Person&lt;T1,T2&gt; p)&#123;<br>    cout&lt;&lt;&quot;类外实现name: &quot;&lt;&lt;p.m_name&lt;&lt;&quot;age= &quot;&lt;&lt;p.m_age&lt;&lt;endl;<br>&#125;<br><br>void test01()&#123;<br>    Person&lt;string,int&gt;p(&quot;tom&quot;,20);<br>    print(p);<br>    print1(p);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h1><h2 id="STL的诞生"><a href="#STL的诞生" class="headerlink" title="STL的诞生"></a>STL的诞生</h2><ul><li>长久以来，软件界一直希望建立一种可重复利用的东西</li><li>C++的面向对象和泛型编程思想，目的就是复用性的提升</li><li>大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准，诞生了STL</li></ul><h2 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h2><p>STL(Standard Template Library,标准模板库)<br>STL从广义上分为：容器(container) 算法(algorithm) 迭代器(iterator)<br>容器和算法之间通过迭代器进行无缝连接<br>STL几乎所有代码都采用了模板类或者模板函数</p><h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><p>STL大体分为六大组件，分别为：容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器</p><ul><li>容器：各种数据结构，如：vector、list、deque、set、map等，用来存放数据</li><li>算法：各种常用的算法，如：sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂</li><li>仿函数：行为类似函数，可作为算法的某种策略</li><li>适配器：一种用来修饰容器或者仿函数或者迭代器接口的东西</li><li>空间配置器：负责空间的配置与管理。</li></ul><h2 id="STL中容器、算法、迭代器"><a href="#STL中容器、算法、迭代器" class="headerlink" title="STL中容器、算法、迭代器"></a>STL中容器、算法、迭代器</h2><p><strong>容器</strong>：置物之所也<br>STL容器就是将运用最广泛的一些数据结构闪现出来<br>常用的数据结构：数组，链表，树，栈，队列，集合，映射表等<br>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种：</p><ul><li>序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置</li><li>关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系<br><strong>算法</strong>：问题之解法也</li></ul><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们称为算法(Algorithms)<br>算法分为<strong>质变算法</strong>和<strong>非质变算法</strong>：</p><ul><li><strong>质变算法</strong>：是指运算过程中会更改区间内的元素的内容，例如：拷贝，替换，删除等等</li><li><strong>非质变算法</strong>：是指运算过程中不会更改区间内的元素内容，例如：查找，计数，遍历，寻找极值等等</li></ul><p><strong>迭代器</strong>：容器和算法之间粘合剂<br>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式<br>每个容器都有自己专属的迭代器<br>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针<br><strong>迭代器种类</strong>：</p><table><thead><tr><th><strong>种类</strong></th><th><strong>功能</strong></th><th><strong>支持运算</strong></th></tr></thead><tbody><tr><td><strong>输入迭代器</strong></td><td>对数据的只读访问</td><td>只读，支持++、&#x3D;&#x3D;、!&#x3D;</td></tr><tr><td><strong>输出迭代器</strong></td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td><strong>前向迭代器</strong></td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、&#x3D;&#x3D;、!&#x3D;</td></tr><tr><td><strong>双向迭代器</strong></td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–</td></tr><tr><td><strong>随机访问迭代器</strong></td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写操作，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td></tr><tr><td>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</td><td></td><td></td></tr></tbody></table><h2 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h2><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器插入数据，并遍历这个容器<br>vector存放内置数据类型</p><h3 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h3><p><strong>容器</strong>：vector<br><strong>算法</strong>：for_each<br><strong>迭代器</strong>：vector<int>::iterator<br>示例：</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">void myPrint(int val)&#123;<br>      <br>      cout &lt;&lt; val &lt;&lt; endl;<br>&#125;<br>void test01()&#123;<br>    //创建了一个vector容器，数组<br>    vector&lt;int&gt; v;<br>    <br>    //向容器中插入数据<br>    v.push_back(10);<br>    v.push_back(20);<br>    v.push_back(30);<br>    v.push_back(40);<br>    <br>    //通过迭代器访问容器中的数据<br>    vetor&lt;int&gt;::iterator itBegin = v.begin(); //起始迭代器，指向容器中的第一个元素<br>    vetor&lt;int&gt;::iterator itEnd = v.end();// 结束迭代器，指向容器中最后一个元素的下一个位置<br>    <br>    //第一张遍历方式<br>    while(itBegin != itEnd)&#123;<br>          cout &lt;&lt; *itBegin &lt;&lt; endl;<br>          itBegin++;<br>          &#125;<br>          <br>    //第二种遍历方式<br>    for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;<br>            cout &lt;&lt; *itBegin &lt;&lt; endl;<br>    &#125;<br>    //第三种遍历方式<br>    for_each(v.begin(), v.end(), myPrint)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vector容器中存放自定义数据类型"><a href="#vector容器中存放自定义数据类型" class="headerlink" title="vector容器中存放自定义数据类型"></a>vector容器中存放自定义数据类型</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br><br>class Person&#123;<br>public:<br>Person(string name,int age)&#123;<br>        this-&gt;m_name=name;<br>        this-&gt;m_age=age;<br>    &#125;<br>    string m_name;<br>    int m_age;<br>&#125;;<br><br>void test01()&#123;<br>    vector&lt;Person&gt; v;<br>    Person p1(&quot;aaa&quot;,10);<br>    Person p2(&quot;bbb&quot;,20);<br>    Person p3(&quot;ccc&quot;,30);<br>    Person p4(&quot;ddd&quot;,40);<br>    Person p5(&quot;eee&quot;,50);<br>    v.push_back(p1);<br>    v.push_back(p2);<br>    v.push_back(p3);<br>    v.push_back(p4);<br>    v.push_back(p5);<br>    for(vector&lt;Person&gt;::iterator it=v.begin();it!=v.end();it++)&#123;<br>        //cout&lt;&lt;&quot;name：&quot;&lt;&lt;(*it).m_name&lt;&lt;&quot;  age：&quot;&lt;&lt;(*it).m_age&lt;&lt;endl;<br>        cout&lt;&lt;&quot;name：&quot;&lt;&lt;it-&gt;m_name&lt;&lt;&quot;  age：&quot;&lt;&lt;it-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br>void test02()&#123;<br>    vector&lt;*Person&gt; v;<br>    Person p1(&quot;aaa&quot;,10);<br>    Person p2(&quot;bbb&quot;,20);<br>    Person p3(&quot;ccc&quot;,30);<br>    Person p4(&quot;ddd&quot;,40);<br>    Person p5(&quot;eee&quot;,50);<br>    v.push_back(&amp;p1);<br>    v.push_back(&amp;p2);<br>    v.push_back(&amp;p3);<br>    v.push_back(&amp;p4);<br>    v.push_back(&amp;p5);<br>    for(vector&lt;Person*&gt;::iterator it=v.begin();it!=v.end();it++)&#123;<br>        cout&lt;&lt;&quot;name：&quot;&lt;&lt;(*it)-&gt;m_name&lt;&lt;&quot;  age：&quot;&lt;&lt;(*it)-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="vector容器嵌套容器"><a href="#vector容器嵌套容器" class="headerlink" title="vector容器嵌套容器"></a>vector容器嵌套容器</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">void test01()&#123;<br>      vector&lt;vector&lt;int&gt;&gt; v;<br>      <br>      vector&lt;int&gt;v1;<br>      vector&lt;int&gt;v2;<br>      vector&lt;int&gt;v3;<br>      vector&lt;int&gt;v4;<br>      <br>      for(int i = 0;i &lt; 4; i++)&#123;<br>      v1.push_back(i + 1);<br>      v2.push_back(i + 1);<br>      v3.push_back(i + 1);<br>      v4.push_back(i + 1);<br>      &#125;<br>      <br>       v.push_back(v1);<br>       v.push_back(v2);<br>       v.push_back(v3);<br>       v.push_back(v4);<br>       <br>       for(vector&lt;vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); i++)&#123;<br>           for(vector&lt;int&gt;::iterator vit=(*it).end(); vit++)&#123;<br>              cout &lt;&lt; *it ;<br>              &#125;<br>              cout &lt;&lt; endl;<br>              &#125;<br></code></pre></td></tr></table></figure><h1 id="STL-常用容器"><a href="#STL-常用容器" class="headerlink" title="STL-常用容器"></a>STL-常用容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><h3 id="string基本概念"><a href="#string基本概念" class="headerlink" title="string基本概念"></a>string基本概念</h3><p><strong>本质</strong>：</p><ul><li>string是C++风格的字符串，而string本质上是一个类<br>string和char*的区别：</li><li>char*是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char指针型容器<br><strong>特点</strong>：<br>string类内部封装了很多成员的方法<br>例如：查找find，拷贝copy，删除delete，替换replace，插入insert<br>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</li></ul><h3 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h3><p>构造函数原型：</p><ul><li>string(); &#x2F;&#x2F;创建一个空的字符串，例如：string str;</li><li>string(const char* s); &#x2F;&#x2F;使用字符串s初始化</li><li>string(const string&amp; str); &#x2F;&#x2F;使用一个string对象初始化另一个string对象</li><li>string(int n,char c); &#x2F;&#x2F;使用n个字符c初始化<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">void test01()&#123;<br>     string s1; //默认构造<br>  <br>     const char* str= &quot;hello world&quot;;<br>     string(str);<br>     cout &lt;&lt; s2 &lt;&lt;endl;<br>     <br>     string s3(s2);<br>     cout &lt;&lt; s3 &lt;&lt;endl;<br>      <br>      string s4(10,&#x27;a&#x27;);<br>      cout &lt;&lt; s4 &lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h3><p>功能描述：</p><ul><li>给string字符串进行赋值<br>赋值的函数原型：</li><li>string&amp; operator&#x3D;(const char* s); &#x2F;&#x2F;char*类型字符串赋值给当前的字符串</li><li>string&amp; operator&#x3D;(const string &amp;s); &#x2F;&#x2F;把字符串s赋给当前的字符串</li><li>string&amp; operator&#x3D;(char c); &#x2F;&#x2F;字符赋值给当前的字符串</li><li>string&amp; assign(const char *s); &#x2F;&#x2F;把字符串s赋给当前的字符串</li><li>string&amp; assign(const char *s,int n); &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串</li><li>string&amp; assign(const string &amp;s); &#x2F;&#x2F;把字符串s赋给当前字符串</li><li>string&amp; assign(int n,char c); &#x2F;&#x2F;把n个字符c赋给当前字符串<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">void test01()&#123;<br>    string str1;<br>    str1= &quot;hello world&quot;;<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br>    <br>    string str2;<br>    str2 = str1;<br>    <br>     string str3;<br>    str3 = &#x27;a&#x27;;<br>    <br>     string str4;<br>     str4.assgin(&quot;hello c++&quot;);<br>     <br>     string str5;<br>     str5.assign(&quot;hello c++&quot;,5);//打印hello<br>    <br>    string str6;<br>    str.asssign(str5);<br>    <br>    string str7;<br>    str.assign(5,&#x27;w&#x27;); //打印wwwww<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：string的赋值方式狠多，operator&#x3D;这种方式是比较实用的</p></blockquote></li></ul><h3 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h3><p>功能描述：</p><ul><li>实现在字符串末尾拼接字符串<br>函数原型：</li><li>string&amp; operator+&#x3D;(const char* str); &#x2F;&#x2F;重载+&#x3D;操作符</li><li>string&amp; operator+&#x3D;(const char c); &#x2F;&#x2F;重载+&#x3D;操作符</li><li>string&amp; operator+&#x3D;(const string&amp; str); &#x2F;&#x2F;重载+&#x3D;操作符</li><li>string&amp; append(const char *s); &#x2F;&#x2F;把字符s连接到当前字符串末尾</li><li>string&amp; append(const char *s,int n); &#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾</li><li>string&amp; append(const string &amp;s); &#x2F;&#x2F;同operator+&#x3D;(const string&amp; str);</li><li>string&amp; append(const string &amp;s,int pos,int n); &#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串末尾<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> void test01()&#123;<br>     string str1 = &quot;我&quot;;<br>     str1 += &quot;爱玩游戏&quot;;<br>     <br>     str1 += &quot;:&quot;;<br>     <br>     string str2 = &quot;lol dnf&quot;;<br>     <br>     str1 += str2;<br>     <br>     string str3 = &quot;i&quot;;<br>     str3.append(&quot;love&quot;);<br>     str3.append(&quot;game abcd&quot;,4); // 只复制前四个<br>     <br>     str3.append(str2);<br>     str3.append(str2,0,3); //0为开始位置，3为截取多少个字符     <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h3><p><strong>功能描述</strong>：</p><ul><li>查找：查找指定字符串是否存放</li><li>替换：在指定的位置替换字符串<br><strong>函数原型</strong>：</li><li>int find(const string&amp; str,int pos&#x3D;0) const; &#x2F;&#x2F;查找str第一次出现位置，从pos开始查找</li><li>int find(const char* s,int pos&#x3D;0) const; &#x2F;&#x2F;查找s第一次出现的位置，从pos开始查找</li><li>int find(const char* s,int pos,itn n) const; &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置</li><li>int find(const char c,int pos&#x3D;0) const; &#x2F;&#x2F;查找字符c第一次出现位置</li><li>int rfind(const string&amp; str,int pos&#x3D;npos) const; &#x2F;&#x2F;查找str最后一次出现位置，从pos开始查找</li><li>int rfind(const char* s,int pos&#x3D;npos) const; &#x2F;&#x2F;查找s最后一次出现位置，从pos开始查找</li><li>int rfind(const char* s,int pos,int n) const; &#x2F;&#x2F;从pos查找s的前n个字符最后一次位置</li><li>int rfind(const char c,int pos&#x3D;0) const; &#x2F;&#x2F;查找字符c最后一次出现位置</li><li>string&amp; replace(int pos,int n,const string string&amp; str); &#x2F;&#x2F;替换从pos开始n个字符为字符串str</li><li>string&amp; replace(int pos,int n,const char* s); &#x2F;&#x2F;替换从pos开始的n个字符为字符串<br><strong>find和rfind的区别</strong>：</li><li>find是从左往右查找</li><li>rfind是从右往左查找，但下标返回值是从左往右数的<br><strong>注意事项</strong>：<br>如果查找不到字符或者字符串，会返回值-1<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">//查找<br>void test01()&#123;<br>    string str1 = &quot;abcdefg&quot;;<br>    int pos = str1.find(&quot;de&quot;);<br>     if(pos == -1)<br>        cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;<br>     else<br>        cout &lt;&lt; pos &lt;&lt; ednl;<br>&#125;<br>void test02()&#123;<br>    string str1 = &quot;abcdefg&quot;;<br>    int pos = str1.rfind(&quot;de&quot;);<br>    if(pos == -1)<br>        cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;<br>     else<br>&#125;<br>// 替换<br>void test03()&#123;<br>    string str3 = &quot;abcdefg&quot;;<br>    str3.replace(1,3,&quot;1234&quot;);//从1号位置起3个字符替换成1234   <br></code></pre></td></tr></table></figure></li></ul><h3 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h3><p><strong>功能描述</strong>：</p><ul><li>字符串之间的比较<br><strong>比较方式</strong>：<br>字符串比较是按字符的ASCII码进行对比</li><li>*&#x3D;*返回 0</li><li>*&gt;*返回 1</li><li>*&lt;*返回 -1<br>函数原型：</li><li>int compare(const string &amp;s) const;&#x2F;&#x2F;与字符串s比较</li><li>int compare(const char *s) const; &#x2F;&#x2F;与字符串s比较<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>using namespace std;<br><br>void test01()&#123;<br>    string str1=&quot;hello&quot;;<br>    string str2=&quot;hello&quot;;<br>    if(str1.compare(str2)==0)&#123;<br>        cout&lt;&lt;&quot;str1=str2&quot;&lt;&lt;endl;<br>    &#125;else if(str1.compare(str2)&gt;0)&#123;<br>        cout&lt;&lt;&quot;str1&gt;str2&quot;&lt;&lt;endl;<br>    &#125;else if(str1.compare(str2)&lt;0)&#123;<br>        cout&lt;&lt;&quot;str1&lt;str2&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：主要是比较两个字符是否相等</p></blockquote></li></ul><h3 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h3><p>string中单个字符存取方式有两种：</p><ul><li>char&amp; operator[](int n); &#x2F;&#x2F;通过[]方式取字符</li><li>char&amp; at(int n); &#x2F;&#x2F;通过at方法获取字符<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"><br><br>void test01()&#123;<br>    string sr1=&quot;hello&quot;;<br>    //通过[]访问单个字符<br>    for(int i=0;i&lt;str1.size();i++)&#123;<br>        cout&lt;&lt;str1[i]&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    //通过at方式访问单个字符<br>    for(int i=0;i&lt;str1.size();i++)&#123;<br>        cout&lt;&lt;str1.at(i)&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    //修改单个字符<br>    str1[0]=&#x27;x&#x27;;<br>    cout&lt;&lt;&quot;str1= &quot;&lt;&lt;str1&lt;&lt;endl;<br>    str1.at(1)=&#x27;x&#x27;;<br>    cout&lt;&lt;&quot;str1= &quot;&lt;&lt;str1&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h3><p>功能描述：</p><ul><li>对string字符串进行插入和删除字符操作<br>函数原型：</li><li>string&amp; insert(int pos,const char* s); &#x2F;&#x2F;插入字符串</li><li>string&amp; insert(int pos,const string&amp; str); &#x2F;&#x2F;插入字符串</li><li>string&amp; insert(int pos,int n,char c); &#x2F;&#x2F;在指定位置插入n个字符c</li><li>string&amp; erase(int pos,int n&#x3D;npos); &#x2F;&#x2F;删除从pos开始的n个字符<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;string&gt;<br>using namespace std;<br><br><br>void test01()&#123;<br>    string str=&quot;hello&quot;;<br>    //插入<br>    str.insert(1,&quot;111&quot;);<br>    cout&lt;&lt;&quot;str= &quot;&lt;&lt;str&lt;&lt;endl;<br>    //删除<br>    str.erase(1,3);<br>    cout&lt;&lt;&quot;str= &quot;&lt;&lt;str&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h3><p><strong>功能描述</strong>：</p><ul><li>从字符串中获取想要的子串<br><strong>函数原型</strong>：</li><li>string substr(int pos&#x3D;0,int n&#x3D;npos) const; &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">void test02()&#123;<br>    string email.find(&quot;@&quot;);<br>    string userName = email.substr(1,3);<br>    cout &lt;&lt; subStr &lt;&lt; endl;<br>    &#125;<br>void test02()&#123;<br>    string email=&quot;zhangsan@sina.com&quot;;<br>    //从邮件地址中获取用户名信息<br>    int pos=email.find(&quot;@&quot;);<br>    string username=email.substr(0,pos);<br>    cout&lt;&lt;&quot;username= &quot;&lt;&lt;username&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="vector基本概念"><a href="#vector基本概念" class="headerlink" title="vector基本概念"></a>vector基本概念</h3><p><strong>功能</strong>：</p><ul><li>vector数据结构和数组非常相似，也成为单端数组<br><strong>vector与普通数组区别</strong>：</li><li>不同之处在于数组是静态空间，而vector可以动态扩展<br><strong>动态扩展</strong>：</li><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h3 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h3><p><strong>功能描述</strong>：</p><ul><li>创建vector容器<br><strong>函数原型</strong>：</li><li>vector<T> v; &#x2F;&#x2F;采用模块实现类实现，默认构造函数</li><li>vector(v.begin(),v.end()); &#x2F;&#x2F;将v[begin(),end())区间中的元素拷贝给本身</li><li>vector(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身</li><li>vector(const vector &amp;vec); &#x2F;&#x2F;拷贝构造函数<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">void print(vector&lt;int&gt;&amp;v)&#123;<br>    for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br> void test01()&#123;<br>    vector&lt;int&gt;v1;<br>    <br>    for(int i = 0; i &lt; 10; i++)&#123;<br>        v1.push_back(i);<br>        &#125;;<br>    print(v);  <br>    //通过区间方式进行构造  <br>    vector&lt;int&gt; v2(v1.begin(),v1.end());<br>    printfVector(v2);<br>    //n个方式够着<br>    vector&lt;int&gt; v2(10, 100);<br>    //拷贝构造<br>    vectorb=v4(v3);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h3><p><strong>功能描述</strong>：</p><ul><li>给vector容器进行赋值<br><strong>函数原型</strong>：</li><li>vector&amp; operator&#x3D;(const vector &amp;vec); &#x2F;&#x2F;重载等号操作符</li><li>assign(beg,end); &#x2F;&#x2F;将[beg,end)区间中的数据拷贝赋值给本身</li><li>assign(n,elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">void test01()&#123;<br>     vector&lt;int&gt; v1;<br>     for(int i = 0; i &lt; 10; i++)&#123;<br>         v1.push_back(i);<br>         &#125;<br>     //等号赋值<br>     vector&lt;int&gt;v2;<br>     v2 =v1;<br>     //assign赋值<br>     vector&lt;int&gt;v3;<br>     v3.assign(v1.beigin(),v1.end);<br>     //n个elem方式赋值<br>     vector&lt;int&gt;v4;<br>     v4.assign(10,100);<br>     &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h3><p><strong>功能描述</strong>：</p><ul><li>对vector容器的容量和大小操作<br><strong>函数原型</strong>：</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>capacity(); &#x2F;&#x2F;容器的容量</li><li>size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>resize(int num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值(0)填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li><li>resize(int num,elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">void test01()&#123;<br>     vector&lt;int&gt; v1;<br>     for(int i = 0; i &lt; 10; i++)&#123;<br>          v1.push_back(i);<br>     &#125;<br>     <br>     if(v1.empty())<br>         cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;<br>     else&#123;<br>          cout &lt;&lt; &quot;0&quot; &lt;&lt;endl;<br>          cout &lt;&lt; v1.capacity() &lt;&lt; endl;//容量<br>          cout &lt;&lt; v1.size() &lt;&lt; endl; // 大小<br>     &#125;<br>     <br>     <br>     v1.resize(15,100);//如果重新指定的闭原长，，默认用零填充<br>     <br>     v1.resize(5);//如果比它短，超过部分会被删除<br></code></pre></td></tr></table></figure></li></ul><h3 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h3><p><strong>功能描述</strong>：</p><ul><li>对vector容器进行插入、删除操作<br><strong>函数原型</strong>：</li><li>push_back(ele); &#x2F;&#x2F;尾部插入元素ele</li><li>pop_back(); &#x2F;&#x2F;删除最后一个元素</li><li>insert(const_iterator pos,ele); &#x2F;&#x2F;迭代器指向位置pos插入元素ele</li><li>insert(const_iterator pos,int count,ele); &#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</li><li>erase(const_iterator pos); &#x2F;&#x2F;删除迭代器指向的元素</li><li>erase(const_iterator start,const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素</li><li>clear(); &#x2F;&#x2F;删除容器中所有元素<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs [c++["> #include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br>void print(vector&lt;int&gt;&amp;v)&#123;<br>    for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><br>void test01()&#123;<br>    vector&lt;int&gt;v;<br>    for(int i=1;i&lt;=5;i++)&#123;<br>        v.push_back(i*10);<br>    &#125;<br>    print(v);<br>    v.pop_back();  //尾删<br>    print(v);<br>    //插入<br>    v.insert(v.begin(),100);  //第一个参数为迭代器<br>    print(v);<br>    v.insert(v.begin(),2,1000);<br>    print(v);<br>    //删除<br>    v.erase(v.begin());  //参数也为迭代器<br>    print(v);<br>    //清空<br>    //v.erase(v.begin(),v.end());  //从头到尾删除<br>    v.clear();  //也是清空操作<br>    print(v);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取"></a>vector数据存取</h3><p><strong>功能描述</strong>：</p><ul><li>对vector中的数据的存取操作<br><strong>函数原型</strong>：</li><li>at(int idx); &#x2F;&#x2F;返回索引idx所指的数据</li><li>operator[]; &#x2F;&#x2F;返回索引idx所指的数据</li><li>front(); &#x2F;&#x2F;返回容器中第一个数据元素</li><li>back(); &#x2F;&#x2F;返回容器中最后一个数据元素<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br><br>void test01()&#123;<br>    vector&lt;int&gt;v;<br>    for(int i=0;i&lt;10;i++)&#123;<br>        v.push_back(i);<br>    &#125;<br>    //利用[]方式访问数组中元素<br>    for(int i=0;i&lt;v.size();i++)&#123;<br>        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    //利用at方式访问元素<br>    for(int i=0;i&lt;v.size();i++)&#123;<br>cout&lt;&lt;v.at(i)&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <br>    cout&lt;&lt;&quot;第一个元素为：&quot;&lt;&lt;v.front()&lt;&lt;endl;<br>    cout&lt;&lt;&quot;最后一个元素为：&quot;&lt;&lt;v.back()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器"></a>vector互换容器</h3><p><strong>能描述</strong>：</p><ul><li>实现两个容器内元素进行互换<br><strong>函数原型</strong>：</li><li>swap(vec); &#x2F;&#x2F;将vec与本身大的元素互换<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br>void print(vector&lt;int&gt;&amp;v)&#123;<br>    for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br>void test01()&#123;<br>    vector&lt;int&gt;v;<br>    for(int i=0;i&lt;10;i++)&#123;<br>        v.push_back(i);<br>    &#125;<br>    print(v);<br>    vector&lt;int&gt;v1;<br>    for(int i=10;i&gt;0;i--)&#123;<br>v1.push_back(i);<br>    &#125;<br>    print(v1);<br>    cout&lt;&lt;&quot;交换后：&quot;&lt;&lt;endl;<br>    v1.swap(v);<br>    print(v);<br>    print(v1);<br>&#125;<br><br>//实际用途<br>//巧用swap可以收缩内存空间<br>void test02()&#123;<br>    vector&lt;int&gt;v;<br>    for(int i=0;i&lt;10000;i++)&#123;<br>        v.push_back(i);<br>        <br>    &#125;<br>    cout&lt;&lt;&quot;v的容量：&quot;&lt;&lt;v.capacity()&lt;&lt;endl;<br>    cout&lt;&lt;&quot;v的大小为：&quot;&lt;&lt;v.size()&lt;&lt;endl;<br>    v.resize(3);<br>    cout&lt;&lt;&quot;v的容量：&quot;&lt;&lt;v.capacity()&lt;&lt;endl;   //容量不变<br>    cout&lt;&lt;&quot;v的大小为：&quot;&lt;&lt;v.size()&lt;&lt;endl;<br>    //巧用swap收缩内存<br>    vector&lt;int&gt;(v).swap(v);<br>    //vector&lt;int&gt;(v)  匿名对象，当前行执行完，就将匿名对象回收<br>    //.swap(v);   容量交换<br>    //用swap会根据交换的容器大小来初始化容器的容量<br>    cout&lt;&lt;&quot;v的容量：&quot;&lt;&lt;v.capacity()&lt;&lt;endl;   //容量收缩了<br>    cout&lt;&lt;&quot;v的大小为：&quot;&lt;&lt;v.size()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a>vector预留空间</h3><p><strong>功能描述</strong>：</p><ul><li>减少vector在动态扩展容量时的扩展次数<br><strong>函数原型</strong>：</li><li>reserve(int len); &#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br>void test01()&#123;<br>    vector&lt;int&gt;v;<br>    //利用reserve预留空间，减少开辟次数<br>    v.reserve(100000);<br>    int num=0;//统计容器开辟次数<br>    int *p=NULL;<br>    for(int i=0;i&lt;100000;i++)&#123;<br>v.push_back(i);<br>        if(p!=&amp;v[0])&#123;<br>            p=&amp;v[0];<br>            num++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;&quot;num= &quot;&lt;&lt;num&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>功能</strong>：</p><ul><li>双端数组，可以对头端进行插入删除操作<br><strong>deque与vector区别</strong>：</li><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度会比vector快</li><li>vector访问元素时速度会比deque快，这和两者内部实现有关<br><strong>deque内部工作原理</strong>：<br>deque内部有一个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据<br>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</li><li>deque容器的迭代器也是支持随机访问的</li></ul><h3 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h3><p>功能描述：</p><ul><li>deque容器构造<br>函数原型：</li><li>deque<T> deqT; &#x2F;&#x2F;默认构造形式</li><li>deque(beg,end); &#x2F;&#x2F;构造函数将[beg,end)区间中的元素拷贝给本身</li><li>deque(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身</li><li>deque(const deque &amp;deq); &#x2F;&#x2F;拷贝构造函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [c++]bush">void print(const deque&lt;int&gt;&amp;d)&#123;<br>    for(deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++)&#123;<br>        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;<br>        &#125;<br>    cout &lt;&lt; endl;<br>    &#125;<br>void test01()&#123;<br>    deque&lt;int&gt;d1;<br>    for(int i = 0; i &lt; 20; i++)&#123;<br>        d1.push_back(i);<br>        &#125;<br>    print(d1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h3><p>功能描述：</p><ul><li>给deque容器进行赋值<br>函数原型：</li><li>deque&amp; operator&#x3D;(const deque &amp;deq); &#x2F;&#x2F;重载等号操作符</li><li>assign(beg,end); &#x2F;&#x2F;将[beg,end)区间中的数据拷贝赋值给本身</li><li>assign(n,elem); &#x2F;&#x2F;将n个elem赋值给本身<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;deque&gt;<br>using namespace std;<br><br>void print(const deque&lt;int&gt; &amp;d)&#123;  //内部的*it不能更改了<br>    for(deque&lt;int&gt;:: const_iterator it=d.begin();it!=d.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br>void test01()&#123;<br>    deque&lt;int&gt;d1;<br>    for(int i=0;i&lt;10;i++)&#123;<br>        d1.push_back(i);<br>    &#125;<br>    print(d1);<br>    //第一种赋值<br>    deque&lt;int&gt;d2;<br>    d2=d1;<br>    print(d2);<br>    //第二种<br>    deque&lt;int&gt;d3;<br>    d3.assign(d1.begin(),d1.end());<br>    print(d3);<br>    //第三种<br>    deque&lt;int&gt;d4;<br>    d4.assign(10,100);<br>    print(d4);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h3><p>功能描述：</p><ul><li>对deque容器的大小进行操作<br>函数原型：</li><li>deque.empty(); &#x2F;&#x2F;判断容器是否为空</li><li>deque.size(); &#x2F;&#x2F;返回容器中的元素个数</li><li>deque.resize(num); &#x2F;&#x2F;重新指定容器的长度num，若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li><li>deque.resize(num,elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;deque&gt;<br>using namespace std;<br><br><br>void print(const deque&lt;int&gt;&amp;d)&#123;<br>    for(deque&lt;int&gt;::const_iterator it=d.begin();it!=d.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br>void test01()&#123;<br>    deque&lt;int&gt;d1;<br>    for(int i=0;i&lt;10;i++)&#123;<br>        d1.push_back(i);<br>    &#125;<br>    print(d1);<br>    if(d1.empty())&#123;<br>        cout&lt;&lt;&quot;d1为空&quot;&lt;&lt;endl;<br>    &#125;else&#123;<br>        cout&lt;&lt;&quot;d1不为空&quot;&lt;&lt;endl;<br>        cout&lt;&lt;&quot;d1的大小为：&quot;&lt;&lt;d1.size()&lt;&lt;endl;<br>        //deque容器没有容量概念<br>    &#125;<br>    //重新指定大小<br>    d1.resize(15);<br>    print(d1);<br>    d1.resize(15,1);<br>    print(d1);<br>    d1.resize(5);<br>    print(d1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="deque插入和删除"><a href="#deque插入和删除" class="headerlink" title="deque插入和删除"></a>deque插入和删除</h3><p>功能描述：</p><ul><li>向deque容器中插入和删除数据<br>函数原型：<br>两端插入删除操作：</li><li>push_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据</li><li>push_front(elem); &#x2F;&#x2F;在容器的头部插入一个数据</li><li>pop_back(); &#x2F;&#x2F;删除容器最后一个数据</li><li>pop_front(); &#x2F;&#x2F;删除容器第一个数据<br>指定位置操作：</li><li>insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值</li><li>insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值</li><li>clear(); &#x2F;&#x2F;清空容器的所有数据</li><li>erase(beg,end); &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置</li><li>erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> void test01()&#123;<br>      deque&lt;int&gt;d1;<br>      d1.push_black(10);<br>      d1.push_black(20)；<br>      <br>      d1.push_front(100);<br>      d1.push_front(200);<br>      <br>      d1.pop_front();<br>      &#125;<br> <br> &#125;<br><br>void test02()&#123;<br>    deque&lt;int&gt;d1;<br>    d1.push_back(10);<br>    d1.push_back(20);<br>    d1.push_front(100);<br>    d1.push_front(200);<br>    print(d1);<br>    //insert插入<br>    d1.insert(d1.begin(),1000);<br>    print(d1);<br>    d1.insert(d1.begin(),2,10000);<br>    print(d1);<br>    //按照区间进行插入<br>    deque&lt;int&gt;d2;<br>    d2.push_back(1);<br>    d2.push_back(2);<br>    d2.push_back(3);<br>    d1.insert(d1.begin(),d2.begin(),d2.end());<br>    print(d1);<br>&#125;<br><br>void test03()&#123;<br>    deque&lt;int&gt;d1;<br>    d1.push_back(10);<br>    d1.push_back(20);<br>    d1.push_front(100);<br>    d1.push_front(200);<br>    //删除<br>    deque&lt;int&gt;::iterator it=d1.begin();<br>    it++;<br>    d1.erase(it);<br>    print(d1);<br>    //按照区间方式删除<br>    d1.erase(d1.begin(),d1.end());<br>    //清空<br>    d1.clear();<br>    print(d1);<br></code></pre></td></tr></table></figure><blockquote><p>总结：<br>插入和删除提供的位置是迭代器</p></blockquote></li></ul><h3 id="eque数据存取"><a href="#eque数据存取" class="headerlink" title="eque数据存取"></a>eque数据存取</h3><p><strong>功能描述</strong>：</p><ul><li>对deque中的数据的存取操作<br><strong>函数原型</strong>：</li><li>at(int idx); &#x2F;&#x2F;返回索引idx所指数据</li><li>operator[]; &#x2F;&#x2F;返回索引idx所指数据</li><li>front(); &#x2F;&#x2F;返回容器中第一个数据元素</li><li>back(); &#x2F;&#x2F;返回容器中最后一个数据元素<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;deque&gt;<br>using namespace std;<br><br>void test01()&#123;<br>    deque&lt;int&gt;d;<br>    d.push_back(10);<br>    d.push_back(20);<br>    d.push_back(30);<br>    d.push_front(100);<br>    d.push_front(200);<br>    d.push_front(300);<br>    //通过[]方式访问元素<br>    for(int i=0;i&lt;d.size();i++)&#123;<br>        cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <br>    //通过at方式访问元素<br>    for(int i=0;i&lt;d.size();i++)&#123;<br>        cout&lt;&lt;d.at(i)&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;&quot;第一个元素为：&quot;&lt;&lt;d.front()&lt;&lt;endl;<br>    cout&lt;&lt;&quot;最后一个元素为：&quot;&lt;&lt;d.back()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="deque排序"><a href="#deque排序" class="headerlink" title="deque排序"></a>deque排序</h3><p><strong>功能描述</strong>：</p><ul><li>利用算法实现deque容器进行排序<br><strong>算法</strong>：</li><li>sort(iterator beg,iterator end) &#x2F;&#x2F;对beg和end区间内元素进行排序<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;deque&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>void print(const deque&lt;int&gt;&amp;d)&#123;<br>    for(deque&lt;int&gt;::const_iterator it=d.begin();it!=d.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br>void test01()&#123;<br>    deque&lt;int&gt;d;<br>    d.push_back(10);<br>    d.push_back(20);<br>    d.push_back(30);<br>    d.push_front(100);<br>    d.push_front(200);<br>    d.push_front(300);<br>    //排序<br>    //对于支持随机访问的迭代器的容器，都可以利用sort算法直接进行排序<br>    sort(d.begin(),a.end());<br>    cout&lt;&lt;&quot;排序后结果：&quot;&lt;&lt;endl;<br>    print(d);  //默认排序规则从小到大升序<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="stack-栈-容器"><a href="#stack-栈-容器" class="headerlink" title="stack(栈)容器"></a>stack(栈)容器</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><p>概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口<br>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为<br>栈中进入数据称为 — 入栈push<br>栈中弹出数据称为 — 出栈pop</p><h3 id="stack常用接口"><a href="#stack常用接口" class="headerlink" title="stack常用接口"></a>stack常用接口</h3><p>功能描述：</p><ul><li>栈容器常用的对外接口<br><strong>构造函数</strong>：</li><li>stack<T> stk; &#x2F;&#x2F;stack采用模板类实现，stack对象的默认构造形式</li><li>stack(const stack &amp;stk); &#x2F;&#x2F;拷贝构造函数<br><strong>赋值操作</strong>：</li><li>stack&amp; operator&#x3D;(const stack &amp;stk); &#x2F;&#x2F;重载等号操作符<br><strong>数据存取</strong>：</li><li>push(elem); &#x2F;&#x2F;向栈顶添加元素</li><li>pop(); &#x2F;&#x2F;从栈顶移除第一个元素</li><li>top(); &#x2F;&#x2F;返回栈顶元素<br><strong>大小操作</strong>：</li><li>empty(); &#x2F;&#x2F;判断堆栈是否为空</li><li>size(); &#x2F;&#x2F;返回栈的大小<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;stack&gt;<br>using namespace std;<br><br>void test01()&#123;<br>    stack&lt;int&gt;s;<br>    //入栈<br>    s.push(10);<br>    s.push(20);<br>    s.push(30);<br>    s.push(40);<br>    cout&lt;&lt;&quot;栈的大小：&quot;&lt;&lt;s.size()&lt;&lt;endl;<br>    //只要栈不为空，查看栈顶，并且执行出栈操作<br>    while(!s.empty())&#123;<br>        cout&lt;&lt;&quot;栈顶元素为：&quot;&lt;&lt;s.top()&lt;&lt;endl;<br>        //出栈<br>        s.pop();<br>    &#125;<br>    cout&lt;&lt;&quot;栈的大小为：&quot;&lt;&lt;s.size()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="queue-队列-容器"><a href="#queue-队列-容器" class="headerlink" title="queue(队列)容器"></a>queue(队列)容器</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>概念</strong>：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口<br>队列容器允许从一端新增元素，从另一端移除元素<br>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为<br>队列中进数据称为 — 入队push<br>队列中出数据称为 — 出队pop</p><h3 id="queue常用接口"><a href="#queue常用接口" class="headerlink" title="queue常用接口"></a>queue常用接口</h3><p><strong>功能描述</strong>：</p><ul><li>队列容器常用的对外接口<br><strong>构造函数</strong>：</li><li>queue<T> que; &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</li><li>queue(const queue &amp;que); &#x2F;&#x2F;拷贝构造函数<br><strong>赋值操作</strong>：</li><li>queue&amp; operator&#x3D;(const queue &amp;que); &#x2F;&#x2F;重载等号操作符<br><strong>数据存取</strong>：</li><li>push(elem); &#x2F;&#x2F;往队尾添加元素</li><li>pop(); &#x2F;&#x2F;从队头移除第一个元素</li><li>back(); &#x2F;&#x2F;返回最后一个元素</li><li>front(); &#x2F;&#x2F;返回第一个元素<br><strong>大小操作</strong>：</li><li>empty(); &#x2F;&#x2F;判断堆栈是否为空</li><li>size(); &#x2F;&#x2F;返回栈的大小<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;queue&gt;<br>#include &lt;string&gt;<br>using namespace std;<br><br>class Person&#123;<br>public:<br>    Person(string name,int age)&#123;<br>        this-&gt;m_name=name;<br>        this-&gt;m_age=age;<br>    &#125;<br>    string m_name;<br>    int m_age;<br>&#125;;<br><br>void test01()&#123;<br>    queue&lt;Person&gt;q;<br>    Person p1(&quot;p1&quot;,20);<br>    Person p2(&quot;p2&quot;,30);<br>    Person p3(&quot;p3&quot;,40);<br>    Person p4(&quot;p4&quot;,50);<br>    //入队<br>    q.push(p1);<br>    q.push(p2);<br>    q.push(p3);<br>    q.push(p4);<br>    cout&lt;&lt;&quot;队列大小：&quot;&lt;&lt;q.size()&lt;&lt;endl;<br>    //判断只要队列不为空，查看队头，查看队尾，出队<br>    while(!q.empty())&#123;<br>        //查看队头<br>        cout&lt;&lt;&quot;队头元素：&quot;&lt;&lt;q.front().m_name&lt;&lt;&quot; &quot;&lt;&lt;q.front().m_age&lt;&lt;endl;<br>        //查看队尾<br>        cout&lt;&lt;&quot;队尾元素：&quot;&lt;&lt;q.back().m_name&lt;&lt;&quot; &quot;&lt;&lt;q.back().m_age&lt;&lt;endl;<br>        //出队<br>        q.pop();<br>    &#125;<br>    cout&lt;&lt;&quot;队列大小：&quot;&lt;&lt;q.size()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="priority-queue-优先队列-容器"><a href="#priority-queue-优先队列-容器" class="headerlink" title="priority_queue(优先队列)容器"></a>priority_queue(优先队列)容器</h2><p><strong>优先队列定义：</strong></p><ul><li>使用优先队列,**定义参数&lt;数据类型，容器类型，比较方法&gt;**，默认是大根堆 例子： priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt;q;<br><strong>数据存取操作：</strong></li><li>push(elem); &#x2F;&#x2F;添加元素</li><li>pop(); &#x2F;&#x2F;从队列中删除最高优先级的元素</li><li>top(); &#x2F;&#x2F;获取队列中最高优先级的元素<br><strong>大小操作</strong>：</li><li>empty(); &#x2F;&#x2F;判断是否为空</li><li>size(); &#x2F;&#x2F;获取队列大小</li></ul><h2 id="list-链表-容器"><a href="#list-链表-容器" class="headerlink" title="list(链表)容器"></a>list(链表)容器</h2><p><strong>功能</strong>：将数据进行链式存储<br><strong>链表(list)<strong>：是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的<br><strong>链表的组成</strong>：链表由一系列结点组成<br><strong>结点的组成</strong>：一个是存储数据元素的</strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong><br>STL的链表是一个<strong>双向循环链表</strong><br>由于链表的存储方式不是连续的内存内存空间，因此链表list中的迭代器只支持前移和后移属于双向迭代器<br><strong>优点：</strong></p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素<br><strong>缺点：</strong></li><li>链表灵活，但是空间(指针域)和时间(遍历)额外耗费较大<br>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的<blockquote><p>总结：STL中的List和vector是两个最常被使用的容器，各有优缺点</p></blockquote></li></ul><h3 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h3><p><strong>功能描述：</strong></p><ul><li>创建list容器<br><strong>函数原型：</strong></li><li>list<T> lst; &#x2F;&#x2F;list采用模板类实现，对象的默认构造形式</li><li>list(beg,end); &#x2F;&#x2F;构造函数将[beg,end)区间中的元素拷贝给本身</li><li>list(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身</li><li>list(const list &amp;lst); &#x2F;&#x2F;拷贝构造函数<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;list&gt;<br>using namespace std;<br><br>void print(const list&lt;int&gt;&amp;l)&#123;<br>    for(list&lt;int&gt;::const_iterator it=l.begin();it!=l.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br>void test01()&#123;<br>    list&lt;int&gt;l;<br>    //添加数据<br>    l.push_back(10);<br>    l.push_back(20);<br>    l.push_back(30);<br>    l.push_back(40);<br>    //遍历容器<br>    print(l);<br>    //区间方式构造<br>    list&lt;int&gt;l1(l.begin(),l.end());<br>    print(l1);<br>    //拷贝构造<br>    list&lt;int&gt;l2(l1);<br>    print(l2);<br>    //n个elem<br>    list&lt;int&gt;l3(10,1000);<br>    print(l3);<br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h3 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h3><p><strong>功能描述</strong>：</p><ul><li>给list容器进行赋值，以及交换list容器<br><strong>函数原型：</strong></li><li>assign(beg,end); &#x2F;&#x2F;将[beg,end)区间中的数据拷贝赋值给本身</li><li>assign(n,elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身</li><li>list&amp; operator&#x3D;(const list &amp;lst); &#x2F;&#x2F;重载等号操作符</li><li>swap(lst); &#x2F;&#x2F;将lst与本身的元素互换<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;list&gt;<br>using namespace std;<br><br>void print(const list&lt;int&gt;&amp;l)&#123;<br>    for(list&lt;int&gt;::const_iterator it=l.begin();it!=l.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br>void test01()&#123;<br>    list&lt;int&gt;l;<br>    l.push_back(10);<br>    l.push_back(20);<br>    l.push_back(30);<br>    l.push_back(40);<br>    print(l);<br>    list&lt;int&gt;l1;<br>    l1=l;  //operator= 赋值<br>    print(l1);<br>    list&lt;int&gt;l2;<br>    l2.assign(l1.begin(),l1.end());<br>    print(l2);<br>    list&lt;int&gt;l3;<br>    l3.assign(10,100);<br>    print(l3);<br>&#125;<br><br>//交换<br>void test02()&#123;<br>    list&lt;int&gt;l;<br>    l.push_back(10);<br>    l.push_back(20);<br>    l.push_back(30);<br>    l.push_back(40);<br>    list&lt;int&gt;l1;<br>    l1.assign(10,100);<br>    cout&lt;&lt;&quot;交换前：&quot;&lt;&lt;endl;<br>    print(l);<br>    print(l1);<br>    cout&lt;&lt;&quot;交换后：&quot;&lt;&lt;endl;<br>    l.swap(l1);<br>    print(l);<br>    print(l1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="list反转和排序"><a href="#list反转和排序" class="headerlink" title="list反转和排序"></a>list反转和排序</h3><p><strong>功能描述</strong>：</p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序<br><strong>函数原型</strong>：</li><li>reverse(); &#x2F;&#x2F;反转链表</li><li>sort(); &#x2F;&#x2F;链表排序<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;list&gt;<br>using namespace std;<br><br>void print(const list&lt;int&gt;l)&#123;<br>    for(list&lt;int&gt;::const_iterator it=l.begin();it!=l.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><br>void test01()&#123;<br>    //反转<br>    list&lt;int&gt;l;<br>    l.push_back(10);<br>    l.push_back(20);<br>    l.push_back(30);<br>    l.push_back(40);<br>    l.push_back(50);<br>    print(l);<br>    cout&lt;&lt;&quot;反转后：&quot;&lt;&lt;endl;<br>    l.reverse();<br>    print(l);<br>&#125;<br><br>bool mycompare(int v1,int v2)&#123;<br>    //降序，就让第一个数大于第二个数<br>    return v1&gt;v2;<br>&#125;<br><br>void test02()&#123;<br>    list&lt;int&gt;l;<br>    l.push_back(60);<br>    l.push_back(10);<br>    l.push_back(5);<br>    l.push_back(40);<br>    l.push_back(50);<br>    cout&lt;&lt;&quot;排序前：&quot;&lt;&lt;endl;<br>    print(l);<br>    cout&lt;&lt;&quot;排序后：&quot;&lt;&lt;endl;<br>    //所有不支持随机访问迭代器的容器，不可以用标准算法<br>    //不支持随机访问迭代器的容器,内部会提供对应一些算法<br>    l.sort();//默认为升序<br>    print(l);<br>    //降序<br>    l.sort(mycompare);<br>    print(l);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="set-multiset-集合-容器"><a href="#set-multiset-集合-容器" class="headerlink" title="set&#x2F;multiset(集合)容器"></a>set&#x2F;multiset(集合)容器</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>简介:</strong></p><ul><li>所有元素都会插入时自动被排序<br><strong>本质：</strong></li><li>set&#x2F;multiset属于关联式容器，底层结构是用二叉树实现<br><strong>set和multiset区别：</strong></li><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h3 id="set构造和赋值"><a href="#set构造和赋值" class="headerlink" title="set构造和赋值"></a>set构造和赋值</h3><p><strong>功能描述</strong>：</p><ul><li>创建set容器以及赋值<br><strong>构造：</strong></li><li>set<T>st; &#x2F;&#x2F;默认构造函数</li><li>set(const set &amp;st); &#x2F;&#x2F;拷贝构造函数<br><strong>赋值：</strong></li><li>set&amp; operator&#x3D;(const set &amp;st); &#x2F;&#x2F;重载等号操作符<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br>void print(const set&lt;int&gt;s)&#123;<br>    for(set&lt;int&gt;::const_iterator it=s.begin();it!=s.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125; <br><br>void test01()&#123;<br>    set&lt;int&gt;s1;<br>    //插入数据只有insert方式<br>    s1.insert(10);<br>    s1.insert(30);<br>    s1.insert(40);<br>    s1.insert(20);<br>    s1.insert(30);<br>    //set容器特点：所有元素插入时候自动排序<br>    //set容器不允许插入重复值<br>    print(s1);<br>    //拷贝构造<br>    set&lt;int&gt;s2(s1);<br>    print(s2);<br>    //赋值<br>    set&lt;int&gt;s3;<br>    s3=s2;<br>    print(s3);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="set大小和交换"><a href="#set大小和交换" class="headerlink" title="set大小和交换"></a>set大小和交换</h3><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器<br><strong>函数原型：</strong></li><li>size(); &#x2F;&#x2F;返回容器中元素的数目</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>swap(st); &#x2F;&#x2F;交换两个集合容器<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br>void print(const set&lt;int&gt;s)&#123;<br>    for(set&lt;int&gt;::const_iterator it=s.begin();it!=s.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br>//大小<br>void test01()&#123;<br>set&lt;int&gt;s1;<br>    s1.insert(10);<br>    s1.insert(20);<br>    s1.insert(30);<br>    s1.insert(40);<br>    print(s1);<br>    <br>    if(s1.empty())&#123;<br>        cout&lt;&lt;&quot;s1为空&quot;&lt;&lt;endl;<br>    &#125;else&#123;<br>        cout&lt;&lt;&quot;s1不为空&quot;&lt;&lt;endl;<br>        cout&lt;&lt;&quot;s1的大小为：&quot;&lt;&lt;s1.size()&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br>void test02()&#123;<br>    set&lt;int&gt;s1;<br>    s1.insert(10);<br>    s1.insert(20);<br>    s1.insert(30);<br>    s1.insert(40);<br>    set&lt;int&gt;s2;<br>    s2.insert(100);<br>    s2.insert(200);<br>    s2.insert(300);<br>    s2.insert(400);<br>    cout&lt;&lt;&quot;交换前：&quot;&lt;&lt;endl;<br>    print(s1);<br>    print(s2);<br>    cout&lt;&lt;&quot;交换后：&quot;&lt;&lt;endl;<br>    s1.swap(s2);<br>    print(s1);<br>    print(s2);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="set插入和删除"><a href="#set插入和删除" class="headerlink" title="set插入和删除"></a>set插入和删除</h3><p><strong>功能描述</strong>：</p><ul><li>set容器进行插入数据和删除数据<br><strong>函数原型：</strong></li><li>insert(elem); &#x2F;&#x2F;在容器中插入元素</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器</li><li>erase(beg,end); &#x2F;&#x2F;删除区间[beg,end)的所有元素，返回下一个元素的迭代器</li><li>erase(elem); &#x2F;&#x2F;删除容器中值为elem的元素<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br>void print(const set&lt;int&gt;s)&#123;<br>    for(set&lt;int&gt;::const_iterator it=s.begin();it!=s.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br>void test01()&#123;<br>    set&lt;int&gt;s1;<br>    s1.insert(10);<br>    s1.insert(30);<br>    s1.insert(20);<br>    s1.insert(40);<br>    print(s1);<br>    <br>    //删除<br>    s1.erase(s1.begin());<br>    print(s1);<br>    //删除重载版本<br>    s1.erase(30);<br>    print(s1);<br>    <br>    //清空<br>    //s1.erase(s1.begin(),s1.end());<br>    s1.clear();<br>    print(s1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>set查找和统计<br><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据<br><strong>函数原型：</strong></li><li>find(key); &#x2F;&#x2F;查找key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li>count(key); &#x2F;&#x2F;统计key的元素个数<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br>void test01()&#123;<br>    set&lt;int&gt;s1;<br>    s1.insert(10);<br>    s1.insert(20);<br>    s1.insert(30);<br>    s1.insert(40);<br>    //查找<br>    set&lt;int&gt;::iterator pos=s1.find(30);<br>    if(pos!=s1.end())&#123;<br>        cout&lt;&lt;&quot;找到元素：&quot;&lt;&lt;*pos&lt;&lt;endl;<br>    &#125;else&#123;<br>        cout&lt;&lt;&quot;未找到元素&quot;&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br>void test02()&#123;<br>set&lt;int&gt;s1;<br>    s1.insert(10);<br>    s1.insert(20);<br>    s1.insert(30);<br>    s1.insert(40);<br>    s1.insert(30);<br>    s1.insert(30);<br>    //统计,对于set而言，统计结果要么是0，要么是1<br>    int num=s1.count(30);<br>    cout&lt;&lt;&quot;num= &quot;&lt;&lt;num&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="set和multiset区别"><a href="#set和multiset区别" class="headerlink" title="set和multiset区别"></a>set和multiset区别</h3><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br><br>void test01()&#123;<br>    set&lt;int&gt;s;<br>    pair&lt;set&lt;int&gt;::iterator,bool&gt; ret=s.insert(10);<br>    if(ret.second)&#123;<br>        cout&lt;&lt;&quot;第一次插入成功&quot;&lt;&lt;endl;<br>    &#125;else&#123;<br>        cout&lt;&lt;&quot;第一次插入失败&quot;&lt;&lt;endl;<br>    &#125;<br>    ret=s.insert(10);<br>    if(ret.second)&#123;<br>        cout&lt;&lt;&quot;第二次插入成功&quot;&lt;&lt;endl;<br>    &#125;else&#123;<br>        cout&lt;&lt;&quot;第二次插入失败&quot;&lt;&lt;endl;<br>    &#125;<br>    <br>    multiset&lt;int&gt;m;<br>    //允许插入重复的值<br>    m.insert(10);<br>    m.insert(10);<br>    for(multiset&lt;int&gt;::iterator it=m.begin();it!=m.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结：</strong></p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul></blockquote></li></ul><h3 id="pair队组创建"><a href="#pair队组创建" class="headerlink" title="pair队组创建"></a>pair队组创建</h3><p>功能描述：</p><ul><li>成对出现的数据，利用队组可以返回两个数据<br>两种创建方式：</li><li>pair&lt;type,type&gt; p(value1,value2);</li><li>pair&lt;type,type&gt; p&#x3D;make_pair(value1,value2);<br>注意事项：</li><li>使用时不需要包含头文件<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;string&gt;<br>using namespace std;<br><br><br>void test01()&#123;<br>    //第一种方式<br>    pair&lt;string,int&gt;p(&quot;Tom&quot;,20);<br>    cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;p.first&lt;&lt;&quot;年龄：&quot;&lt;&lt;p.second&lt;&lt;endl;<br>    <br>    //第二种方式<br>    pair&lt;string,int&gt;p2=make_pair(&quot;jerry&quot;,30);<br>    cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;p2.first&lt;&lt;&quot;年龄：&quot;&lt;&lt;p2.second&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h3><p>学习目标：</p><ul><li>set容器默认排序规则是从小到大，掌握如何改变排序规则<br>主要技术点：</li><li>利用仿函数，可以改变排序规则<br>示例一 set存放内置数据类型<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br>class mycompare&#123;<br>public:<br>    bool operator()(int v1,int v2)&#123;<br>        return v1&gt;v2;<br>    &#125;<br>&#125;;<br><br><br>void test01()&#123;<br>    set&lt;int&gt;s1;<br>    s1.insert(10);<br>    s1.insert(20);<br>    s1.insert(30);<br>    s1.insert(40);<br>    s1.insert(50);<br>    for(set&lt;int&gt;::iterator it=s1.begin();it!=s1.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    //指定排序规则为从小到大<br>    set&lt;int,mycompare&gt;s2;<br>    <br>    s2.insert(10);<br>    s2.insert(20);<br>    s2.insert(30);<br>    s2.insert(40);<br>    s2.insert(50);<br>    for(set&lt;int,mycompare&gt;::iterator it=s2.begin();it!=s2.end();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>示例2 set存放自定义数据类型<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br>class Person&#123;<br>public:<br>    Person(string name,int age)&#123;<br>        this-&gt;m_name=name;<br>        this-&gt;m_age=age;<br>    &#125;<br>    string m_name;<br>    int m_age;<br>&#125;;<br><br>class mycompare&#123;<br>public:<br>    bool operator()(const Person&amp;p1,const Person&amp;p2)&#123;<br>        return p1.m_age&gt;p2.m_age;<br>    &#125;<br>&#125;;<br><br>void test01()&#123;<br>    //自定义数据类型都会指定排序规则<br>    set&lt;Person,mycompare&gt;s;<br>    Person p1(&quot;张1&quot;,24);<br>    Person p1(&quot;张2&quot;,28);<br>    Person p1(&quot;张3&quot;,25);<br>    Person p1(&quot;张4&quot;,21);<br>    s.insert(p1);<br>    s.insert(p2);<br>    s.insert(p3);<br>    s.insert(p4);<br>    for(set&lt;Person&gt;::iterator it=s.begin();it!=s.end();it++)&#123;<br>        cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;it-&gt;m_name&lt;&lt;&quot;年龄：&quot;&lt;&lt;it-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map&#x2F;multimap容器"></a>map&#x2F;multimap容器</h2><h3 id="map基本概念"><a href="#map基本概念" class="headerlink" title="map基本概念"></a>map基本概念</h3><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair(队组)</li><li>pair中第一个元素为key(键值)，起到索引作用，第二个元素为value(实值)</li><li>所有元素都会根据元素的键值自动排序<br><strong>本质：</strong></li><li>map&#x2F;multimap属于关联式容器，底层使用二叉树实现<br><strong>优点：</strong></li><li>可以根据key值快速找到value值<br><strong>map和multimap区别：</strong></li><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h3 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h3><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作<br><strong>函数原型：</strong><br>构造：</li><li>map&lt;T1,T2&gt;mp; &#x2F;&#x2F;map默认构造函数</li><li>map(const map &amp;mp); &#x2F;&#x2F;拷贝构造函数<br><strong>赋值：</strong></li><li>map&amp; operator&#x3D;(const map &amp;mp); &#x2F;&#x2F;重载等号操作符<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;map&gt;<br>using namespace std;<br><br>void print(const map&lt;int,int&gt;&amp;m)&#123;<br>    for(map&lt;int,int&gt;::const_iterator it=m.begin();it!=m.end();it++)&#123;<br>        cout&lt;&lt;&quot;key= &quot;&lt;&lt;(*it).first&lt;&lt;&quot;value= &quot;&lt;&lt;(*it).second&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><br>void test01()&#123;<br>    map&lt;int,int&gt;m;<br>    m.insert(pair&lt;int,int&gt;(1,10));<br>    m.insert(pair&lt;int,int&gt;(3,30));<br>    m.insert(pair&lt;int,int&gt;(2,20));<br>    m.insert(pair&lt;int,int&gt;(4,40));<br>    <br>    print(m);<br>    <br>    //拷贝构造<br>    map&lt;int,int&gt;m2(m);<br>    print(m2);<br>    <br>    //赋值<br>    map&lt;int,int&gt;m3;<br>    m3=m2;<br>    print(m3);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h3><p>功能描述：</p><ul><li>统计map容器大小以及交换map容器<br>函数原型：</li><li>size(); &#x2F;&#x2F;返回容器中元素的数目</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>swap(st); &#x2F;&#x2F;交换两个集合容器<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">-map大小和交换<br>功能描述：<br><br>统计map容器大小以及交换map容器<br>函数原型：<br><br>size(); //返回容器中元素的数目<br>empty(); //判断容器是否为空<br>swap(st); //交换两个集合容器<br></code></pre></td></tr></table></figure></li></ul><h3 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h3><p>功能描述：</p><ul><li>map容器进行插入数据和删除数据<br>函数原型：</li><li>insert(elem); &#x2F;&#x2F;在容器中插入元素</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器</li><li>erase(beg,end); &#x2F;&#x2F;删除区间[beg,end)的所有有元素，返回下一个元素的迭代器</li><li>erase(key); &#x2F;&#x2F;删除容器中值为key的元素<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>using namespace std;<br><br>void print(const map&lt;int,int&gt;&amp;m)&#123;<br>    for(map&lt;int,int&gt;::const_iterator it=m.begin();it!=m.end();it++)&#123;<br>        cout&lt;&lt;&quot;key= &quot;&lt;&lt;it-&gt;first&lt;&lt;&quot; value= &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br>void test01()&#123;<br>    map&lt;int,int&gt;m;<br>    //第一种<br>    m.insert(pair&lt;int,int&gt;(1,10));<br>    //第二种<br>    m.insert(make_pair(2,20));<br>    //第三种<br>    m.insert(map&lt;int,int&gt;::value_type(3,30));<br>    //第四种,不建议使用<br>    m[4]=40;<br>    //[]不建议插入，用途可以利用key访问到value<br>    cout&lt;&lt;m[5]&lt;&lt;endl;   //如果容器没有这个key值会直接插入该键值实值为0的元素<br>    print(m);<br>    <br>    //删除<br>    m.erase(m.begin());<br>    print(m);<br>    m.erase(3);  //按照key删除<br>    print(m);<br>    //清空<br>    //m.erase(m.begin(),m.end());<br>    m.clear();<br>    print(m);<br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h3 id="map插入和删除-1"><a href="#map插入和删除-1" class="headerlink" title="map插入和删除"></a>map插入和删除</h3><p>功能描述：</p><ul><li>map容器进行插入数据和删除数据<br>函数原型：</li><li>insert(elem); &#x2F;&#x2F;在容器中插入元素</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器</li><li>erase(beg,end); &#x2F;&#x2F;删除区间[beg,end)的所有有元素，返回下一个元素的迭代器</li><li>erase(key); &#x2F;&#x2F;删除容器中值为key的元素<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;map&gt;<br>using namespace std;<br><br>void print(const map&lt;int,int&gt;&amp;m)&#123;<br>    for(map&lt;int,int&gt;::const_iterator it=m.begin();it!=m.end();it++)&#123;<br>        cout&lt;&lt;&quot;key= &quot;&lt;&lt;it-&gt;first&lt;&lt;&quot; value= &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br>void test01()&#123;<br>    map&lt;int,int&gt;m;<br>    //第一种<br>    m.insert(pair&lt;int,int&gt;(1,10));<br>    //第二种<br>    m.insert(make_pair(2,20));<br>    //第三种<br>    m.insert(map&lt;int,int&gt;::value_type(3,30));<br>    //第四种,不建议使用<br>    m[4]=40;<br>    //[]不建议插入，用途可以利用key访问到value<br>    cout&lt;&lt;m[5]&lt;&lt;endl;   //如果容器没有这个key值会直接插入该键值实值为0的元素<br>    print(m);<br>    <br>    //删除<br>    m.erase(m.begin());<br>    print(m);<br>    m.erase(3);  //按照key删除<br>    print(m);<br>    //清空<br>    //m.erase(m.begin(),m.end());<br>    m.clear();<br>    print(m);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="map查找和统计"><a href="#map查找和统计" class="headerlink" title="map查找和统计"></a>map查找和统计</h3><p>功能描述：</p><ul><li>对map容器进行查找数据以及统计数据<br>函数原型：</li><li>find(key); &#x2F;&#x2F;查找key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li>count(key); &#x2F;&#x2F;统计key的元素个数<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>using namespace std;<br><br>void test01()&#123;<br>    map&lt;int,int&gt;m;<br>    m.insert(make_pair(1,10));<br>    m.insert(make_pair(2,20));<br>    m.insert(make_pair(3,30));<br>    m.insert(make_pair(4,40));<br>    map&lt;int,int&gt;::iterator pos=m.find(3);<br>    if(pos!=m.end())&#123;<br>        cout&lt;&lt;&quot;查到了元素key= &quot;&lt;&lt;pos-&gt;first&lt;&lt;&quot; value= &quot;&lt;&lt;pos-&gt;second&lt;&lt;endl;<br>    &#125;else&#123;<br>        cout&lt;&lt;&quot;未找到元素&quot;&lt;&lt;endl;<br>    &#125;<br>    //统计<br>    //map不允许插入重复key元素，count统计而言，结果要么0，要么1<br>    int num=m.count(3);<br>    cout&lt;&lt;&quot;num= &quot;&lt;&lt;num&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="map容器排序"><a href="#map容器排序" class="headerlink" title="map容器排序"></a>map容器排序</h3><p>学习目标：</p><ul><li>map容器默认排序规则为按照key值进行从小到大排序，掌握如何改变排序规则<br>主要技术点：</li><li>利用仿函数，可以改变排序规则<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>using namespace std;<br><br>class mycompare&#123;<br>public:<br>    bool operator()(int v1,int v2)&#123;<br>        //降序<br>        return v1&gt;v2;<br>    &#125;<br>&#125;;<br><br>void test01()&#123;<br>    map&lt;int,int,mycompare&gt;m;<br>    m.insert(make_pair(1,10));<br>    m.insert(make_pair(2,30));<br>    m.insert(make_pair(3,30));<br>    m.insert(make_pair(4,40));<br>    m.insert(make_pair(5,50));<br>    for(map&lt;int,int&gt;::iterator it=m.begin();it!=m.end();it++)&#123;<br>        cout&lt;&lt;&quot;key= &quot;&lt;&lt;it-&gt;first&lt;&lt;&quot; value= &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="unordered-map-哈希-容器"><a href="#unordered-map-哈希-容器" class="headerlink" title="unordered_map(哈希)容器"></a>unordered_map(哈希)容器</h2><p><strong>功能描述：</strong></p><ul><li>是一个底层由哈希表实现的无序容器，可存储若干个键值对，键有唯一性。</li></ul><h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><p><strong>构造函数：</strong></p><ul><li>unordered_map&lt;key_type,val_type&gt; um &#x2F;&#x2F;key_type为键的类型一般为int型，val_type为存储数据类型<br><strong>赋值操作：</strong></li><li>unordered_map&amp; operator&#x3D;(const unordered_map &amp;um); &#x2F;&#x2F;重载等号操作符<br><strong>数据存取：</strong></li><li>insert(make_pair(key,val)) &#x2F;&#x2F;向哈希表中插入键值对<br><strong>数据查找&#x2F;修改：</strong></li><li>count(const key_type&amp; key); &#x2F;&#x2F;返回键为key的元素个数</li><li>find(const key_type&amp; key); &#x2F;&#x2F;返回键为key的第一个元素，返回迭代器，没找到返回end()</li><li>emplace(const key_type&amp; key,const val_type&amp; val); &#x2F;&#x2F;如果容器中没有对应的键值，则插入一个新元素，如果有，就修改该键值对应的value值</li><li>clear(); &#x2F;&#x2F;清除容器中所有元素</li><li>iterator erase ( const_iterator position ); &#x2F;&#x2F;删除指定迭代器的元素</li><li>size_type erase ( const key_type&amp; k ); &#x2F;&#x2F;删除指定键值的元素</li><li>iterator erase ( const_iterator first, const_iterator last ); &#x2F;&#x2F;删除指定迭代器范围内的元素</li><li>swap(unordered_map&amp; ump); &#x2F;&#x2F;互相交换两个容器的内容，容器类型必须一致，但大小可以不同<br>大小操作：</li><li>empty(); &#x2F;&#x2F;判断哈希表是否为空</li><li>size(); &#x2F;&#x2F;返回哈希表的大小</li><li>max_size(); &#x2F;&#x2F;返回哈希容器最大容纳数量</li></ul><h1 id="STL-函数对象"><a href="#STL-函数对象" class="headerlink" title="STL-函数对象"></a>STL-函数对象</h1><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><h3 id="函数对象概念"><a href="#函数对象概念" class="headerlink" title="函数对象概念"></a>函数对象概念</h3><p><strong>概念</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为函数对象</li><li>函数对象使用重载的（）时，行为类似函数调用，也叫<strong>仿函数</strong><br><strong>本质</strong>：<br>函数对象(仿函数)是一个类，不是一个函数</li></ul><h3 id="函数对象使用"><a href="#函数对象使用" class="headerlink" title="函数对象使用"></a>函数对象使用</h3><p><strong>特点</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>using namespace std<br>class myadd&#123;<br>public:<br>      int opertaor()(int v1, int v2)&#123;<br>          return v1 + v2;<br>          &#125;<br>&#125;;<br><br>void test01()&#123;<br>    myadd a;<br>    cout &lt;&lt; a(10,10) &lt;&lt; endl;<br>    &#125;<br>    <br>class myprint&#123;<br>public:<br>      myprint()&#123;<br>          this-&gt;cnt = 0;<br>          &#125;<br>      void operator()(string test)&#123;<br>          cout &lt;&lt; test &lt;&lt; endl;<br>          cnt++;<br>          &#125; <br>      int cnt;<br>&#125;;<br>void test02()&#123;<br>    myprint p;<br>    p(&quot;hello world&quot;);<br>    cout &lt;&lt; p.cnt &lt;&lt; endl;<br>&#125;<br><br>void doprint(myprint &amp;mp, string tet)&#123;<br>      mp(test);<br>&#125;<br><br>void test03()&#123;<br>      myprint p;<br>      doprint(p, &quot;hello c++&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：仿函数写法非常灵活，可以作为参数进行传递</p></blockquote></li></ul><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><h3 id="谓词概念"><a href="#谓词概念" class="headerlink" title="谓词概念"></a>谓词概念</h3><p><strong>概念</strong></p><ul><li>返回bool类型的仿函数称为谓词</li><li>如果operator()接收一个参数，那么叫做一元谓词</li><li>如果operator()接收两个参数，那么叫做二元谓词</li></ul><h3 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>class greaterfive&#123;<br>public:<br>    bool operator()(int val)&#123;<br>        return val&gt;5;<br>        &#125;<br>    &#125;；<br>    <br>void test01()&#123;<br>    vector&lt;int&gt; v;<br>    for(int i = 0; i &lt; 10; i++)&#123;<br>               v.push_back(i);<br>    &#125;<br>    <br>    vector&lt;int&gt;::iterator it = find_if(v.begin(),v.end(),greaterfive());<br>    if((if == v.end())&#123;<br>          cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;<br>    &#125;else&#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二元谓词"><a href="#二元谓词" class="headerlink" title="二元谓词"></a>二元谓词</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#inlcude &lt;algorithm&gt;<br>using namespace std;<br><br>class mycommpare&#123;<br>public:<br>    bool operator()(int val1, int val2)&#123;<br>        return val1 &gt; val2;<br>    &#125;<br>&#125;;<br><br>void test01()&#123;<br>      vector&lt;int&gt; v;<br>      v.push_back(10);<br>      v.push_back(40);<br>      v.push_back(20);<br>      v.push_back(30);<br>      v.push_back(50);<br>      v.push_back(60);<br>      sort(v.begin(), v.end());<br>      for(vecgtor&lt;int&gt;::iterator it = v.bengin(); it != end(); it++)&#123;<br>            cout &lt;&lt; *it ;<br>            &#125;<br>      cout &lt;&lt; endl;<br>      sort(v.bengin(),v.end,mycompare());<br>      cout&lt;&lt;&quot;-----------------------&quot;&lt;&lt; endl;<br>      for(vector&lt;int&gt;::iterator it = v.begin() ; it != v.end(); it++)&#123;<br>          cout &lt;&lt; *it <br>          &#125;<br>      cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h2><h3 id="内建函数对象意义"><a href="#内建函数对象意义" class="headerlink" title="内建函数对象意义"></a>内建函数对象意义</h3><p><strong>概念</strong>：</p><ul><li>STL内建一些函数对象<br><strong>分类</strong></li><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数<br><strong>用法</strong></li><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件#include<functional></li></ul><h3 id="算术仿函数"><a href="#算术仿函数" class="headerlink" title="算术仿函数"></a>算术仿函数</h3><p><strong>功能描述</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算<br><strong>仿函数原型</strong></li><li>template<class T> T plus<T> &#x2F;&#x2F;加法仿函数</li><li>template<class T> T minus<T> &#x2F;&#x2F;减法仿函数</li><li>template<class T> T multiplies<T> &#x2F;&#x2F;乘法仿函数</li><li>template<class T> T divides<T> &#x2F;&#x2F;除法仿函数</li><li>template<class T> T modulus<T> &#x2F;&#x2F;取模仿函数</li><li>template<class T> T negate<T> &#x2F;&#x2F;取反仿函数<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;functional&gt;<br>using namespace std;<br><br>void tet01()&#123;<br>        negate&lt;int&gt; n;<br>        cout&lt;&lt; n(50) &lt;&lt; endl;<br>        &#125;       <br>void tet02()&#123;<br>      plus&lt;int&gt; p ;<br>      cout &lt;&lt; p(10, 10) &lt;&lt; endl;<br>      &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h3><p><strong>功能描述</strong>：</p><ul><li>实现关系对比<br><strong>仿函数原型</strong>：</li><li>template<class T> bool equal_to<T> &#x2F;&#x2F;等于</li><li>template<class T> bool not_equal_to<T> &#x2F;&#x2F;不等于</li><li>template<class T> bool greater<T> &#x2F;&#x2F;大于</li><li>template<class T> bool greater_equal<T> &#x2F;&#x2F;大于等于</li><li>template<class T> bool less<T> &#x2F;&#x2F;小于</li><li>template<class T> bool less_equal<T> &#x2F;&#x2F;小于等于<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;functional&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>class mycompare&#123;<br>public:<br>      bool operator()(interestingv1,int v2)&#123;<br>            return v1 &gt; v2;<br>        &#125;<br>&#125;;<br><br>void test01()&#123;<br>      vector&lt;int&gt;v;<br>      v.push_back(10);<br>      v.push_back(10);<br>      v.push_back(10);<br>      v.push_back(10);<br>      v.push_back(10);     <br>      for(vector&lt;int&gt;::iterator it = v.bengin(); it != v.end(); it++)&#123;<br>          cout&lt;&lt;*it;<br>      &#125;<br>      cout &lt;&lt; endl;<br>      sort(b=v.begin(),v.end(),greater&lt;int&gt;());<br>      for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;<br>          cout&lt;&lt;*it;<br>          &#125;<br>      cout&lt;&lt; endl;<br>      &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h3><p><strong>功能描述</strong>：</p><ul><li>实现逻辑运算<br><strong>函数原型</strong></li><li>template<class T> bool logical_and<T> &#x2F;&#x2F;逻辑与</li><li>template<class T> bool logical_or<T> &#x2F;&#x2F;逻辑或</li><li>template<class T> bool logical_not<T> &#x2F;&#x2F;逻辑非<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;functional&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br>void test01()&#123;<br>    vector&lt;bool&gt;v;<br>    v.push_back(true);<br>    v.push_back(false);<br>    v.push_back(true);<br>    v.push_back(false);<br>    <br>   for(vector&lt;bool&gt;::iterator it=v.begin();it!=v.end();it++)&#123;<br>       cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>   &#125;<br>    cout&lt;&lt;endl;<br>    //利用逻辑非将容器v搬运到容器v2中，并执行取反的操作<br>    vector&lt;bool&gt;v2;<br>    v2.resize(v.size());<br>    transform(v.begin(),v.end(),v2.begin(),logical_not&lt;bool&gt;());<br>    cout&lt;&lt;&quot;--------------------&quot;&lt;&lt;endl;<br>    for(vector&lt;bool&gt;::iterator it=v2.begin();it!=v2.end();it++)&#123;<br>       cout&lt;&lt;*it&lt;&lt;&quot; &quot;;<br>   &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：逻辑仿函数实际应用较少，了解即可</p></blockquote></li></ul><h1 id="STL-常用算法"><a href="#STL-常用算法" class="headerlink" title="STL-常用算法"></a>STL-常用算法</h1><p><strong>概念</strong>：</p><ul><li>算法主要是由头文件<algorithm> <functional> <numeric>组成</li><li><algorithm>是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等</li><li><numeric>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><functional>定义了一些模板类，用以声明函数对象</li></ul><h2 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h2><p><strong>学习目标</strong></p><ul><li>掌握常用的遍历算法<br>算法简介：</li><li>for_each &#x2F;&#x2F;遍历容器</li><li>transform &#x2F;&#x2F;搬运容器到另外一个容器中</li></ul><h3 id="for-each算法"><a href="#for-each算法" class="headerlink" title="for_each算法"></a>for_each算法</h3><p><strong>功能描述</strong></p><ul><li>实现遍历容器<br><strong>函数原型</strong></li><li>for_each(iterator beg,iterator end, _func);<br>&#x2F;&#x2F;遍历算法 遍历容器元素<br>&#x2F;&#x2F;beg开始迭代器<br>&#x2F;&#x2F;end结束迭代器<br>&#x2F;&#x2F;_func函数或者函数对象<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#inlcude &lt;vector&gt;<br>using namespace std;<br><br>void print01(int val)&#123;<br>    cout &lt;&lt; val;<br>&#125;<br><br>class print02&#123;<br>public:<br>     void operator()(int val)&#123;<br>        cout &lt;&lt; val;<br>     &#125;<br>&#125;;<br><br>void test01()&#123;<br>    vector&lt;int&gt; v;<br>    for(int i = 0; i &lt; 10; i++)&#123;<br>        v.push_back(i);<br>    &#125;<br>    for_each(v.begin(), v.end(), print01);<br>    coout &lt;&lt; endl;<br>    for_each(v.begin(),v.end(),priunt02());<br>    cout &lt;&lt; endl;<br>&#125;<br>&gt; 总结：for_each在实际开发中是最常用的遍历算法，需要熟练掌握<br></code></pre></td></tr></table></figure></li></ul><h3 id="transform算法"><a href="#transform算法" class="headerlink" title="transform算法"></a>transform算法</h3><p>功能描述：</p><ul><li>搬运容器到另一个容器中<br>函数原型：</li><li>transform(iterator beg1,iterator end1,iterator beg2,_func);<br>&#x2F;&#x2F;beg1 源容器开始迭代器<br>&#x2F;&#x2F;end1 源容器结束迭代器<br>&#x2F;&#x2F;beg2 目标容器开始迭代器<br>&#x2F;&#x2F;_func 函数或者函数对象<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br> #include &lt;vector&gt;<br> #include &lt;algorithm&gt;<br> using namespace std;<br> class Transform&#123;<br> public:<br>    int operator()(int v)&#123;<br>          return v+1000;<br>    &#125;<br>    &#125;;<br> class myprint&#123;<br> public:<br>      void operator()(int val)&#123;<br>          cout &lt;&lt; val ;<br>          &#125;<br>      &#125;;<br>      <br>void test01()&#123;<br>    vector&lt;int&gt; v;<br>    for(int i = 0; i &lt; 10; i++)&#123;<br>        v.push_back(i);<br>    &#125;<br>    <br>    vector&lt;int&gt;vt;//目标容器<br>    vt.resize(v.size());//目标容器需要提前开辟空间<br>    transform(v.bengin(),v.end(),vt.begin(),Transform());<br>    for_each(vt.bengin(),vt.end(),myprintf());<br>    cout&lt;&lt;endl;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p></blockquote></li></ul><h2 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h2><p><strong>学习目标</strong>：</p><ul><li>掌握常用的查找算法<br><strong>算法简介</strong>：</li><li>find &#x2F;&#x2F;查找元素</li><li>find_if &#x2F;&#x2F;按条件查找元素</li><li>abjacent_find &#x2F;&#x2F;查找相邻重复元素</li><li>binary_search &#x2F;&#x2F;二分查找法</li><li>count &#x2F;&#x2F;统计元素个数</li><li>count_if &#x2F;&#x2F;按条件统计元素个数</li></ul><h3 id="find算法"><a href="#find算法" class="headerlink" title="find算法"></a>find算法</h3><p><strong>功能描述</strong>：<br>功能描述：</p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()<br>函数原型：</li><li>find(iterator beg,iterator end,value);<br>&#x2F;&#x2F;按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>&#x2F;&#x2F;beg 开始迭代器<br>&#x2F;&#x2F;end 结束迭代器<br>&#x2F;&#x2F;value 查找的元素<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>using namespace std;<br><br>class greaterfive&#123;<br>public:<br>    bool operator()(int val)&#123;<br>        return val &gt; 5;<br>        &#125;<br>&#125;;<br><br>// 查找内置数据类型<br>void tsst01()&#123;<br>    vector&lt;int&gt;v&#123;<br>    for(int i = 0; i &lt; 10; i++)&#123;<br>        v.push_back(i);<br>    &#125;<br>    vector&lt;int&gt;::iterator it = find_if(v.bengin(),v.end(),greaterfive());<br>    if(it == v.end())&#123;<br>        cout&lt;&lt; &quot;0&quot; &lt;&lt; endl;<br>    &#125;else&#123;<br>        cout&lt;&lt; &quot;1&quot; &lt;&lt; endl;<br>    &#125;<br>&#125;<br>class Person&#123;<br>public:<br>    Person(string name, int age)&#123;<br>          this-&gt;m_name = name;<br>          this-&gt;m_age = age;<br>          &#125;<br>          string m_name;<br>          int m_age;<br>&#125;;<br>class gerater20&#123;<br>public:<br>    bool operator()(Person &amp;p)&#123;<br>        return p.m_age &gt; 20;<br>        &#125;<br>&#125;;<br><br>void test02()&#123;<br>    vector&lt;Person&gt;v;<br>    Person p1(&quot;a&quot;, 10);<br>    Person p1(&quot;b&quot;, 20);<br>    Person p1(&quot;c&quot;, 30);<br>    Person p1(&quot;d&quot;, 40);<br>    v.push_back(p1);<br>    v.push_back(p2);<br>    v.push_back(p3);<br>    v.push_back(p4);<br>    vector&lt;Person&gt;::iterator it = find_if(v.begin(),vv.end(),greater20());<br>    if(it==v.end())&#123;<br>        cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;<br>    &#125;else&#123;<br>        cout &lt;&lt; it-&gt;m_name &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="find-if-算法"><a href="#find-if-算法" class="headerlink" title="find_if 算法"></a>find_if 算法</h3><p>功能描述： </p><ul><li>按条件查找元素<br>函数原型：</li><li>find_if(iterator beg,iterator end,_Pred);<br>&#x2F;&#x2F;按值查找元素，找到返回指定位置的迭代器，找不到返回结束迭代器位置<br>&#x2F;&#x2F;beg 开始迭代器<br>&#x2F;&#x2F;end 结束迭代器<br>&#x2F;&#x2F;_Pred 函数或者谓词(返回bool类型的仿函数)<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>class greaterfive&#123;<br>public:<br>    bool operator()(int val)&#123;<br>        return val&gt;5;<br>    &#125;<br>&#125;;<br><br>//查找内置数据类型<br>void test01()&#123;<br>    vector&lt;int&gt;v;<br>    for(int i=0;i&lt;10;i++)&#123;<br>        v.push_back(i);<br>    &#125;<br>    vector&lt;int&gt;::iterator it=find_if(v.begin(),v.end(),greaterfive());<br>    if(it==v.end())&#123;<br>        cout&lt;&lt;&quot;没有找到&quot;&lt;&lt;endl;<br>    &#125;else&#123;<br>        cout&lt;&lt;&quot;找到大于5的数字为：&quot;&lt;&lt;*it&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br>class Person&#123;<br>public:<br>    Person(string name,int age)&#123;<br>        this-&gt;m_name=name;<br>        this-&gt;m_age=age;<br>    &#125;<br>    string m_name;<br>    int m_age;<br>&#125;;<br><br>class greater20&#123;<br>public:<br>    bool operator()(Person &amp;p)&#123;<br>        return p.m_age&gt;20;<br>    &#125;<br>&#125;;<br><br>//查找自定义数据类型<br>void test02()&#123;<br>    vector&lt;Person&gt;v;<br>    Person p1(&quot;a&quot;,10);<br>    Person p2(&quot;b&quot;,20);<br>    Person p3(&quot;c&quot;,30);<br>    Person p4(&quot;d&quot;,40);<br>    v.push_back(p1);<br>    v.push_back(p2);<br>    v.push_back(p3);<br>    v.push_back(p4);<br>    vector&lt;Person&gt;::iterator it=find_if(v.begin(),v.end(),greater20());<br>    if(it==v.end())&#123;<br>        cout&lt;&lt;&quot;未找到&quot;&lt;&lt;endl;<br>    &#125;else&#123;<br>        cout&lt;&lt;&quot;找到姓名：&quot;&lt;&lt;it-&gt;m_name&lt;&lt;&quot; 年龄：&quot;&lt;&lt;it-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="adjacent-find-算法"><a href="#adjacent-find-算法" class="headerlink" title="adjacent_find 算法"></a>adjacent_find 算法</h3><p>功能描述：</p><ul><li>查找相邻重复元素<br>函数原型：<br>adjacent_find(iterator beg,iterator end);<br>&#x2F;&#x2F;查找相邻重复元素，返回相邻元素的第一个位置的迭代器<br>&#x2F;&#x2F;beg开始迭代器<br>&#x2F;&#x2F;end 结束迭代器<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br><br>void test01()&#123;<br>    vector&lt;int&gt;v;<br>    v.push_back(0);<br>    v.push_back(2);<br>    v.push_back(0);<br>    v.push_back(3);<br>    v.push_back(1);<br>    v.push_back(4);<br>    v.push_back(3);<br>    v.push_back(3);<br>    vector&lt;int&gt;::iterator pos=adjacent_find(v.begin(),v.end());<br>    if(pos==v.end())&#123;<br>        cout&lt;&lt;&quot;未找到相邻重复元素&quot;&lt;&lt;endl;<br>    &#125;else&#123;<br>        cout&lt;&lt;&quot;找到相邻重复元素：&quot;&lt;&lt;*pos&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="binary-search-算法"><a href="#binary-search-算法" class="headerlink" title="binary_search 算法"></a>binary_search 算法</h3><p>功能描述：</p><ul><li>查找指定元素是否存在<br>函数原型：</li><li>bool binary_search(iterator beg,iterator end,value);<br>&#x2F;&#x2F;查找指定的元素，查到返回true，否则false<br>&#x2F;&#x2F;注意：在无序序列中不可用<br>&#x2F;&#x2F;beg 开始迭代器<br>&#x2F;&#x2F;end 结束迭代器<br>&#x2F;&#x2F;value 查找的元素<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs [c++]"> #include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br><br>void test01() &#123;<br>vector&lt;int&gt;v;<br>for (int i = 0; i &lt; 10; i++) &#123;<br>v.push_back(i);<br>&#125;<br>//注意：容器必须是有序的序列，如果是无序序列结果未知<br>bool ret = binary_search(v.begin(), v.end(), 9);<br>if (ret) &#123;<br>cout &lt;&lt; &quot;找到了元素&quot; &lt;&lt; endl;<br>&#125; else &#123;<br>cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：二分查找法查找效率很高，值得注意的是查找的容器中必须是有序序列</p></blockquote></li></ul><h3 id="count-算法"><a href="#count-算法" class="headerlink" title="count 算法"></a>count 算法</h3><p>功能描述：</p><ul><li>统计元素个数<br>函数原型：</li><li>count(iterator beg,iterator end,value);<br> &#x2F;&#x2F;统计元素出现次数<br> &#x2F;&#x2F;beg 开始迭代器<br> &#x2F;&#x2F;end 结束迭代器<br> &#x2F;&#x2F;value 统计的元素<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>//统计内置数据类型<br>void test01() &#123;<br>vector&lt;int&gt;v;<br>v.push_back(10);<br>v.push_back(40);<br>v.push_back(30);<br>v.push_back(40);<br>v.push_back(40);<br>int num = count(v.begin(), v.end(), 40);<br>cout &lt;&lt; &quot;40的元素个数为：&quot; &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br>//统计自定义数据类型<br>class Person &#123;<br>public:<br>Person(string name, int age) &#123;<br>this-&gt;m_name = name;<br>this-&gt;m_age = age;<br>&#125;<br>bool operator==(const Person &amp;p) &#123;<br>if (this-&gt;m_age == p.m_age) &#123;<br>return true;<br>&#125; else &#123;<br>return false;<br>&#125;<br>&#125;<br>string m_name;<br>int m_age;<br>&#125;;<br><br>void test02() &#123;<br>vector&lt;Person&gt;v;<br>Person p1(&quot;a&quot;, 35);<br>Person p2(&quot;b&quot;, 35);<br>Person p3(&quot;c&quot;, 35);<br>Person p4(&quot;d&quot;, 40);<br>Person p5(&quot;e&quot;, 40);<br>Person p6(&quot;f&quot;, 35);<br>v.push_back(p1);<br>v.push_back(p2);<br>v.push_back(p3);<br>v.push_back(p4);<br>v.push_back(p5);<br>int num = count(v.begin(), v.end(), p6);<br>cout &lt;&lt; &quot;与f同岁数的人员个数为：&quot; &lt;&lt; num &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：统计自定义数据类型时候，需要配合重载operator&#x3D;&#x3D;</p></blockquote></li></ul><h3 id="count-if-算法"><a href="#count-if-算法" class="headerlink" title="count_if 算法"></a>count_if 算法</h3><p>功能描述：</p><ul><li>按条件统计元素个数<br>函数原型：</li><li>count_if(iterator beg,iterator end,_Pred);<br>&#x2F;&#x2F;按条件统计元素出现次数<br>&#x2F;&#x2F;beg 开始迭代器<br>&#x2F;&#x2F;end 结束迭代器<br>&#x2F;&#x2F;_Pred 谓词<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>class greater20 &#123;<br>public:<br>bool operator()(int val) &#123;<br>return val &gt; 20;<br>&#125;<br>&#125;;<br><br>//统计内置数据类型<br>void test01() &#123;<br>vector&lt;int&gt;v;<br>v.push_back(10);<br>v.push_back(40);<br>v.push_back(30);<br>v.push_back(20);<br>v.push_back(40);<br>int num = count_if(v.begin(), v.end(), greater20());<br>cout &lt;&lt; &quot;大于20的元素个数为：&quot; &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br>class Person &#123;<br>public:<br>Person(string name, int age) &#123;<br>this-&gt;m_name = name;<br>this-&gt;m_age = age;<br>&#125;<br>string m_name;<br>int m_age;<br>&#125;;<br><br>class agegreater &#123;<br>public:<br>bool operator()(const Person &amp;p) &#123;<br>return p.m_age &gt; 20;<br>&#125;<br>&#125;;<br><br>//统计自定义数据类型<br>void test02() &#123;<br>vector&lt;Person&gt;v;<br>Person p1(&quot;a&quot;, 35);<br>Person p2(&quot;b&quot;, 35);<br>Person p3(&quot;c&quot;, 35);<br>Person p4(&quot;d&quot;, 40);<br>Person p5(&quot;e&quot;, 20);<br>v.push_back(p1);<br>v.push_back(p2);<br>v.push_back(p3);<br>v.push_back(p4);<br>v.push_back(p5);<br>int num = count_if(v.begin(), v.end(), agegreater());<br>cout &lt;&lt; &quot;大于20岁的人员个数：&quot; &lt;&lt; num &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><p>算法简介：</p><ul><li>sort &#x2F;&#x2F;对容器内元素进行排序</li><li>random_shuffle &#x2F;&#x2F;洗牌 指定范围内的元素随机调整次序</li><li>merge &#x2F;&#x2F;容器元素合并，并存储到另一个容器</li><li>reverse &#x2F;&#x2F;反转指定范围的元素</li><li>sort 算法</li></ul><h3 id="sort-算法"><a href="#sort-算法" class="headerlink" title="sort 算法"></a>sort 算法</h3><p>功能描述：</p><ul><li>对容器内元素进行排序<br>函数原型：</li><li>sort(iterator beg,iterator end,_Pred);<br>&#x2F;&#x2F;按值查找元素，找到返回指定值位置迭代器，找不到返回结束迭代器位置<br>&#x2F;&#x2F;beg 开始迭代器<br>&#x2F;&#x2F;end 结束迭代器<br>&#x2F;&#x2F;_Pred 谓词<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>#include &lt;functional&gt;<br>using namespace std;<br><br>void myprint(int val) &#123;<br>cout &lt;&lt; val &lt;&lt; &quot; &quot;;<br>&#125;<br><br>void test01() &#123;<br>vector&lt;int&gt;v;<br>v.push_back(10);<br>v.push_back(30);<br>v.push_back(50);<br>v.push_back(20);<br>v.push_back(40);<br>sort(v.begin(), v.end());<br>for_each(v.begin(), v.end(), myprint);<br>cout &lt;&lt; endl;<br>sort(v.begin(), v.end(), greater&lt;int&gt;());<br>for_each(v.begin(), v.end(), myprint);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="random-shuffle-算法"><a href="#random-shuffle-算法" class="headerlink" title="random_shuffle 算法"></a>random_shuffle 算法</h3><p>功能描述：</p><ul><li>洗牌 指定范围内的元素随机调整次序<br>函数原型：</li><li>random_shuffle(iterator beg,iterator end);<br>&#x2F;&#x2F;指定范围内的元素随机调整次序<br>&#x2F;&#x2F;beg 开始迭代器<br>&#x2F;&#x2F;end 结束迭代器<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;ctime&gt;<br>using namespace std;<br><br>class print &#123;<br>public:<br>void operator()(int val) &#123;<br>cout &lt;&lt; val &lt;&lt; &quot; &quot;;<br>&#125;<br>&#125;;<br><br>void test01() &#123;<br>srand((unsigned int)time(NULL));<br>vector&lt;int&gt;v;<br>for (int i = 0; i &lt; 10; i++) &#123;<br>v.push_back(i);<br>&#125;<br>random_shuffle(v.begin(), v.end());<br>for_each(v.begin(), v.end(), print());<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：random_shuffle算法使用时记得加随机数种子</p></blockquote></li></ul><h3 id="merge-算法"><a href="#merge-算法" class="headerlink" title="merge 算法"></a>merge 算法</h3><p>功能描述：</p><ul><li>两个容器元素合并，并存储到另一个容器中<br>函数原型：</li><li>merge(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);<br>&#x2F;&#x2F;容器元素合并，并存储到另一容器中<br>&#x2F;&#x2F;注意：两个容器必须是有序的<br>&#x2F;&#x2F;beg1 容器1开始迭代器<br>&#x2F;&#x2F;end1 容器1结束迭代器<br>&#x2F;&#x2F;beg2 容器2开始迭代器<br>&#x2F;&#x2F;end2 容器2结束迭代器<br>&#x2F;&#x2F;dest 目标容器开始迭代器<figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs [c++]">#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>void print(int val)&#123;<br>    cout&lt;&lt;val&lt;&lt;&quot; &quot;;<br>&#125;<br><br><br>void test01()&#123;<br>    vector&lt;int&gt;v1;<br>    vector&lt;int&gt;v2;<br>    for(int i=0;i&lt;10;i++)&#123;<br>        v1.push_back(i);<br>        v2.push_back(i+1);<br>    &#125;<br>    //目标容器<br>    vector&lt;int&gt;v;<br>    //提前给目标容器分配空间<br>    v.resize(v1.size()+v2.size());<br>    merge(v1.begin(),v1.end(),v2.begin(),v2.end(),v.begin());<br>    for_each(v.begin(),v.end(),print);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：merge合并的两个容器必须的有序序列</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录一刷</title>
    <link href="/2024/09/16/DaiMaSuiXiang-1/"/>
    <url>/2024/09/16/DaiMaSuiXiang-1/</url>
    
    <content type="html"><![CDATA[<h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h3><p><img src="/../img/DaiMaSuiXiang_1/704.png"><br>第一种（左闭右闭）</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int search(int* nums, int numsSize, int target) &#123;<br>    int left = 0;<br>    int right = numsSize - 1;<br>    int middle;<br>    while(left &lt;= right)&#123;<br>         middle = (left + right) / 2;<br>        if(target &lt; nums[middle])<br>            right = middle - 1;<br>        else if(target &gt;nums[middle] )<br>            left =  middle + 1;<br>        else<br>            return middle;<br>    &#125;<br>    return -1;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种（左闭右开）</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int search(int* nums, int numsSize, int target) &#123;<br>    int left = 0;<br>    int right = numsSize;<br>    int middle;<br>    while(left &lt; right)&#123;<br>         middle = (left + right) / 2;<br>        if(target &lt; nums[middle])<br>            right = middle;<br>        else if(target &gt;nums[middle] )<br>            left =  middle + 1;<br>        else<br>            return middle;<br>    &#125;<br>    return -1;<br></code></pre></td></tr></table></figure><p><strong>总结</strong><br>二分法就是化一为二，将问题细分，当是一个有序的数组才可以使用，区间的选择决定了while的条件和right的值</p><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p><img src="/../img/DaiMaSuiXiang_1/34.png"><br>思路：通过两个二分法分别找出左右两个边界。<br>错误和分析：我将数组从中间分成两半，然后这个中间值作为左右两个边界了，应该是先用二分法找出第一个出现的目标值，然后再根据找哪个边界值然后才进行下一个二分法。虽然我的想法是这个的，但是我的代码还是先是将中间值作为了边界值<br>新知识：&gt;&gt;1右移运算符，将二进制位数向右移动一位，相当于整数除法除以2<br>middle &#x3D; left+((right - letf) &gt;&gt; 1)  等于 middle&#x3D;（left+right)&#x2F;2</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int searchLeftBorder(int *nums, int numsSize, int target) &#123;<br>    int left = 0, right = numsSize - 1;<br>    // 记录leftBorder没有被赋值的情况<br>    int leftBorder = -1;<br>    // 边界为[left, right]<br>    while (left &lt;= right) &#123;<br>        // 更新middle值，等同于middle = (left + right) / 2<br>        int middle = left + ((right - left) &gt;&gt; 1);<br>        // 若当前middle所指为target，将左边界设为middle，并向左继续寻找左边界<br>        if (nums[middle] == target) &#123;<br>            leftBorder = middle;<br>            right = middle - 1;<br>        &#125; else if (nums[middle] &gt; target) &#123;<br>            right = middle - 1;<br>        &#125; else &#123;<br>            left = middle + 1;<br>        &#125;<br>    &#125;<br>    return leftBorder;<br>&#125;<br>int searchRightBorder(int *nums, int numsSize, int target) &#123;<br>    int left = 0, right = numsSize - 1;<br>    // 记录rightBorder没有被赋值的情况<br>    int rightBorder = -1;<br>    while (left &lt;= right) &#123;<br>        int middle = left + ((right - left) &gt;&gt; 1);<br>        // 若当前middle所指为target，将右边界设为middle，并向右继续寻找右边界<br>        if (nums[middle] == target) &#123;<br>            rightBorder = middle;<br>            left = middle + 1;<br>        &#125; else if (nums[middle] &gt; target) &#123;<br>            right = middle - 1;<br>        &#125; else &#123;<br>            left = middle + 1;<br>        &#125;<br>    &#125;<br>    return rightBorder;<br>&#125;<br> <br>int* searchRange(int* nums, int numsSize, int target, int* returnSize)&#123;<br>    int leftBorder = searchLeftBorder(nums, numsSize, target);<br>    int rightBorder = searchRightBorder(nums, numsSize, target);<br> <br>    // 定义返回数组及数组大小<br>    *returnSize = 2;<br>    int *resNums = (int*)malloc(sizeof(int) * 2);<br>    resNums[0] = leftBorder;<br>    resNums[1] = rightBorder;<br>    return resNums;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="35搜索插入位置"><a href="#35搜索插入位置" class="headerlink" title="35搜索插入位置"></a>35搜索插入位置</h3><p><img src="/../img/DaiMaSuiXiang_1/35.png"><br>左闭右闭</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int searchInsert(int* nums, int numsSize, int target) &#123;<br>    int left = 0;<br>    int right = numsSize - 1;<br>    int  middle;<br>    while(left &lt;= right)&#123;<br>        middle = (left + right)/2;<br>        if(nums[middle] &lt; target )<br>            left = middle + 1;<br>        else if(nums[middle] &gt; target)<br>            right = middle - 1;<br>        else <br>            return middle;<br>    &#125;<br>    return right + 1;<br>    &#125;<br></code></pre></td></tr></table></figure><p>左闭右开</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int searchInsert(int* nums, int numsSize, int target) &#123;<br>    int left = 0;<br>    int right = numsSize;<br>    int  middle;<br>    while(left &lt; right)&#123;<br>        middle = (left + right)/2;<br>        if(nums[middle] &lt; target )<br>            left = middle + 1;<br>        else if(nums[middle] &gt; target)<br>            right = middle;<br>        else <br>            return middle;<br>    &#125;<br>    return right;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><p><img src="/../img/DaiMaSuiXiang_1/27.png"><br>暴力解法</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int removeElement(int* nums, int numsSize, int val) &#123;<br>    for(int i = 0;i &lt; numsSize; i++)&#123;<br>        if(nums[i] == val)<br>        &#123;<br>            for(int j = i + 1; j &lt; numsSize; j++ )<br>                nums[j - 1] = nums[j];<br>            i--;<br>            numsSize--; <br>        &#125;<br>    &#125;<br>    return numsSize;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int removeElement(int* nums, int numsSize, int val) &#123;<br>    int slow = 0; <br>    for(int fast = 0; fast &lt; numsSize; fast++)&#123;<br>        if(nums[fast] != val)<br>            nums[slow++] = nums[fast];<br>    &#125;<br>    return slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结<br>数组理论知识：数组在内存上是连续的，不可以通过删除移除元素，只可以通过覆盖元素<br>双指针：慢指针是指向数组位置，快指针是指向数值，将原来的数组当作空白的数组，只要不是删除值，那么就将它复制数组中</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p><img src="/../img/DaiMaSuiXiang_1/997.png"><br>暴力解法（插入排序）</p><figure class="highlight plaintext"><figcaption><span>[c]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bush">void square(int* nums, int numsSize)&#123;<br>    for(int i = 0; i &lt; numsSize; i++)<br>        nums[i]*=nums[i];<br>&#125;<br>void insertSort(int* nums, int numsSize)&#123;<br>    int i;<br>    int p;<br>    int temp;<br>    for(i = 1; i &lt; numsSize; i++)&#123;<br>        temp = nums[i];<br>        for(p = i;p &gt; 0 &amp;&amp; nums[p-1] &gt; temp; p--)<br>            nums[p] = nums[p-1];<br>        nums[p] = temp;<br>    <br>    &#125;<br>&#125;<br>int* sortedSquares(int* nums, int numsSize, int* returnSize) &#123;<br>    square(nums, numsSize);<br>    insertSort(nums, numsSize);<br>    *returnSize = numsSize;<br>    int* ans=(int*)malloc(sizeof(int)*numsSize);<br>    for(int i = 0; i &lt; numsSize; i++)<br>        ans[i] = nums[i];<br>    return ans;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>双指针</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs [c]">/**<br> * Note: The returned array must be malloced, assume caller calls free().<br> */<br>int* sortedSquares(int* nums, int numsSize, int* returnSize) &#123;<br>    *returnSize = numsSize;<br>    int left = 0;<br>    int right = numsSize - 1;<br>    int*ans = (int*)malloc(sizeof(int)*numsSize);<br>    int index;<br>    for( index = numsSize-1; index &gt;= 0; index--)&#123;<br>        int lsquare = nums[left]*nums[left];<br>        int rsquare =  nums[right]*nums[right];<br>        if(lsquare &gt; rsquare)<br>        &#123;<br>            ans[index] = lsquare;<br>            left++;<br>        &#125;<br>        else<br>        &#123;<br>            ans[index] = rsquare;<br>            right--;<br>        &#125;<br>        <br>    &#125;<br>    return ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：如何使用双指针是看题目的需求，这道题用双指针的思路和归并排序的思路相类似。</p><h3 id="209-长度最小数组"><a href="#209-长度最小数组" class="headerlink" title="209.长度最小数组"></a>209.长度最小数组</h3><p><img src="/../img/DaiMaSuiXiang_1/209.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int minSubArrayLen(int target, int* nums, int numsSize) &#123;<br>    int minlength =  INT_MAX;<br>    int sum = 0;<br>    int left = 0;<br>    int right = 0;<br>    for(; right &lt; numsSize; right++)&#123;<br>        sum+=nums[right];<br>        while(sum &gt;= target)<br>        &#123;<br>            int SubLength = right - left + 1;<br>            minlength=minlength &lt; SubLength ? minlength: SubLength;<br>            sum-= nums[left++];<br>        &#125;<br>    &#125;<br>    return minlength == INT_MAX ? 0 : minlength;<br>&#125;<br></code></pre></td></tr></table></figure><p>我的错误：想将所有的长度放在一个数组里，然后再进行比较，而且没有完全将所有的可能考虑到。对c语言还不是很熟练<br>总结：滑动窗口中，要考虑滑动窗口是如何移动的。看到最大值，可以使用动态变化，可以使用三元表示法，最值初始化时，可以使用头文件带的最值。</p><h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h3><p><img src="/../img/DaiMaSuiXiang_1/59.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int** generateMatrix(int n, int* returnSize, int** returnColumnSizes)&#123;<br>    //初始化返回的结果数组的大小<br>    *returnSize = n;<br>    *returnColumnSizes = (int*)malloc(sizeof(int) * n);<br>    //初始化返回结果数组ans<br>    int** ans = (int**)malloc(sizeof(int*) * n);<br>    int i;<br>    for(i = 0; i &lt; n; i++) &#123;<br>        ans[i] = (int*)malloc(sizeof(int) * n);<br>        (*returnColumnSizes)[i] = n;<br>    &#125;<br> <br>    //设置每次循环的起始位置<br>    int startX = 0;<br>    int startY = 0;<br>    //设置二维数组的中间值，若n为奇数。需要最后在中间填入数字<br>    int mid = n / 2;<br>    //循环圈数<br>    int loop = n / 2;<br>    //偏移数<br>    int offset = 1;<br>    //当前要添加的元素<br>    int count = 1;<br> <br>    while(loop) &#123;<br>        int i = startX;<br>        int j = startY;<br>        //模拟上侧从左到右<br>        for(; j &lt;   n - offset; j++) &#123;<br>            ans[startX][j] = count++;<br>        &#125;<br>        //模拟右侧从上到下<br>        for(; i &lt;  n - offset; i++) &#123;<br>            ans[i][j] = count++;<br>        &#125;<br>        //模拟下侧从右到左<br>        for(; j &gt; startY; j--) &#123;<br>            ans[i][j] = count++;<br>        &#125;<br>        //模拟左侧从下到上<br>        for(; i &gt; startX; i--) &#123;<br>            ans[i][j] = count++;<br>        &#125;<br>        //偏移值每次加2<br>        offset+=1;<br>        //遍历起始位置每次+1<br>        startX++;<br>        startY++;<br>        loop--;<br>    &#125;<br>    //若n为奇数需要单独给矩阵中间赋值<br>    if(n%2)<br>        ans[mid][mid] = count;<br> <br>    return ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：螺旋矩阵最重要的就是区间的选择。</p><h2 id="数组总结"><a href="#数组总结" class="headerlink" title="数组总结"></a>数组总结</h2><p>理论<br>数组的内存是连续的，想要得到连续的数组，就不可以直接删除其中的元素<br>二维数组的初始化</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int** ans = (int**)malloc(sizeof(int*) * n);<br>    int i;<br>    for(i = 0; i &lt; n; i++) &#123;<br>    ans[i] = (int*)malloc(sizeof(int) * n);<br></code></pre></td></tr></table></figure><p>解题方法：<br>二分法：根据是否满足题目的条件来缩小答案所在的区间，这个就是二分的本质。<br>做好区间的选择<br>双指针：要根据题目的条件来确定快慢指针的位置，循环的条件</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p><img src="/../img/DaiMaSuiXiang_1/203.png"><br>有哑结点</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c]">struct ListNode* removeElements(struct ListNode* head, int val) &#123;<br>    typedef struct ListNode ListNode;<br>    ListNode *shead;<br>    shead = (ListNode*)malloc(sizeof(ListNode));<br>    shead-&gt;next = head;<br>    ListNode *cur = shead;<br>    while(cur-&gt;next != NULL)<br>&#123;<br>        if(cur-&gt;next-&gt;val == val)<br>            &#123;<br>                ListNode *temp = cur-&gt;next;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>                free(temp);<br>&#125;<br>           else<br>&#123;<br>                cur = cur-&gt;next;<br>&#125;<br><br>    &#125;<br>    head = shead-&gt;next;<br>    return head;<br>&#125;<br></code></pre></td></tr></table></figure><p>无哑结点</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c]">struct ListNode* removeElements(struct ListNode* head, int val) &#123;<br>    struct ListNode* temp;<br>    while(head &amp;&amp; head-&gt;val == val)<br>&#123;<br>        temp = head;<br>        head = head-&gt;next;<br>        free(temp);<br>&#125;<br>       struct ListNode* cur = head;<br>    while(cur &amp;&amp; (temp = cur-&gt;next))<br>&#123;<br>    if(temp -&gt;val == val)<br>&#123;<br>        cur-&gt;next = temp-&gt;next;<br>        free(temp);<br>&#125;<br>    else<br>    cur = cur-&gt;next;<br><br>    &#125;<br>    return head;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>总结：有无哑结点的，就是对头节点如何操作的问题。</p><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p><img src="/../img/DaiMaSuiXiang_1/707.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs [c]">typedef struct &#123;<br>    int val;<br>    struct MyLinkedList* next;<br>&#125; MyLinkedList;<br><br>MyLinkedList* myLinkedListCreate() &#123;<br>    MyLinkedList* head = (MyLinkedList *)malloc(sizeof (MyLinkedList));<br>    head-&gt;next = NULL;<br>    return head;<br>&#125;<br><br>int myLinkedListGet(MyLinkedList* obj, int index) &#123;<br>    MyLinkedList *cur = obj-&gt;next;<br>    for (int i = 0; cur != NULL; i++)&#123;<br>        if (i == index)&#123;<br>            return cur-&gt;val;<br>&#125;<br>            else&#123;<br>                cur = cur-&gt;next;<br>&#125;<br>&#125;<br>        return -1;<br>&#125;<br><br>void myLinkedListAddAtHead(MyLinkedList* obj, int val) &#123;<br>    MyLinkedList* nhead = (MyLinkedList*)malloc(sizeof(MyLinkedList));<br>        nhead-&gt;val = val;<br>    nhead-&gt;next = obj-&gt;next;<br>    obj-&gt;next = nhead;<br>&#125;<br>void myLinkedListAddAtTail(MyLinkedList* obj, int val) &#123;<br>    MyLinkedList *cur = obj;<br>    while(cur-&gt;next != NULL)&#123;<br>    cur = cur-&gt;next;<br>&#125;<br>MyLinkedList *ntail = (MyLinkedList *)malloc(sizeof (MyLinkedList));<br>    ntail-&gt;val = val;<br>    ntail-&gt;next = NULL;<br>    cur-&gt;next = ntail;<br>&#125;<br><br>void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) &#123;<br>if (index == 0)&#123;<br>myLinkedListAddAtHead(obj, val);<br>return;<br>&#125;<br>MyLinkedList *cur = obj-&gt;next;<br>for(int count = 1; cur != NULL;count++)&#123;<br>    if(count == index)<br>&#123;<br>        MyLinkedList* new =(MyLinkedList*)malloc(sizeof(MyLinkedList));<br>        new-&gt;val = val;<br>        new-&gt;next = cur-&gt;next;<br>        cur-&gt;next = new;<br>        return;<br>&#125;<br>        else<br>            cur = cur-&gt;next;<br>    &#125;<br>&#125;<br><br>void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) &#123;<br>    if (index == 0)&#123;<br>        MyLinkedList *tmp = obj-&gt;next;<br>    <br>    if (tmp != NULL)&#123;<br>        obj-&gt;next = tmp-&gt;next;<br>        free(tmp);<br>    &#125;<br>    return;<br>&#125;<br>MyLinkedList *cur = obj-&gt;next;<br>    for (int i = 1 ;cur != NULL &amp;&amp; cur-&gt;next != NULL; i++)&#123;<br>        if (i == index)&#123;<br>            MyLinkedList *tmp = cur-&gt;next;<br>        if (tmp != NULL) &#123;<br>            cur-&gt;next = tmp-&gt;next;<br>        free(tmp);<br>&#125;<br>        return;<br>&#125;<br>e       lse&#123;<br>        cur = cur-&gt;next;<br>&#125;<br>&#125;<br><br>&#125;<br><br>void myLinkedListFree(MyLinkedList* obj) &#123;<br><br>    while(obj != NULL)<br>    &#123;<br>        MyLinkedList *tmp = obj;<br>        obj = obj-&gt;next;<br>        free(tmp);<br> <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="206反转链表"><a href="#206反转链表" class="headerlink" title="206反转链表"></a>206反转链表</h3><p><img src="/../img/DaiMaSuiXiang_1/206.png"><br>双指针</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">struct ListNode* reverseList(struct ListNode* head) &#123;<br>    struct ListNode* cur = head;<br>    struct ListNode* pre = NULL;<br>    while(cur)&#123;<br>    struct ListNode* temp;<br>    temp = cur-&gt;next;<br>    cur-&gt;next = pre;<br>    pre = cur;<br>    cur = temp;<br>&#125;<br>    return pre;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">struct ListNode*reverse(struct ListNode* cur,struct ListNode* pre )&#123;<br><br>    if(!cur)<br>        return pre;<br>    struct ListNode* temp = cur-&gt;next;<br>    cur-&gt;next = pre;<br>    return reverse(temp,cur);<br><br>&#125;<br>    struct ListNode* reverseList(struct ListNode* head) &#123;<br>    return reverse(head,NULL);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h2><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p><img src="/../img/DaiMaSuiXiang_1/24.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs [c]">struct ListNode* swapPairs(struct ListNode* head) &#123;<br>    typedef struct ListNode ListNode;<br>    ListNode *fakehead = (ListNode*)malloc(sizeof(ListNode));<br>    fakehead-&gt;next = head;<br>    ListNode* left = fakehead;<br>    ListNode* right = fakehead-&gt;next;<br>    while(left &amp;&amp; right &amp;&amp; right-&gt;next)<br>    &#123;<br>        left-&gt;next = right-&gt;next;<br>        right-&gt;next = left-&gt;next-&gt;next;<br>        left-&gt;next-&gt;next = right; <br>        left = right;<br>        right = left-&gt;next; <br>    &#125;<br>    return fakehead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p><img src="/../img/DaiMaSuiXiang_1/19.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs [c]">/**<br> * Definition for singly-linked list.<br> * struct ListNode &#123;<br> *     int val;<br> *     struct ListNode *next;<br> * &#125;;<br> */<br>struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123;<br>    typedef  struct ListNode ListNode;<br>    ListNode* fakehead=(ListNode*)malloc(sizeof(ListNode));<br>    fakehead-&gt;next = head;<br>    ListNode* fast = fakehead;<br>    ListNode* slow = fakehead;<br>    int count = 0;<br>    for(;count &lt; n+1; count++)&#123;<br>        fast = fast-&gt;next;<br>    &#125;<br>    while(fast)&#123;<br>        fast = fast-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    ListNode* temp;<br>    temp = slow-&gt;next;<br>    slow -&gt;next = slow-&gt;next-&gt;next;<br>    free(temp);<br>    return fakehead-&gt;next;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p><img src="/../img/DaiMaSuiXiang_1/02.07.png"></p><p>思考：</p><p>为什么要对齐链表长度后才进行比较,相差的那一段为什么不会有相同的</p><p>——因为他们有一段共同的长度，所以说，他们相差的那一段中不可能有相同的元素。</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs [c]">ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;<br>    ListNode *l = NULL, *s = NULL;<br>    int lenA = 0, lenB = 0, gap = 0;<br>    // 求出两个链表的长度<br>    s = headA;<br>    while (s) &#123;<br>        lenA ++;<br>        s = s-&gt;next;<br>    &#125;<br>    s = headB;<br>    while (s) &#123;<br>        lenB ++;<br>        s = s-&gt;next;<br>    &#125;<br><br>    // 求出两个链表长度差<br>    if (lenA &gt; lenB) &#123;<br>        l = headA, s = headB;<br>        gap = lenA - lenB;<br>    &#125; else &#123;<br>        l = headB, s = headA;<br>        gap = lenB - lenA;<br>    &#125;<br><br>    // 尾部对齐<br>    while (gap--) l = l-&gt;next;<br>    // 移动，并检查是否有相同的元素<br>    while (l) &#123;<br>        if (l == s) return l;<br>        l = l-&gt;next, s = s-&gt;next;<br>    &#125;<br><br>    return NULL;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><p><img src="/../img/DaiMaSuiXiang_1/142.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [c]">ListNode *detectCycle(ListNode *head) &#123;<br>    ListNode *fast = head, *slow = head;<br>    while (fast &amp;&amp; fast-&gt;next) &#123;<br>        // 这里判断两个指针是否相等，所以移位操作放在前面<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        if (slow == fast) &#123; // 相交，开始找环形入口：分别从头部和从交点出发，找到相遇的点就是环形入口<br>            ListNode *f = fast, *h = head;<br>            while (f != h) f = f-&gt;next, h = h-&gt;next;<br>            return h;<br>        &#125;<br>    &#125;<br>    return NULL;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="day6"><a href="#day6" class="headerlink" title="day6"></a>day6</h2><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p><img src="/../img/DaiMaSuiXiang_1/242.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs [c]">bool isAnagram(char* s, char* t) &#123;<br>    int record[26] = &#123;0&#125;;<br>    for(int i = 0; i &lt; strlen(s);i++)<br>    &#123;<br>        record[s[i] - &#x27;a&#x27;]++;<br>    &#125;<br>    for(int i = 0; i &lt; strlen(t); i++)&#123;<br>        record[t[i] - &#x27;a&#x27;]--;<br>    &#125;<br>    for(int i = 0; i &lt; 26; i++)&#123;<br>        if(record[i] != 0)<br>            return false;<br>    &#125;<br>    return true;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p><img src="/../img/DaiMaSuiXiang_1/349.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs [c]">/**<br> * Note: The returned array must be malloced, assume caller calls free().<br> */<br>int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size,<br>                  int* returnSize) &#123;<br>    int nums1Cnt[1000] = &#123;0&#125;;<br>    int lessSize = nums1Size &lt; nums2Size ? nums1Size : nums2Size;<br>    int* result = (int*)calloc(lessSize, sizeof(int));<br>    int resultIndex = 0;<br> <br>    int i;<br> <br>    /* Calculate the number&#x27;s counts for nums1 array */<br>    for (i = 0; i &lt; nums1Size; i++) &#123;<br>        nums1Cnt[nums1[i]]++;<br>    &#125;<br>    /* Check if the value in nums2 is existing in nums1 count array */<br>    for (i = 0; i &lt; nums2Size; i++) &#123;<br>        if (nums1Cnt[nums2[i]] != 0) &#123;<br>            result[resultIndex] = nums2[i];<br>            resultIndex++;<br>            nums1Cnt[nums2[i]] = 0;<br>        &#125;<br>    &#125;<br>    *returnSize = resultIndex;<br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p><img src="/../img/DaiMaSuiXiang_1/202.png"><br>思路1：要将每一次的结果给记录下来，当有结果再次重复的时候，说明是循环的了，所以用到哈希表</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int getsum(int n)&#123;<br>    int sum = 0;<br>    while(n)&#123;<br>        sum+= (n%10)*(n%10);<br>        n /= 10;<br>    &#125;<br>    return sum;<br>&#125;<br>bool isHappy(int n) &#123;<br>    int sum = getsum(n);<br>    int hash[820] = &#123;0&#125;;<br>    while(sum != 1)&#123;<br>        if(hash[sum] == 1)<br>            return false;<br>        else&#123;<br>            hash[sum]++;<br>        &#125;<br>        sum = getsum(sum);<br>    &#125;<br>    return true;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路二：用双指针，为什么可以用双指针，因为可以将每一次的sum放入链表中，如果是是循环的话，那么就会形成环链，在链表中，学习到了如何找一个环链的入口，所以说这道题可以通过双指针的方法来解决</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int getsum(int n)&#123;<br>    int sum = 0;<br>    while(n)&#123;<br>        sum+= (n%10)*(n%10);<br>        n /= 10;<br>    &#125;<br>    return sum;<br>&#125;<br>bool isHappy(int n) &#123;<br>   int slow = n;<br>    int fast = n;<br> <br>    do &#123;<br>        slow = getsum(slow);<br>        fast = getsum(getsum(fast));<br>    &#125; while (slow != fast);<br> <br>    return (fast == 1);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p><img src="/../img/DaiMaSuiXiang_1/1.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs [c]">    typedef struct &#123;<br>     int key;<br>     int value;<br>     UT_hash_handle hh; // make this structure hashable<br> &#125; map;<br> <br>map* hashMap = NULL;<br> void hashMapAdd(int key, int value)&#123;<br>     map* s;<br>     // key already in the hash?<br>     HASH_FIND_INT(hashMap, &amp;key, s);<br>     if(s == NULL)&#123;<br>         s = (map*)malloc(sizeof(map));<br>         s -&gt; key = key;<br>         HASH_ADD_INT(hashMap, key, s);<br>     &#125;<br>     s -&gt; value = value;<br> &#125;<br> <br>map* hashMapFind(int key)&#123;<br>     map* s;<br>     // *s: output pointer<br>     HASH_FIND_INT(hashMap, &amp;key, s);   <br>     return s;<br> &#125;<br> <br> void hashMapCleanup()&#123;<br>     map* cur, *tmp;<br>     HASH_ITER(hh, hashMap, cur, tmp)&#123;<br>         HASH_DEL(hashMap, cur);<br>         free(cur);<br>     &#125;<br> &#125;<br> <br> void hashPrint()&#123;<br>     map* s;<br>     for(s = hashMap; s != NULL; s=(map*)(s -&gt; hh.next))&#123;<br>         printf(&quot;key %d, value %d\n&quot;, s -&gt; key, s -&gt; value);<br>     &#125;<br> &#125;<br> <br> <br>int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;<br>    int i, *ans;<br>    // hash find result<br>    map* hashMapRes; <br>    hashMap = NULL;<br>    ans = malloc(sizeof(int) * 2);<br> <br>    for(i = 0; i &lt; numsSize; i++)&#123;<br>        // key 代表 nums[i] 的值，value 代表所在 index;<br>        hashMapAdd(nums[i], i);<br>    &#125;<br> <br>    hashPrint();<br> <br>    for(i = 0; i &lt; numsSize; i++)&#123;<br>        hashMapRes = hashMapFind(target - nums[i]);<br>        if(hashMapRes &amp;&amp; hashMapRes -&gt; value != i)&#123;<br>            ans[0] = i;<br>            ans[1] = hashMapRes -&gt; value ;<br>            *returnSize = 2;<br>            return ans;<br>        &#125;<br>    &#125;<br>    <br>    hashMapCleanup();<br>    return NULL;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="day07"><a href="#day07" class="headerlink" title="day07"></a>day07</h2><h3 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><p><img src="/../img/DaiMaSuiXiang_1/454.png"><br>思路：从四个数组中找到四个元素相加等于零，暴力解法就是用四个for循环进行遍历，</p><p>如何用到哈希法呢？</p><p>——可以效仿两数相加这道题，有四个数组，那么就将他们分成两个数组，先遍历数组1，将其变成哈希表</p><p>哈希表的结构是？</p><p>——因为数组内的元素范围很大，所以不可以将将元素映射到数组里面，数组的大小难以确定，并且会浪费大量的内存，然后不仅要储存元素，还要储存出现的次数，所以选择使用map，而不使用set，</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs [c]">struct hashTable &#123;<br>    int key;<br>    int val;<br>    UT_hash_handle hh;<br>&#125;;<br> <br>int fourSumCount(int* A, int ASize, int* B, int BSize, int* C, int CSize, int* D, int DSize) &#123;<br>    struct hashTable* hashtable = NULL;<br>    for (int i = 0; i &lt; ASize; ++i) &#123;<br>        for (int j = 0; j &lt; BSize; ++j) &#123;<br>            int ikey = A[i] + B[j];<br>            struct hashTable* tmp;<br>            HASH_FIND_INT(hashtable, &amp;ikey, tmp);<br>            if (tmp == NULL) &#123;<br>                struct hashTable* tmp = malloc(sizeof(struct hashTable));<br>                tmp-&gt;key = ikey, tmp-&gt;val = 1;<br>                HASH_ADD_INT(hashtable, key, tmp);<br>            &#125; else &#123;<br>                tmp-&gt;val++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    int ans = 0;<br>    for (int i = 0; i &lt; CSize; ++i) &#123;<br>        for (int j = 0; j &lt; DSize; ++j) &#123;<br>            int ikey = -C[i] - D[j];<br>            struct hashTable* tmp;<br>            HASH_FIND_INT(hashtable, &amp;ikey, tmp);<br>            if (tmp != NULL) &#123;<br>                ans += tmp-&gt;val;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p><img src="/../img/DaiMaSuiXiang_1/383.png"><br>思路：和有效字母异位的解题大体一样，但是，这道题是将两个数组都变成哈希表，然后才进行比较他们的值，如果ransomNote大于magazine，那么就返回false,</p><p>为什么不能和有效字母异位一样，只一个哈希表，然后对哈希表进行减值操作呢？</p><p>——数组2的值可能会超过数组一的值，那么就会出现一种情况，数值一的值会变成负数，那么就会返回false了</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs [c]">bool canConstruct(char* ransomNote, char* magazine) &#123;<br>    int record1[26] = &#123;0&#125;;<br>    int record2[26] = &#123;0&#125;;<br>    for(int i = 0; i &lt; strlen(ransomNote); i++)&#123;<br>        record[ransomNote[i] - &#x27;a&#x27;]++;<br>    &#125;<br>    for(int i = 0; i &lt; strlen(magazine); i++)&#123;<br>        record[magazine[i] - &#x27;a&#x27;]++;<br> <br>    &#125;<br>    for(int i =0; i &lt;strlen(record); i++)&#123;<br>        if(record1[i] &gt; record2[i])<br>            return false;<br>    &#125;<br>    return true;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><p><img src="/../img/DaiMaSuiXiang_1/15.png"><br>思路：可以用三个for遍历三个数组，枚举出每一种可能出现的情况，</p><p>为什么不采用哈希表，而是用双指针？</p><p>——这道题目和两数之和的区别在于，要进行去重，而对三个数组去重，难度并不小，</p><p>为什么用双指针？</p><p>——a+b+c可以看成a+(b+c)，把b和c看做一个整体，然后和a进行比较，然后这里就和长度最小的子数组一样，这里滑动窗口是向内收缩</p><p>为什么要进行排序？</p><p>——因为要进行去重操作，排序可以减少去重的操作</p><p>a的去重为什么是nums[i]&#x3D;&#x3D;nums[i-1]不是nums[i]&#x3D;&#x3D;nums[i+1]</p><p>——前者是向前检查是否有重复，而后者相反，题目要求的是没有重复的三元组，但是里面的元素是可以相同的，所以如果是向后去重的话，那么就有些情况被删去了</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs [c]">//qsort辅助cmp函数<br>int cmp(const void* ptr1, const void* ptr2) &#123;<br>    return *((int*)ptr1) &gt; *((int*)ptr2);<br>&#125;<br> <br>int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) &#123;<br>    //开辟ans数组空间<br>    int **ans = (int**)malloc(sizeof(int*) * 18000);<br>    int ansTop = 0;<br>    //若传入nums数组大小小于3，则需要返回数组大小为0<br>    if(numsSize &lt; 3) &#123;<br>        *returnSize = 0;<br>        return ans;<br>    &#125;<br>    //对nums数组进行排序<br>    qsort(nums, numsSize, sizeof(int), cmp);<br>    <br> <br>    int i;<br>    //用for循环遍历数组，结束条件为i &lt; numsSize - 2(因为要预留左右指针的位置)<br>    for(i = 0; i &lt; numsSize - 2; i++) &#123;<br>        //若当前i指向元素&gt;0，则代表left和right以及i的和大于0。直接break<br>        if(nums[i] &gt; 0)<br>            break;<br>        //去重：i &gt; 0 &amp;&amp; nums[i] == nums[i-1]<br>        if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1])<br>            continue;<br>        //定义左指针和右指针<br>        int left = i + 1;<br>        int right = numsSize - 1;<br>        //当右指针比左指针大时进行循环<br>        while(right &gt; left) &#123;<br>            //求出三数之和<br>            int sum = nums[right] + nums[left] + nums[i];<br>            //若和小于0，则左指针+1（因为左指针右边的数比当前所指元素大）<br>            if(sum &lt; 0)<br>                left++;<br>            //若和大于0，则将右指针-1<br>            else if(sum &gt; 0)<br>                right--;<br>            //若和等于0<br>            else &#123;<br>                //开辟一个大小为3的数组空间，存入nums[i], nums[left]和nums[right]<br>                int* arr = (int*)malloc(sizeof(int) * 3);<br>                arr[0] = nums[i];<br>                arr[1] = nums[left];<br>                arr[2] = nums[right];<br>                //将开辟数组存入ans中<br>                ans[ansTop++] = arr;<br>                //去重<br>                while(right &gt; left &amp;&amp; nums[right] == nums[right - 1])<br>                    right--;<br>                while(left &lt; right &amp;&amp; nums[left] == nums[left + 1])<br>                    left++;<br>                //更新左右指针<br>                left++;<br>                right--;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    //设定返回的数组大小<br>    *returnSize = ansTop;<br>    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);<br>    int z;<br>    for(z = 0; z &lt; ansTop; z++) &#123;<br>        (*returnColumnSizes)[z] = 3;<br>    &#125;<br>    return ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="18四数之和"><a href="#18四数之和" class="headerlink" title=":18四数之和"></a>:18四数之和</h3><p><img src="/../img/DaiMaSuiXiang_1/18.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int comp(const void* a, const void* b) &#123;<br>    return *(int*)a - *(int*)b;<br>&#125;<br> <br>int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) &#123;<br>    int** quadruplets = malloc(sizeof(int*) * 1001);<br>    *returnSize = 0;<br>    *returnColumnSizes = malloc(sizeof(int) * 1001);<br>    if (numsSize &lt; 4) &#123;<br>        return quadruplets;<br>    &#125;<br>    qsort(nums, numsSize, sizeof(int), comp);<br>    int length = numsSize;<br>    for (int i = 0; i &lt; length - 3; i++) &#123;<br>        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;<br>            continue;<br>        &#125;<br>        if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123;<br>            break;<br>        &#125;<br>        if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) &#123;<br>            continue;<br>        &#125;<br>        for (int j = i + 1; j &lt; length - 2; j++) &#123;<br>            if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;<br>                continue;<br>            &#125;<br>            if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) &#123;<br>                break;<br>            &#125;<br>            if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) &#123;<br>                continue;<br>            &#125;<br>            int left = j + 1, right = length - 1;<br>            while (left &lt; right) &#123;<br>                long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];<br>                if (sum == target) &#123;<br>                    int* tmp = malloc(sizeof(int) * 4);<br>                    tmp[0] = nums[i], tmp[1] = nums[j], tmp[2] = nums[left], tmp[3] = nums[right];<br>                    (*returnColumnSizes)[(*returnSize)] = 4;<br>                    quadruplets[(*returnSize)++] = tmp;<br>                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;<br>                        left++;<br>                    &#125;<br>                    left++;<br>                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;<br>                        right--;<br>                    &#125;<br>                    right--;<br>                &#125; else if (sum &lt; target) &#123;<br>                    left++;<br>                &#125; else &#123;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return quadruplets;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="day9"><a href="#day9" class="headerlink" title="day9"></a>day9</h2><h3 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h3><p>什么是kmp算法？</p><p>——这是一个解决字符串匹配的一个算法</p><p>例子：</p><p>文本串:aabaabaaf</p><p>模式串：aabaaf</p><p>暴力解法：两层for循环，第一层遍历第文本串，第二层，遍历模式串，逐个匹配，当遇到不匹配的时候，重新匹配</p><p>重新匹配是指：文本串中的指针会跳，回到起始位置的下一个位置，然后重新开始匹配</p><p>kmp算法：就是一次遍历中，在文本串中找到模式串</p><p>原理是？</p><p>——在暴力破解中，我们是回到初始位置的下一个字符串开始，但是我们已经遍历过的字符串中可能会出现重复的元素，那么我们就可以跳过它，</p><p>我认为这道题也是双指针的一种用法，也可以说kmp算法是双指针的一种用法</p><p>——一个指针是文本字符串的，另外一个是模式字符串的，而暴力解法中呢，就是第一个指针不是一直往前走，而是遇到不同的时候，两个指针都往回跳，</p><p>而kmp则是第一个指针只往前走，而第二个指针回跳</p><p>我们如何知道要跳过多少？看什么？</p><p>——我们需要一个前缀表来记录，每一个字符串的最长相等前后缀（的长度）是多少，我们要看不相同元素的前一个元素的最长相等前后缀是多少，</p><p>前缀是指除尾字符串以外的所有子字符串</p><p>后缀是除首元素之外所有字符串</p><p>为什么这样子可以？</p><p>——因为第一个指针不动，第二个指针是取第一个指针前一个的最长相等前后缀第二个指针的起始位置，这个长度实际是指第二个指针在模式串跳过多少个元素后进行比较，因为是相等前后缀的原因，所以说，这跳过的x个元素，必定会和第一指针前的x个元素相等</p><h2 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h2><h3 id="232用栈实现队列"><a href="#232用栈实现队列" class="headerlink" title="232用栈实现队列"></a>232用栈实现队列</h3><p><img src="/../img/DaiMaSuiXiang_1/232.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs [c]">typedef struct &#123;<br>    int stackInTop, stackOutTop;<br>    int stackin[100], stackout[100];<br>&#125; MyQueue;<br> <br> <br>MyQueue* myQueueCreate() &#123;<br>    MyQueue* queue = (MyQueue*)malloc(sizeof(MyQueue));<br>    queue-&gt;stackInTop = 0;<br>    queue-&gt;stackOutTop = 0;<br>    return queue;<br>&#125;<br> <br>void myQueuePush(MyQueue* obj, int x) &#123;<br>    obj-&gt;stackin[(obj-&gt;stackInTop)++] = x;<br>&#125;<br> <br>int myQueuePop(MyQueue* obj) &#123;<br>    int stackInTop = obj-&gt;stackInTop;<br>    int stackOutTop = obj-&gt;stackOutTop;<br> <br>    if(stackOutTop == 0)&#123;<br>        while(stackInTop &gt; 0)&#123;<br>            obj-&gt;stackout[stackOutTop++] = obj-&gt;stackin[--stackInTop];<br>        &#125;       <br>    <br>    &#125;<br>    int top = obj-&gt;stackout[--stackOutTop];<br>    while(stackOutTop &gt; 0)<br>        obj-&gt;stackin[stackInTop++] = obj-&gt;stackout[--stackOutTop];<br>    <br>    obj-&gt;stackInTop = stackInTop;<br>    obj-&gt;stackOutTop = stackOutTop;<br>    return top;<br>&#125;<br> <br>int myQueuePeek(MyQueue* obj) &#123;<br>    return obj-&gt;stackin[0];<br>&#125;<br> <br>bool myQueueEmpty(MyQueue* obj) &#123;<br>    return obj-&gt;stackInTop == 0  &amp;&amp; obj-&gt;stackOutTop == 0;<br>&#125;<br> <br>void myQueueFree(MyQueue* obj) &#123;<br>    obj-&gt;stackInTop = 0;<br>    obj-&gt;stackOutTop = 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h3><p><img src="/../img/DaiMaSuiXiang_1/225.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs [c]">typedef struct &#123;<br>    int queue[100];<br>    int front;<br>    int rear;<br>&#125; MyStack;<br> <br>MyStack* myStackCreate() &#123;<br>    MyStack* stack = (MyStack*)malloc(sizeof(MyStack));<br>    stack-&gt;front = 0;<br>    stack-&gt;rear = 0;<br>    return stack;<br>&#125;<br> <br>void myStackPush(MyStack* obj, int x) &#123; obj-&gt;queue[(obj-&gt;rear)++] = x; &#125;<br> <br>int myStackPop(MyStack* obj) &#123;<br>    int front = obj-&gt;front;<br>    int rear = obj-&gt;rear;<br> <br>    int size = rear - front;<br>    while (size-- &gt; 1) &#123;<br>        obj-&gt;queue[rear++] = obj-&gt;queue[front++];<br>    &#125;<br>    int top = obj-&gt;queue[front++];<br> <br>    obj-&gt;front = front;<br>    obj-&gt;rear = rear;<br>    return top;<br>&#125;<br> <br>int myStackTop(MyStack* obj) &#123;return obj-&gt;queue[(obj-&gt;rear) - 1];&#125;<br> <br>bool myStackEmpty(MyStack* obj) &#123; return obj-&gt;rear == obj-&gt;front; &#125;<br> <br>void myStackFree(MyStack* obj) &#123;<br>    obj-&gt;front = 0;<br>    obj-&gt;rear = 0;<br>&#125;<br> <br>/**<br> * Your MyStack struct will be instantiated and called as such:<br> * MyStack* obj = myStackCreate();<br> * myStackPush(obj, x);<br> * int param_2 = myStackPop(obj);<br> * int param_3 = myStackTop(obj);<br> * bool param_4 = myStackEmpty(obj);<br> * myStackFree(obj);<br>*/<br></code></pre></td></tr></table></figure><h2 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p><img src="/../img/DaiMaSuiXiang_1/20.png"><br>第一种是左括号多了</p><p>——当遍历完字符串后栈里面还有元素</p><p>第二种是左右不匹配</p><p>——字符与栈顶元素不匹配</p><p>第三种是右括号多了</p><p>——栈的长度为零了，还有字符串中右方向括号还没有遍历完</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int notMatch(char par, char* stack, int stackTop) &#123;<br>    switch(par) &#123;<br>        case &#x27;]&#x27;:<br>            return stack[stackTop - 1] != &#x27;[&#x27;;<br>        case &#x27;)&#x27;:<br>            return stack[stackTop - 1] != &#x27;(&#x27;;<br>        case &#x27;&#125;&#x27;:<br>            return stack[stackTop - 1] != &#x27;&#123;&#x27;;<br>    &#125;<br>    return 0;<br>&#125;<br> <br>bool isValid(char * s)&#123;<br>    int strLen = strlen(s);<br>    //开辟栈空间<br>    char stack[5000];<br>    int stackTop = 0;<br> <br>    //遍历字符串<br>    int i;<br>    for(i = 0; i &lt; strLen; i++) &#123;<br>        //取出当前下标所对应字符<br>        char tempChar = s[i];<br>        //若当前字符为左括号，则入栈<br>        if(tempChar == &#x27;(&#x27; || tempChar == &#x27;[&#x27; || tempChar == &#x27;&#123;&#x27;)<br>            stack[stackTop++] = tempChar;<br>        //若当前字符为右括号，且栈中无元素或右括号与栈顶元素不符，返回False<br>        else if(stackTop == 0 || notMatch(tempChar, stack, stackTop))<br>            return 0;<br>        //当前字符与栈顶元素为一对括号，将栈顶元素出栈<br>        else<br>            stackTop--;<br>    &#125;<br>    //若栈中有元素，返回False。若没有元素（stackTop为0），返回True<br>    return !stackTop;<br>&#125;<br></code></pre></td></tr></table></figure><p>notMatch中为什么栈顶元素要减1</p><p>——因为代码中使用了后加加的操作，所以说stackTop其实是指向了下一位元素了</p><h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><p><img src="/../img/DaiMaSuiXiang_1/1047.png"><br>方法一（栈）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs [c]bush">char* removeDuplicates(char* s) &#123;<br>    int strlength = strlen(s);<br> <br>    char* stack = (char*)malloc(sizeof(char)*strlength + 1);<br>    int stackTop = 0;<br> <br>    int index = 0;<br>    while(index &lt; strlength)&#123;<br>        char letter = s[index++];<br> <br>        if(stackTop &gt; 0 &amp;&amp; letter == stack[stackTop - 1] )&#123;<br>            stackTop--;<br>        &#125;<br>        else <br>            stack[stackTop++] = letter;<br>        <br>        stack[stackTop] = &#x27;\0&#x27;;<br>      <br>    &#125;<br>      return stack;<br>    &#125;<br></code></pre></td></tr></table></figure><p>方法二（双指针）</p><p>这道题可以看作是移除元素的题目，与数组不一样的地方是字符串以’\0’结尾的，</p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs [c]">char* removeDuplicates(char* s) &#123;<br>    int fast = 0;<br>    int slow = 0; <br>    <br>    int strlength = strlen(s);<br>    while(fast &lt; strlength)<br>    &#123;<br>        char letter = s[slow] = s[fast++];<br>        if(slow &gt; 0 &amp;&amp; letter == s[slow - 1])<br>            slow--;<br>        else<br>            slow++;<br>        <br>    &#125;<br>    s[slow] = &#x27;\0&#x27;;<br>    return s;<br>&#125;<br> <br></code></pre></td></tr></table></figure><h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p><img src="/../img/DaiMaSuiXiang_1/150.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int evalRPN(char** tokens, int tokensSize) &#123;<br>   long long stack[MAX_TOKENS];  <br>    int top = -1; <br>    for (int i = 0; i &lt; tokensSize; i++) &#123;  <br>        if (strcmp(tokens[i], &quot;+&quot;) == 0 || strcmp(tokens[i], &quot;-&quot;) == 0 ||  <br>            strcmp(tokens[i], &quot;*&quot;) == 0 || strcmp(tokens[i], &quot;/&quot;) == 0) &#123;  <br>            long long num1 = stack[top--]; <br>            long long num2 = stack[top--]; <br>  <br>            if (strcmp(tokens[i], &quot;+&quot;) == 0) stack[++top] = num2 + num1;  <br>            if (strcmp(tokens[i], &quot;-&quot;) == 0) stack[++top] = num2 - num1;  <br>            if (strcmp(tokens[i], &quot;*&quot;) == 0) stack[++top] = num2 * num1;  <br>            if (strcmp(tokens[i], &quot;/&quot;) == 0) stack[++top] = num2 / num1; <br>        &#125; else &#123;  <br>            stack[++top] = atoi(tokens[i]); <br>        &#125;  <br>    &#125;  <br>  <br> <br>    return stack[top];  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h2><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h3><p><img src="/../img/DaiMaSuiXiang_1/239.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) &#123;<br>    int n = numsSize;<br>    int queue[n]; //队列<br>    int front = 0, rear = -1; //队首 队尾<br>    int left = 0, right = 0; //窗口左下标 窗口右下标<br>    while (right &lt; n) &#123; //窗口右移至终点<br>        while (rear &gt;= front &amp;&amp; nums[right] &gt; queue[rear]) rear--; //维护队列的单调性（非递增），即保证队首元素就是当前窗口的最大值<br>        queue[++rear] = nums[right++]; //入队下一个窗口可能的最大值<br>        if (left + k &lt;= right) &#123; //窗口大小大于k<br>            if (nums[left] == queue[front]) front++; //如果最大值已经在窗口的左边，则将它永久出队<br>            else nums[left] = queue[front]; //否则记录最大值进原数组中<br>            left++; //左框右移<br>        &#125;<br>    &#125;<br>    *returnSize = n - k + 1;<br>    return nums; //返回原数组<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><p><img src="/../img/DaiMaSuiXiang_1/347.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs [c]">struct hash_table &#123;<br>    int key;<br>    int val;<br>    UT_hash_handle hh;<br>&#125;;<br><br>typedef struct hash_table* hash_ptr;<br><br>struct pair &#123;<br>    int first;<br>    int second;<br>&#125;;<br><br>struct pair* heap;<br>int heapSize;<br><br>void swap(struct pair* a, struct pair* b) &#123;<br>    struct pair t = *a;<br>    *a = *b, *b = t;<br>&#125;<br><br>bool cmp(struct pair* a, struct pair* b) &#123;<br>    return a-&gt;second &lt; b-&gt;second;<br>&#125;<br><br>struct pair top() &#123;<br>    return heap[1];<br>&#125;<br><br>int push(hash_ptr x) &#123;<br>    heap[++heapSize].first = x-&gt;key;<br>    heap[heapSize].second = x-&gt;val;<br>    int p = heapSize, s;<br>    while (p &gt; 1) &#123;<br>        s = p &gt;&gt; 1;<br>        if (cmp(&amp;heap[s], &amp;heap[p])) return;<br>        swap(&amp;heap[p], &amp;heap[s]);<br>        p = s;<br>    &#125;<br>&#125;<br><br>int pop() &#123;<br>    heap[1] = heap[heapSize--];<br>    int p = 1, s;<br>    while ((p &lt;&lt; 1) &lt;= heapSize) &#123;<br>        s = p &lt;&lt; 1;<br>        if (s &lt; heapSize &amp;&amp; cmp(&amp;heap[s + 1], &amp;heap[s])) s++;<br>        if (cmp(&amp;heap[p], &amp;heap[s])) return;<br>        swap(&amp;heap[p], &amp;heap[s]);<br>        p = s;<br>    &#125;<br>&#125;<br><br>int* topKFrequent(int* nums, int numsSize, int k, int* returnSize) &#123;<br>    hash_ptr head = NULL;<br>    hash_ptr p = NULL, tmp = NULL;<br><br>    for (int i = 0; i &lt; numsSize; i++) &#123;<br>        HASH_FIND_INT(head, &amp;nums[i], p);<br>        if (p == NULL) &#123;<br>            p = malloc(sizeof(struct hash_table));<br>            p-&gt;key = nums[i];<br>            p-&gt;val = 1;<br>            HASH_ADD_INT(head, key, p);<br>        &#125; else &#123;<br>            p-&gt;val++;<br>        &#125;<br>    &#125;<br><br>    heap = malloc(sizeof(struct pair) * (k + 1));<br>    heapSize = 0;<br><br>    HASH_ITER(hh, head, p, tmp) &#123;<br>        if (heapSize == k) &#123;<br>            struct pair tmp = top();<br>            if (tmp.second &lt; p-&gt;val) &#123;<br>                pop();<br>                push(p);<br>            &#125;<br>        &#125; else &#123;<br>            push(p);<br>        &#125;<br>    &#125;<br>    *returnSize = k;<br>    int* ret = malloc(sizeof(int) * k);<br>    for (int i = 0; i &lt; k; i++) &#123;<br>        struct pair tmp = top();<br>        pop();<br>        ret[i] = tmp.first;<br>    &#125;<br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="day14"><a href="#day14" class="headerlink" title="day14"></a>day14</h2><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h4><p><img src="/../img/DaiMaSuiXiang_1/144.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs [c]">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     struct TreeNode *left;<br> *     struct TreeNode *right;<br> * &#125;;<br> */<br>/**<br> * Note: The returned array must be malloced, assume caller calls free().<br> */<br> void preOder(struct TreeNode* root, int* ret, int *returnSize)&#123;<br>     if(root == NULL)<br>        return;<br>    ret[(*returnSize)++] = root-&gt;val;<br>    preOder(root-&gt;left, ret, returnSize);<br>    preOder(root-&gt;right, ret, returnSize);<br>     <br> &#125;<br>int* preorderTraversal(struct TreeNode* root, int* returnSize) &#123;<br>    int* ret = (int*)malloc(sizeof(int)*100);<br>    *returnSize = 0;<br>    preOder(root, ret, returnSize);<br>    return ret;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h4><p><img src="/../img/DaiMaSuiXiang_1/145.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs [c]">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     struct TreeNode *left;<br> *     struct TreeNode *right;<br> * &#125;;<br> */<br>/**<br> * Note: The returned array must be malloced, assume caller calls free().<br> */ <br>void postOder(struct TreeNode* root, int* ret, int* returnSize)&#123;<br>    if(root == NULL)<br>        return;<br>    postOder(root-&gt;left, ret, returnSize);<br>    postOder(root-&gt;right,ret, returnSize);<br>    ret[(*returnSize)++] = root-&gt;val;<br>&#125;<br>int* postorderTraversal(struct TreeNode* root, int* returnSize) &#123;<br>    int* ret = (int*)malloc(sizeof(int)*100);<br>    *returnSize = 0;<br>    postOder(root,ret, returnSize);<br>    return  ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h4><p><img src="/../img/DaiMaSuiXiang_1/94.png"></p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs [c]">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     struct TreeNode *left;<br> *     struct TreeNode *right;<br> * &#125;;<br> */<br>/**<br> * Note: The returned array must be malloced, assume caller calls free().<br> */<br> void inOder(struct TreeNode* root, int* ret, int* returnSize)&#123;<br>     if(root == NULL)<br>      return;<br>    inOder(root-&gt;left, ret, returnSize);<br>    ret[(*returnSize)++] = root-&gt;val;<br>    inOder(root-&gt;right, ret, returnSize);<br> &#125;<br>int* inorderTraversal(struct TreeNode* root, int* returnSize) &#123;<br>    int* ret = (int*)malloc(sizeof(int)*100);<br>    *returnSize = 0;<br>     inOder(root, ret, returnSize);<br>     return ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><h4 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h4><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int* preorderTraversal(struct TreeNode* root, int* returnSize) &#123;<br>    int* res = malloc(sizeof(int) * 2000);<br>    *returnSize = 0;<br>    if (root == NULL) &#123;<br>        return res;<br>    &#125;<br> <br>    struct TreeNode* stk[2000];<br>    struct TreeNode* node = root;<br>    int stk_top = 0;<br>    while (stk_top &gt; 0 || node != NULL) &#123;<br>        while (node != NULL) &#123;<br>            res[(*returnSize)++] = node-&gt;val;<br>            stk[stk_top++] = node;<br>            node = node-&gt;left;<br>        &#125;<br>        node = stk[--stk_top];<br>        node = node-&gt;right;<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h4><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int *postorderTraversal(struct TreeNode *root, int *returnSize) &#123;<br>    int *res = malloc(sizeof(int) * 2001);<br>    *returnSize = 0;<br>    if (root == NULL) &#123;<br>        return res;<br>    &#125;<br>    struct TreeNode **stk = malloc(sizeof(struct TreeNode *) * 2001);<br>    int top = 0;<br>    struct TreeNode *prev = NULL;<br>    while (root != NULL || top &gt; 0) &#123;<br>        while (root != NULL) &#123;<br>            stk[top++] = root;<br>            root = root-&gt;left;<br>        &#125;<br>        root = stk[--top];<br>        if (root-&gt;right == NULL || root-&gt;right == prev) &#123;<br>            res[(*returnSize)++] = root-&gt;val;<br>            prev = root;<br>            root = NULL;<br>        &#125; else &#123;<br>            stk[top++] = root;<br>            root = root-&gt;right;<br>        &#125;<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h4><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs [c]">int* inorderTraversal(struct TreeNode* root, int* returnSize) &#123;<br>    *returnSize = 0;<br>    int* res = malloc(sizeof(int) * 501);<br>    struct TreeNode** stk = malloc(sizeof(struct TreeNode*) * 501);<br>    int top = 0;<br>    while (root != NULL || top &gt; 0) &#123;<br>        while (root != NULL) &#123;<br>            stk[top++] = root;<br>            root = root-&gt;left;<br>        &#125;<br>        root = stk[--top];<br>        res[(*returnSize)++] = root-&gt;val;<br>        root = root-&gt;right;<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="day15"><a href="#day15" class="headerlink" title="day15"></a>day15</h3>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>明解C语言课后练习</title>
    <link href="/2024/09/15/MingJieC-exerices/"/>
    <url>/2024/09/15/MingJieC-exerices/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>printf(&quot;15减去37的结果是%d&quot;,15-37);he<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>printf(&quot;15减去37的结果是%d&quot;,15-37);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>printf(&quot;喂\n&quot;);<br>printf(&quot;      \n&quot;);<br>printf(&quot;您好\n&quot;);<br>printf(&quot;再见。\n&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main() &#123;<br>    int a = 3.14;<br>    printf(&quot;输出a的值：%d&quot;, a);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>int是整数型的 小数点后面的会被忽略 只保留整数部分 </p><h3 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main ()&#123;<br>    int a;<br>    printf(&quot;请输入一个整数：&quot;,a);<br>    scanf(&quot;%d&quot;,&amp;a);<br>    printf(&quot;该整数加去12的结果是:%d&quot;,a+6);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main ()&#123;<br>    int a;<br>    printf(&quot;请输入一个整数：&quot;,a);<br>    scanf(&quot;%d&quot;,&amp;a);<br>    printf(&quot;该整数减去6的结果是:%d&quot;,a-6);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>    puts(&quot;天&quot;);<br>    puts(&quot;地&quot;);<br>    puts(&quot;人&quot;);<br>    return  0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b;<br>int c;<br>puts(&quot;请输入两个整数：&quot;);<br>printf(&quot;整数1:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数2:&quot;);    scanf(&quot;%d&quot;,&amp;b);<br>c=a*b;<br>printf(&quot;他们的乘积是：%d&quot;,c);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-9"><a href="#1-9" class="headerlink" title="1.9"></a>1.9</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b,c;<br>int d;<br>puts(&quot;请输入两个整数：&quot;);<br>printf(&quot;整数1:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数2:&quot;);    scanf(&quot;%d&quot;,&amp;b);<br>printf(&quot;整数3:&quot;);    scanf(&quot;%d&quot;,&amp;c);<br>d=a+b+c;<br>printf(&quot;他们的和是：%d&quot;,d);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b;<br><br>puts(&quot;请输入两个整数：&quot;);<br>printf(&quot;整数1:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数2:&quot;);    scanf(&quot;%d&quot;,&amp;b);<br>printf(&quot;a的值是b的值的%d%%&quot;,(a*100)/b);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b;<br>puts(&quot;请输入两个整数：&quot;);<br>printf(&quot;整数1:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数2:&quot;);    scanf(&quot;%d&quot;,&amp;b);<br>printf(&quot;他们的和是%d,积是%d&quot;,a+b,a*b);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>    double a;<br>   <br>printf(&quot;请输入一个实数：&quot;);    scanf(&quot;%lf&quot;,&amp;a);<br>    printf(&quot;你输入的是%lf&quot;,a);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()<br>&#123;<br>int n = 0;<br>double m = 0;<br>n = 10 / 2;<br>m = 10.0 / 2.0;<br>printf(&quot;整型常量除：%d\n&quot;, 10 / 2);<br>printf(&quot;浮点型常量除：%f\n&quot;, 10.0 / 2.0);<br>printf(&quot;int型常量除：%d\n&quot;, n);<br>printf(&quot;double型常量除：%f\n&quot;, m);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b;<br><br>puts(&quot;请输入两个整数：&quot;);<br>printf(&quot;整数1:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数2:&quot;);    scanf(&quot;%d&quot;,&amp;b);<br>printf(&quot;a的值是b的值的%f%%&quot;,(double)(a*100)/b);<br>return 0;&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6"><a href="#2-6" class="headerlink" title="2.6"></a>2.6</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>    int a;<br>    printf(&quot;请输入你的身高:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>    printf(&quot;您的标准体重是%。lf公斤&quot;,(a-100)*0.9);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3-1"></a>3-1</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b;<br>printf(&quot;整数a:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数b:&quot;);    scanf(&quot;%d&quot;,&amp;b);<br>if(a/b)<br>puts(&quot;b不是a的约数&quot;);<br>else<br>puts(&quot;b是a的约数&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2"><a href="#3-2" class="headerlink" title="3-2"></a>3-2</h3><p>结果变得相反 </p><h3 id="3-3"><a href="#3-3" class="headerlink" title="3-3"></a>3-3</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a;<br>printf(&quot;整数a:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>if(a==0)<br>printf(&quot;绝对值是0&quot;);<br>else if(a&gt;0)<br>printf(&quot;绝对值是%d&quot;,a);<br>else<br>printf(&quot;绝对值是%d&quot;,-a);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4"><a href="#3-4" class="headerlink" title="3-4"></a>3-4</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b;<br>printf(&quot;整数a:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数b:&quot;);    scanf(&quot;%d&quot;,&amp;b);<br>if(a==b)<br>printf(&quot;a和b相等&quot;);<br>else if(a&gt;b)<br>printf(&quot;a大于b&quot;);<br>else<br>printf(&quot;a小于b&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5"><a href="#3-5" class="headerlink" title="3-5"></a>3-5</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()<br>&#123;<br>int a = 2;<br>int b = 3;<br><br>    printf(&quot;%d\n&quot;, a &gt; b);<br>    printf(&quot;%d\n&quot;, a &lt; b);<br>    printf(&quot;%d\n&quot;, a == b);<br>    printf(&quot;%d\n&quot;, a != b);<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6"><a href="#3-6" class="headerlink" title="3-6"></a>3-6</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b,c,min;<br>puts(&quot;请输入三个整数。&quot;);<br>printf(&quot;整数a:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数b:&quot;);    scanf(&quot;%d&quot;,&amp;b);<br>printf(&quot;整数c:&quot;);    scanf(&quot;%d&quot;,&amp;c);<br>min=a;<br>if(b&lt;min)  min=b;<br>if(c&lt;min)  min=c;<br>printf(&quot;他们的最小值是%d&quot;,min);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-7"><a href="#3-7" class="headerlink" title="3-7"></a>3-7</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b,c,d,max;<br>puts(&quot;请输入四个整数。&quot;);<br>printf(&quot;整数a:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数b:&quot;);    scanf(&quot;%d&quot;,&amp;b);<br>printf(&quot;整数c:&quot;);    scanf(&quot;%d&quot;,&amp;c);<br>printf(&quot;整数d:&quot;);    scanf(&quot;%d&quot;,&amp;d);<br>max=a;<br>if(b&gt;max)  max=b;<br>if(c&gt;max)  max=c;<br>if(d&gt;max)  max=d;<br>printf(&quot;他们的最大值是%d&quot;,max);<br>return 0;<br></code></pre></td></tr></table></figure><h3 id="3-8"><a href="#3-8" class="headerlink" title="3-8"></a>3-8</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int n1,n2;<br>puts(&quot;请输入两个整数&quot;);<br>printf(&quot;整数n1：&quot;);   scanf(&quot;%d&quot;,&amp;n1);<br>printf(&quot;整数n2：&quot;);   scanf(&quot;%d&quot;,&amp;n2);<br>if(n1&gt;n2)<br>printf(&quot;他们的差是%d&quot;,n1-n2);<br>else<br>printf(&quot;他们的差是%d&quot;,n2-n1);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-9"><a href="#3-9" class="headerlink" title="3-9"></a>3-9</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int n1,n2;<br>puts(&quot;请输入两个整数&quot;);<br>printf(&quot;整数n1：&quot;);   scanf(&quot;%d&quot;,&amp;n1);<br>printf(&quot;整数n2：&quot;);   scanf(&quot;%d&quot;,&amp;n2);<br>n1==n2?printf(&quot;他们是相等数&quot;):printf(&quot;他们不是相等数&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-10"><a href="#3-10" class="headerlink" title="3-10"></a>3-10</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b,c,min;<br>puts(&quot;请输入三个整数。&quot;);<br>printf(&quot;整数a:&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数b:&quot;);    scanf(&quot;%d&quot;,&amp;b);<br>printf(&quot;整数c:&quot;);    scanf(&quot;%d&quot;,&amp;c);<br>if(a==b&amp;&amp;a==c)<br>printf(&quot;三个值相等&quot;);<br>else if(a!=b&amp;&amp;a!=c&amp;a!=c)<br>printf(&quot;三个值不相等&quot;);<br>else<br>printf(&quot;有两个值相等&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-11"><a href="#3-11" class="headerlink" title="3-11"></a>3-11</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b;<br>puts(&quot;请输入两个整数&quot;);<br>printf(&quot;整数a:&quot;);   scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数b:&quot;);   scanf(&quot;%d&quot;,&amp;b);<br>if(a-b&lt;=10||b-a&lt;=10)<br>printf(&quot;他们的差小于10&quot;);<br>else<br>printf(&quot;他们的差大于10&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-12"><a href="#3-12" class="headerlink" title="3-12"></a>3-12</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main() &#123;<br>int no, a;<br>printf(&quot;请输入一个整数：&quot;);   scanf(&quot;%d&quot;, &amp;no);<br>a=no%2;<br>switch (a)&#123;<br>case 0:puts(&quot;输入的整数是偶数&quot;);     break;<br>case 1:puts(&quot;输入的整数是奇数&quot;);     break;<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-13"><a href="#3-13" class="headerlink" title="3-13"></a>3-13</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include&lt;stdio.h&gt;<br>int main()<br>&#123;<br>int month;<br>printf(&quot;请输入月份：&quot;); scanf(&quot;%d&quot;, &amp;month);<br>switch (month)<br>&#123;<br>case 1:printf(&quot;%d月是冬季&quot;, month); break;<br>case 2:printf(&quot;%d月是冬季&quot;,month); break;<br>case 3:printf(&quot;%d月是春季&quot;,month); break;<br>case 4:printf(&quot;%d月是春季&quot;,month); break;<br>case 5:printf(&quot;%d月是春季&quot;,month); break;<br>case 6:printf(&quot;%d月是夏季&quot;,month); break;<br>case 7:printf(&quot;%d月是夏季&quot;,month); break;<br>case 8:printf(&quot;%d月是夏季&quot;,month); break;<br>case 9:printf(&quot;%d月是秋季&quot;,month); break;<br>case 10:printf(&quot;%d月是秋季&quot;,month); break;<br>case 11:printf(&quot;%d月是秋季&quot;,month); break;<br>case 12:printf(&quot;%d月是冬季&quot;,month); break;<br>default:printf(&quot;%d月不存在！&quot;,month); break;<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4-1"></a>4-1</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main() &#123;<br>int no, a;<br>printf(&quot;请输入一个整数：&quot;);   scanf(&quot;%d&quot;, &amp;no);<br>int retry;<br>do&#123;<br>if(no==0)<br>puts(&quot;该整数是零&quot;);<br>else if(no&gt;0)<br>puts(&quot;该整数大于零&quot;);<br>else<br>puts(&quot;该整数小于零&quot;);<br>printf(&quot;是否继续？&lt;yes---0,no--9&gt;:&quot;);  scanf(&quot;%d&quot;,&amp;retry);<br>&#125;while(retry==0);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2"><a href="#4-2" class="headerlink" title="4-2"></a>4-2</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b;<br>printf(&quot;请输入一个整数a:&quot;);   scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;请输入一个整数b:&quot;);  scanf(&quot;%d&quot;,&amp;b);<br>int sum=0;<br>if(a&gt;b)&#123;<br>int i=b;<br>do<br>&#123;<br>sum=sum+i;<br>i=i+1;<br>&#125;while(i&lt;=a);<br>printf(&quot;大于%d小于%d的所有整数和是%d\n&quot;,b,a,sum);<br>&#125;else&#123;<br>int i=a;<br>do&#123;<br>sum=sum+i;<br>i=i+1;<br>&#125;while(i&lt;=b);<br>printf(&quot;大于%d小于%d的所有整数和是%d\n&quot;,a,b,sum);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3"><a href="#4-3" class="headerlink" title="4-3"></a>4-3</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int n;<br>printf(&quot;请输入一个整数：&quot;);    scanf(&quot;%d&quot;,&amp;n);<br>if(n&gt;=0)&#123;<br>while(n&gt;=0)&#123;<br>printf(&quot;%d&quot;,n);<br>n--;&#125;<br>&#125;else<br>puts(&quot;&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4"><a href="#4-4" class="headerlink" title="4-4"></a>4-4</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int n;<br>printf(&quot;请输入一个整数：&quot;);    scanf(&quot;%d&quot;,&amp;n);<br>if(n&gt;=0)&#123;<br>while(n&gt;=1)&#123;<br>printf(&quot;%d&quot;,n);<br>n--;&#125;<br>&#125;else<br>puts(&quot;&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5"><a href="#4-5" class="headerlink" title="4-5"></a>4-5</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int i=1, n;<br>printf(&quot;请输入一个整数：&quot;);    scanf(&quot;%d&quot;,&amp;n);<br>if(i&gt;=0)&#123;<br>while(n&gt;=1)&#123;<br>printf(&quot;%d&quot;,i++);<br>n--;&#125;<br>&#125;else<br>puts(&quot;&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-6"><a href="#4-6" class="headerlink" title="4-6"></a>4-6</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int  no;<br>printf(&quot;请输入一个整数：&quot;);    scanf(&quot;%d&quot;,&amp;no);<br>int i;<br>while(i&lt;=no)&#123;<br>printf(&quot;%d&quot;,i);<br>i=i+2;<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-7"><a href="#4-7" class="headerlink" title="4-7"></a>4-7</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int  no;<br>printf(&quot;请输入一个正整数：&quot;);    scanf(&quot;%d&quot;,&amp;no);<br>int i;<br>while(i&lt;=no)&#123;<br>printf(&quot;%d&quot;,i);<br>i=i*2;<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-8"><a href="#4-8" class="headerlink" title="4-8"></a>4-8</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int  no;<br>printf(&quot;正整数：&quot;);    scanf(&quot;%d&quot;,&amp;no);<br>int i;<br>if(no&gt;=1)&#123;<br>while(no--&gt;1)<br>putchar(&#x27;*&#x27;);<br>putchar(&#x27;\n&#x27;);   <br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-9"><a href="#4-9" class="headerlink" title="4-9"></a>4-9</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int  n;<br>printf(&quot;请输入正整数：&quot;);    scanf(&quot;%d&quot;,&amp;n);<br>int i=1;<br>if(n&gt;=0)&#123;<br>while(i&lt;=n)&#123;<br>if(i%2==0)&#123;<br>printf(&quot;-&quot;);<br>&#125;<br>else<br>printf(&quot;+&quot;);<br>i+=1;&#125;<br><br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-10"><a href="#4-10" class="headerlink" title="4-10"></a>4-10</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int  n;<br>printf(&quot;请输入正整数：&quot;);    scanf(&quot;%d&quot;,&amp;n);<br>int i=1;<br>if(n&gt;=0)&#123;<br>while(n--&gt;0)&#123;<br>printf(&quot;-&quot;);&#125;<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-11"><a href="#4-11" class="headerlink" title="4-11"></a>4-11</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int  n;<br>do &#123;<br>printf(&quot;请输入正整数：&quot;);<br>scanf(&quot;%d&quot;, &amp;n);<br>if(n&lt;=0)&#123;<br>puts(&quot;请不要输入一个正整数。&quot;);<br>&#125;<br>&#125;while(n&lt;=0);<br>printf(&quot;该整数的逆向显示的结果是&quot;);<br>while(n&gt;0)&#123;<br>printf(&quot;%d&quot;,n%10);<br>n/=10;<br>&#125;<br>puts(&quot;。&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-12"><a href="#4-12" class="headerlink" title="4-12"></a>4-12</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int  n,cnt=0;<br>do &#123;<br>printf(&quot;请输入正整数：&quot;);<br>scanf(&quot;%d&quot;, &amp;n);<br>if(n&lt;=0)&#123;<br>puts(&quot;请不要输入一个正整数。&quot;);<br>&#125;<br>&#125;while(n&lt;=0);<br>printf(&quot;该整数的位数是&quot;);<br>while(n&gt;0)&#123;<br>n/=10;<br>cnt+=1;<br>&#125;<br>printf(&quot;%d&quot;,cnt);<br>puts(&quot;。&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-13"><a href="#4-13" class="headerlink" title="4-13"></a>4-13</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int n,sum=0,i;<br>printf(&quot;n的值是：&quot;,n);<br>scanf(&quot;%d&quot;,&amp;n);<br>for(i=0;i&lt;=n;i++)&#123;<br>sum+=1;<br>&#125;<br>printf(&quot;1到%d:%d&quot;,n,sum);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-14"><a href="#4-14" class="headerlink" title="4-14"></a>4-14</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,i;<br>printf(&quot;请输入一个整数：&quot;);<br>scanf(&quot;%d&quot;,&amp;a);<br>for(i=1;i&lt;=a;i++)&#123;<br>printf (&quot;%d&quot;,i%10);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-15"><a href="#4-15" class="headerlink" title="4-15"></a>4-15</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,b,c;<br>printf(&quot;开始数值(cm)：&quot;);<br>scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;结束数值(cm)：&quot;);<br>scanf(&quot;%d&quot;,&amp;b);<br>printf(&quot;间隔数值(cm)：&quot;);<br>scanf(&quot;%d&quot;,&amp;c);<br><br>    for(;a&lt;=b;a+=c)&#123;<br>        printf(&quot;%dcm&quot;,a);<br>        printf(&quot;       &quot;);<br>        printf(&quot;%.2f&quot;,(double)(a-100)*0.9);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-16"><a href="#4-16" class="headerlink" title="4-16"></a>4-16</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,i;<br>printf(&quot;整数值：&quot;);<br>scanf(&quot;%d&quot;,&amp;a);<br>for(i+=1;i&lt;=a;i++)&#123;<br>if(i%2!=0)<br>printf(&quot;%d&quot;,i);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-17"><a href="#4-17" class="headerlink" title="4-17"></a>4-17</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,i;<br>printf(&quot;整数值：&quot;);<br>scanf(&quot;%d&quot;,&amp;a);<br>for(i+=1;i&lt;=a;i++)<br>printf(&quot;%d的二次方是:%d\n&quot;,i,i*i);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-18"><a href="#4-18" class="headerlink" title="4-18"></a>4-18</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,i;<br>printf(&quot;显示多少个*&quot;);<br>scanf(&quot;%d&quot;,&amp;a);<br>for(i+=1;i&lt;=a;i++)&#123;<br>printf(&quot;*&quot;);<br>if(i%5==0)<br>printf(&quot;\n&quot;);&#125;<br><br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-19"><a href="#4-19" class="headerlink" title="4-19"></a>4-19</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int a,i,cnt;<br>printf(&quot;整数值：&quot;);<br>scanf(&quot;%d&quot;,&amp;a);<br>for(i+=1;i&lt;=a;i++) &#123;<br>printf(&quot;*&quot;);<br>if (a % i == 0) &#123;<br>printf(&quot;\n&quot;);<br>cnt = 1;<br>&#125;<br>&#125;<br>printf(&quot;约数有:%d&quot;,cnt);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-20"><a href="#4-20" class="headerlink" title="4-20"></a>4-20</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>printf(&quot; |&quot;);<br>int i,j;<br>for(i=1;i&lt;=9;i++)&#123;<br>printf(&quot;%3d&quot;,i);<br>&#125;<br>putchar(&#x27;\n&#x27;);<br>for (i=1;i&lt;=9;i++)&#123;<br>printf(&quot;----&quot;);<br>&#125;<br>putchar(&#x27;\n&#x27;);<br>for(i=1;i&lt;=9;i++)&#123;<br>printf(&quot;%d|&quot;,i);<br>for(j=1;j&lt;=9;j++)<br>printf(&quot;%3d&quot;,i*j);<br>putchar(&#x27;\n&#x27;);<br>&#125;return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-31"><a href="#4-31" class="headerlink" title="4-31"></a>4-31</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br><br>int main() &#123;<br>int a,b,c;<br>printf(&quot;生成一个正方形。&quot;);<br>printf(&quot;正方形有几层：&quot;);    scanf(&quot;%d&quot;,&amp;a);<br>for(b=1;b&lt;=a;b++)&#123;<br>for(c=1;c&lt;=a;c++)<br>putchar(&#x27;*&#x27;);<br>putchar(&#x27;\n&#x27;);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-22"><a href="#4-22" class="headerlink" title="4-22"></a>4-22</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main() &#123;<br>int a, b;<br>puts(&quot;让我们来画一个长方形&quot;);<br>printf(&quot;一边：&quot;);<br>scanf(&quot;%d&quot;, &amp;a);<br>printf(&quot;另一边：&quot;);<br>scanf(&quot;%d&quot;, &amp;b);<br>int h, w;<br>if (a &lt; b) &#123;<br>for (h = 1; h &lt;= a; h++) &#123;<br>for (w = 1; w &lt;= b; w++) &#123;<br>putchar(&#x27;*&#x27;);<br>&#125;<br>putchar(&#x27;\n&#x27;);<br>&#125;<br>&#125; else &#123;<br>for (h = 1; h &lt;= b; h++) &#123;<br>for (w = 1; w &lt;= a; w++) &#123;<br>putchar(&#x27;*&#x27;);<br>&#125;<br>putchar(&#x27;\n&#x27;);<br>&#125;<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-23"><a href="#4-23" class="headerlink" title="4.23"></a>4.23</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs [c]">（1）左上角的等腰三角形<br><br>#include &lt;stdio.h&gt;<br>int main()&#123;<br>int  i,j,len;<br>puts(&quot;生成直角在左上方的等腰直角三角形。&quot;);<br>printf(&quot;短边：&quot;);     scanf(&quot;%d&quot;,&amp;len);<br><br>for(i=1;i&lt;=len;i++)&#123;<br>for(j=0;j&lt;=len-i;j++)<br>putchar(&#x27;*&#x27;);<br>putchar(&#x27;\n&#x27;);&#125;<br><br>return 0;<br>&#125;<br>内循环结束了，外循环才能继续运行。<br><br>（2）右上方的等腰三角形<br><br>#include &lt;stdio.h&gt;<br>int main()&#123;<br>int  i,j,len;<br>puts(&quot;生成直角在右上方的等腰直角三角形。&quot;);<br>printf(&quot;短边：&quot;);     scanf(&quot;%d&quot;,&amp;len);<br><br>for(i=0;i&lt;=len;i++)&#123;<br>for(j=1;j&lt;=len-i;j++)<br>putchar(&#x27;*&#x27;);<br>for(j=0;j&lt;=i;j++)<br>putchar(&#x27; &#x27;);<br>putchar(&#x27;\n&#x27;);&#125;<br><br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-24"><a href="#4-24" class="headerlink" title="4-24"></a>4-24</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int  i,j,len;<br>puts(&quot;让我们来画一个金字塔。&quot;);<br>printf(&quot;金字塔有几层：&quot;);     scanf(&quot;%d&quot;,&amp;len);<br>for(i=1;i&lt;=len;i++)&#123;<br>for(j=1;j&lt;=len-i;j++)<br>printf(&quot; &quot;);       /*输出左边的空格*/<br>for(j=1;j&lt;=(i-1);j++)<br>printf(&quot;*&quot;);      /*左侧的*号*/<br>printf(&quot;*&quot;);          /*中间的*号*/<br>for(j=1;j&lt;=(i-1);j++)<br>printf(&quot;*&quot;);         /*右侧的*号*/<br>printf(&quot;\n&quot;);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-25"><a href="#4-25" class="headerlink" title="4-25"></a>4-25</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int  i,j,len;<br>puts(&quot;让我们来画一个向下金字塔。&quot;);<br>printf(&quot;金字塔有几层：&quot;);     scanf(&quot;%d&quot;,&amp;len);<br>for(i=1;i&lt;=len;i++)&#123;<br>for(j=1;j&lt;=i-1;j++)<br>printf(&quot; &quot;);       /*输出左边的空格*/<br>for(j=1;j&lt;=len-i;j++)<br>printf(&quot;%d&quot;,i%10);      /*左侧的*号*/<br>printf(&quot;%d&quot;,i%10);          /*中间的*号*/<br>for(j=1;j&lt;=len-i;j++)<br>printf(&quot;%d&quot;,i%10);         /*右侧的*号*/<br>printf(&quot;\n&quot;);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5-1"></a>5-1</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int i;<br>int v[5];<br>for(i=0;i&lt;5;i++)<br>v[i]=i;<br>for(i=0;i&lt;5;i++)<br>printf(&quot;[%d]=%d\n&quot;,i,v[i]);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>&lt;&gt;5-2 </p><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int i,c=5;<br>int v[5];<br>for(i=0;i&lt;5;i++)<br>v[i]=i+1;<br>for(i=0;i&lt;5;i++) &#123;<br>c--;<br>printf(&quot;[%d]=%d\n&quot;, i, v[c]);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3"><a href="#5-3" class="headerlink" title="5-3"></a>5-3</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int i;<br>int v[5]=&#123;5,4,3,2,1&#125;;<br>for(i=0;i&lt;5;i++)<br>printf(&quot;v[%d]=%d\n&quot;,i,v[i]);<br>return 0;<br>&#125;<br><br>#include &lt;stdio.h&gt;<br>int main()&#123;<br>int i;<br>int a[5]=&#123;5,4,3,2,1&#125;;<br>int b[5];<br>for(i=0;i&lt;5;i++)<br>b[i]=a[i];<br>puts(&quot;   a   b&quot;);<br>puts(&quot;---------&quot;);<br>for (i=0;i&lt;5;i++)<br>printf(&quot;%4d%4d\n&quot;,a[i],b[i]);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4"><a href="#5-4" class="headerlink" title="5-4"></a>5-4</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int i;<br>int a[5]=&#123;36,23,17&#125;;<br>int b[5];<br>for(i=0;i&lt;5;i++)<br>b[4-i]=a[i];<br>puts(&quot;   a   b&quot;);<br>puts(&quot;---------&quot;);<br>for (i=0;i&lt;5;i++)<br>printf(&quot;%4d%4d\n&quot;,a[i],b[i]);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5"><a href="#5-5" class="headerlink" title="5-5"></a>5-5</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>#define NUMBER 7   /*数组元素总数*/<br>int main()&#123;<br>int i;<br>int x[NUMBER];<br>for(i=0;i&lt;NUMBER;i++)&#123;<br>printf(&quot;x[%d]:&quot;,i);<br>scanf(&quot;%d&quot;,&amp;x[i]);<br>&#125;<br>for (i=0;i&lt;NUMBER-4;i++)&#123;<br>int temp=x[i];<br>x[i]=x[NUMBER-1-i];<br>x[NUMBER-1-i]=temp;<br>&#125;<br>puts(&quot;倒序排列了。&quot;);<br>for(i=0;i&lt;NUMBER;i++)<br>printf(&quot;x[%d]=%d\n&quot;,i,x[i]);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-6"><a href="#5-6" class="headerlink" title="5-6"></a>5-6</h3><h3 id="a-1-0-b-1"><a href="#a-1-0-b-1" class="headerlink" title="a&#x3D;1.0   b&#x3D;1"></a>a&#x3D;1.0   b&#x3D;1</h3><h3 id="5-7"><a href="#5-7" class="headerlink" title="5-7"></a>5-7</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>#define NUMBER 100    /*数组元素总数*/<br>int main()&#123;<br>int a,i;<br>int x[NUMBER];<br>printf(&quot;数据个数：&quot;);   scanf(&quot;%d&quot;,&amp;a);<br><br>for(i=0;i&lt;a;i++)&#123;<br>printf(&quot;x[%d]号:&quot;,i+1);<br>scanf(&quot;%d&quot;,&amp;x[i]);<br>&#125;<br>putchar(&#x27;&#123;&#x27;);<br>printf(&quot;%d&quot;,x[0]);<br>for(i=1;i&lt;a;i++)<br>&#123;<br>printf(&quot;， %d&quot;,x[i]);<br>&#125;<br>printf(&quot;&#125;\n&quot;);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-8"><a href="#5-8" class="headerlink" title="5-8&lt;\p&gt;"></a>5-8&lt;\p&gt;</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>#define NUMBER 80   /*数组元素总数*/<br>int main()&#123;<br>int i,j;<br>int num;<br>int tensu[NUMBER];<br>int bunpu[11]=&#123;0&#125;;<br><br>    printf(&quot;请输入学生的人数：&quot;);<br>    do&#123;<br>        scanf(&quot;%d&quot;,&amp;num);<br>        if(num&lt;1||num&gt;NUMBER)<br>            printf(&quot;\a请输入1~%d的数： &quot;,NUMBER);<br>    &#125;while (num&lt;1||num&gt;NUMBER);<br> <br>    printf(&quot;请输入%d人的分数。\n&quot;,num);<br> <br>    for(i=0;i&lt;num;i++)&#123;<br>        printf(&quot;%2d号:&quot;,i+1);<br>        do&#123;<br>            scanf(&quot;%d&quot;,&amp;tensu[i]);<br>            if (tensu[i] &lt; 0 || tensu[i] &gt; 100)<br>                printf(&quot;\a请输入1~100的数：&quot;);<br>        &#125;while(tensu[i]&lt;0||tensu[i]&gt;100);<br>        bunpu[tensu[i]/10]++;<br>    &#125;<br> <br>    puts(&quot;\n----分布图-----&quot;);<br> <br>    for(i=0;i&lt;=9;i++)&#123;<br>        printf(&quot;%3d-%3d：&quot;,i*10,i*10+9);<br>        for(j=0;j&lt;=bunpu[i];j++)<br>            putchar(&#x27;*&#x27;);<br>        putchar(&#x27;\n&#x27;);<br>    &#125;<br>    <br>    printf(&quot;    100:&quot;);<br>    for(j=0;j&lt;bunpu[10];j++)&#123;<br>        putchar(&#x27;*&#x27;);&#125;<br>    putchar(&#x27;\n&#x27;);<br>    return 0;<br> <br><br>### 5-9 <br>``` [c] bush                                                                                                           <br>#include &lt;stdio.h&gt;<br><br>#define NUMBER 80<br><br>int main()<br>&#123;<br>int i,j;<br>int num;<br>int score[NUMBER];<br>int scattergram[11]=&#123;0&#125;;<br>int max;<br>int max_x;<br><br>    printf(&quot;请输入学生人数：&quot;);<br> <br>    do&#123;<br>        scanf(&quot;%d&quot;,&amp;num);<br>        if(num&lt;1 || num&gt;NUMBER)<br>            printf(&quot;请输入1~%d之间的整数：&quot;,NUMBER);<br>    &#125;while(num&lt;1 || num&gt;NUMBER);<br> <br>    printf(&quot;请输入%d人的分数。\n&quot;,num);<br>    for(i=0;i&lt;num;i++)<br>    &#123;<br>        printf(&quot;%d号：&quot;,i+1);<br>        do&#123;<br>            scanf(&quot;%d&quot;,&amp;score[i]);<br>            if(score[i]&lt;0 || score[i]&gt;100)<br>            &#123;<br>                printf(&quot;请输入0~100之间的整数：&quot;);<br>            &#125;<br>        &#125;while(score[i]&lt;0 || score[i]&gt;100);<br>        scattergram[score[i]/10]++;<br>    &#125;<br> <br>    max=scattergram[0];<br>    for(i=1;i&lt;11;i++)<br>    &#123;<br>        if(scattergram[i]&gt;max)<br>            max=scattergram[i];<br>    &#125;     /*确定最高层数*/<br> <br>    max_x=max;<br>    for(i=0;i&lt;max_x;i++)<br>    &#123;<br>        for(j=0;j&lt;11;j++)<br>        &#123;<br>            if(max&gt;scattergram[j])<br>                printf(&quot;    &quot;);<br>            else<br>                printf(&quot;*   &quot;);<br>        &#125;<br>        putchar(&#x27;\n&#x27;);<br> <br>        max -= 1;<br>    &#125;<br>    printf(&quot;--------------------------------------------\n&quot;);<br> <br>    for(i=1;i&lt;=11;i++)<br>    &#123;<br>        printf(&quot; %d &quot;,(i-1)*10);<br>    &#125;<br> <br>    putchar(&#x27;\n&#x27;);<br> <br>    return 0;<br>&#125;<br><br>垂直的直方图其实是一层一层打印出来的      if句确定他的最高层   然后再循环<br></code></pre></td></tr></table></figure><h3 id="5-10"><a href="#5-10" class="headerlink" title="5-10"></a>5-10</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main() &#123;<br>int i, j, k;<br>int tensu1[4][3], tensu2[3][4];<br>int product[4][4] = &#123;0&#125;;<br><br>    puts(&quot;请输入第一个矩阵的具体元素&quot;);<br>    for (i = 0; i &lt; 4; i++) &#123;<br>        for (j = 0; j &lt; 3; j++) &#123;<br>            printf(&quot;tensu1[%d][%d]: &quot;, i, j);<br>            scanf(&quot;%d&quot;, &amp;tensu1[i][j]);<br>        &#125;<br>    &#125;<br> <br>    puts(&quot;请输入第二个矩阵的具体元素&quot;);<br>    for (i = 0; i &lt; 3; i++) &#123;<br>        for (j = 0; j &lt; 4; j++) &#123;<br>            printf(&quot;tensu2[%d][%d]: &quot;, i, j);<br>            scanf(&quot;%d&quot;, &amp;tensu2[i][j]);<br>        &#125;<br>    &#125;<br> <br>    for (i = 0; i &lt; 4; i++) &#123;<br>        for (j = 0; j &lt; 4; j++) &#123;<br>            for (k = 0; k &lt; 3; k++) &#123;<br>                product[i][j] += tensu1[i][k] * tensu2[k][j];<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    puts(&quot;显示矩阵1：&quot;);<br>    for (i = 0; i &lt; 4; i++) &#123;<br>        for (j = 0; j &lt; 3; j++) &#123;<br>            printf(&quot;%6d&quot;, tensu1[i][j]);<br>        &#125;<br>        putchar(&#x27;\n&#x27;);<br>    &#125;<br> <br>    puts(&quot;显示矩阵2：&quot;);<br>    for (i = 0; i &lt; 3; i++) &#123;<br>        for (j = 0; j &lt; 4; j++) &#123;<br>            printf(&quot;%6d&quot;, tensu2[i][j]);<br>        &#125;<br>        putchar(&#x27;\n&#x27;);<br>    &#125;<br> <br>    puts(&quot;显示乘积矩阵：&quot;);<br>    for (i = 0; i &lt; 4; i++) &#123;<br>        for (j = 0; j &lt; 4; j++) &#123;<br>            printf(&quot;%6d&quot;, product[i][j]);<br>        &#125;<br>        putchar(&#x27;\n&#x27;);<br>    &#125;<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-11"><a href="#5-11" class="headerlink" title="5-11"></a>5-11</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main() &#123;<br>int i, j=1;<br>int tensu1[6], tensu2[6];<br>int sum1=0, sum2=0, sum3=0;<br>puts(&quot;请输入六名学生的两门成绩&quot;);<br><br>    do&#123;j+=1;<br>        for (i = 0; i &lt; 6; i++) &#123;<br>            printf(&quot;%d号  &quot;, i + 1);<br>            do &#123;<br>                printf(&quot;语文：&quot;);<br>                scanf(&quot;%d&quot;, &amp;tensu1[i]);<br>                if (tensu1[i] &lt; 0 || tensu1[i] &gt; 100)<br>                    printf(&quot;请输入1~100的数：&quot;);<br>            &#125; while (tensu1[i] &lt; 0 || tensu1[i] &gt; 100);<br>            sum2 += tensu1[i];<br>        &#125;<br> <br>        for (i = 0; i &lt; 6; i++) &#123;<br>            printf(&quot;%d号  &quot;, i + 1);<br>            do &#123;<br>                printf(&quot;数学：&quot;);<br>                scanf(&quot;%d&quot;, &amp;tensu2[i]);<br>                if (tensu2[i] &lt; 0 || tensu2[i] &gt; 100)<br>                    printf(&quot;请输入1~100的数：&quot;);<br>            &#125; while (tensu2[i] &lt; 0 || tensu2[i] &gt; 100);<br>            sum3 += tensu2[i];<br>        &#125;<br> <br>        for (i = 0; i &lt; 6; i++) &#123;<br>            sum1 = tensu1[i] + tensu2[i];<br>            printf(&quot;%d号两门总分为%d,平均分为%.2f   &quot;,i+1,sum1, (double) sum1 / 2);<br>            putchar(&#x27;\n&#x27;);<br>        &#125;<br>     putchar(&#x27;\n&#x27;);<br>    &#125;while(j&gt;6);<br>    <br>    printf(&quot;语文的总分：%5d,平均分:%.2f\n&quot;,sum2,(double)sum2/6);<br>    printf(&quot;数学的总分：%5d,平均分:%.2f\n&quot;,sum3,(double)sum3/6);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-12"><a href="#5-12" class="headerlink" title="5-12"></a>5-12</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()<br>&#123;<br>int i,j,k;<br>int course[2][4][3]=&#123;&#123;&#123;91,63,78&#125;,&#123;67,72,46&#125;,&#123;89,34,53&#125;,&#123;32,54,34&#125;&#125;,<br>&#123;&#123;97,67,82&#125;,&#123;73,43,46&#125;,&#123;97,56,21&#125;,&#123;85,46,35&#125;&#125;&#125;;<br><br>    for(i=0;i&lt;2;i++)<br>    &#123;<br>        printf(&quot;第%d次考试的分数\n&quot;,i+1);<br>        for(j=0;j&lt;4;j++)<br>        &#123;<br>            printf(&quot;%d:&quot;,j+1);<br>            for(k=0;k&lt;3;k++)<br>            &#123;<br>                printf(&quot;%4d&quot;,course[i][j][k]);<br>            &#125;<br>            putchar(&#x27;\n&#x27;);<br>        &#125;<br>        putchar(&#x27;\n&#x27;);<br>    &#125;<br>    <br>    puts(&quot;总分&quot;);<br>    for(i=0;i&lt;1;i++)<br>    &#123;<br>        for(j=0;j&lt;4;j++)<br>        &#123;<br>            printf(&quot;%d:&quot;,j+1);<br>            for(k=0;k&lt;3;k++)<br>            &#123;<br>                printf(&quot;%4d&quot;,course[i][j][k]+course[i+1][j][k]);<br>            &#125;<br>            putchar(&#x27;\n&#x27;);<br>        &#125;<br>    &#125;<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><h3 id="6-1"><a href="#6-1" class="headerlink" title="6-1"></a>6-1</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int min2(int a,int b) &#123;<br>if (a &lt; b)<br>return a;<br>else<br>return b;<br>&#125;<br>int main()&#123;<br>int a,b;<br>puts(&quot;请输入两个整数：&quot;);<br>printf(&quot;整数a:&quot;);   scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;整数b:&quot;);   scanf(&quot;%d&quot;,&amp;b);<br>printf(&quot;最小值是%d。\n&quot;,min2(a,b));<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2"><a href="#6-2" class="headerlink" title="6-2"></a>6-2</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int min3(int a,int b,int c) &#123;<br>int min=a;<br>if(b&lt;min)     b=min;<br>if(c&lt;min)     c=min;<br>return min ;<br>&#125;<br><br>    int main()&#123;<br>        int a,b,c;<br>        puts(&quot;请输入三个整数：&quot;);<br>        printf(&quot;整数a:&quot;);   scanf(&quot;%d&quot;,&amp;a);<br>        printf(&quot;整数b:&quot;);   scanf(&quot;%d&quot;,&amp;b);<br>        printf(&quot;整数c:&quot;);   scanf(&quot;%d&quot;,&amp;c);<br>        printf(&quot;最小值是%d。\n&quot;,min3(a,b,c));<br>        return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3"><a href="#6-3" class="headerlink" title="6-3"></a>6-3</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int cbue(int x) &#123;<br>return x*x*x;<br>&#125;<br>int main()&#123;<br>int x;<br>printf(&quot;请输入一个整数：&quot;);<br>scanf(&quot;%d&quot;,&amp;x);<br>printf(&quot;该整数的立方是：%d&quot;,cbue(x));<br>return 0;<br>&#125;<br>6-4<br>#include &lt;stdio.h&gt;<br>int  spr(int x) &#123;<br>return x*x;<br>&#125;<br>int pow4(int x)&#123;<br>return spr(x*x);<br>&#125;<br>int main()&#123;<br>int x;<br>printf(&quot;请输入一个整数：&quot;);<br>scanf(&quot;%d&quot;,&amp;x);<br>printf(&quot;该整数的四次方是：%d&quot;,pow4(x));<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-5"><a href="#6-5" class="headerlink" title="6-5"></a>6-5</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int  sumup(int n) &#123;<br>int i;<br>int tmp=0;<br>for(i=1;i&lt;=n;i++)<br>tmp+=i;<br>return tmp;<br><br>&#125;<br>int main()&#123;<br>int a;<br>printf(&quot;请输n的值：&quot;);<br>scanf(&quot;%d&quot;,&amp;a);<br>printf(&quot;从1到%d和是：%d&quot;,a, sumup(a));<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-6"><a href="#6-6" class="headerlink" title="6-6"></a>6-6</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>void alert(int n) &#123;<br>while(n--&gt;0)<br>putchar(&#x27;\a&#x27;);<br><br>&#125;<br>int main()&#123;<br>int a;<br>printf(&quot;请输入多少次铃声&quot;);<br>scanf(&quot;%d&quot;,&amp;a);<br>alert(a);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-7"><a href="#6-7" class="headerlink" title="6-7"></a>6-7</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>void hello(void)&#123;<br>printf(&quot;你好.\n&quot;);<br>&#125;<br>int main()&#123;<br>hello();<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-8"><a href="#6-8" class="headerlink" title="6-8"></a>6-8</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>#define NUMBER 5<br>int min_of(const int v[],int n)&#123;<br>int i;<br>int min=v[0];<br>for(i=1;i&lt;n;i++)<br>if(v[i]&lt;min)<br>min=v[i];<br>return min;<br>&#125;<br>int main()&#123;<br>int i;<br>int v[NUMBER]=&#123;0&#125;;<br>printf(&quot;请输入%d个元素:&quot;,NUMBER);<br>for (i=0;i&lt;NUMBER;i++)<br>&#123;<br>printf(&quot;%d：&quot;,i+1);<br>scanf(&quot;%d&quot;,&amp;v[i]);<br>&#125;<br>printf(&quot;最小值是%d。\n&quot;,min_of(v,NUMBER));<br>return 0;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-9"><a href="#6-9" class="headerlink" title="6-9"></a>6-9</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>#define NUMBER 7<br><br>void rev_intary(int v[],int n)&#123;<br>int i;<br>for(i=0;i&lt;n-4;i++)<br>&#123;<br>int temp=v[i];<br>v[i] =v[n-1-i];<br>v[n-1-i]=temp;<br>&#125;<br><br>&#125;<br><br>int main()&#123;<br>int i;<br>int x[NUMBER];<br>for(i=0;i&lt;NUMBER;i++) &#123;<br>printf(&quot;x[%d]&quot;, i);<br>scanf(&quot;%d&quot;, &amp;x[i]);<br>&#125;<br>rev_intary(x,NUMBER);<br><br>    puts(&quot;倒序排列了！&quot;);<br> <br>    for (i=0;i&lt;NUMBER;i++)<br>    &#123;<br>        printf(&quot;x[%d]：%d\n&quot;,i,x[i]);<br>    &#125;<br> <br>    return 0;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-10"><a href="#6-10" class="headerlink" title="6-10"></a>6-10</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>#define NUMBER 7<br><br>void rev_intary(int v[], int n) &#123;<br>int i;<br>for (i = 0; i &lt; n / 2; i++) &#123;<br>int temp = v[i];<br>v[i] = v[n - 1 - i];<br>v[n - 1 - i] = temp;<br>&#125;<br>&#125;<br><br>void intary_rcpy(int v1[], const int v2[], int n) &#123;<br>int i;<br>for (i = 0; i &lt; n; i++) &#123;<br>v1[i] = v2[i];<br>&#125;<br>&#125;<br><br>int main() &#123;<br>int i;<br>int v1[NUMBER];<br>int v2[NUMBER];<br><br>    for (i = 0; i &lt; NUMBER; i++) &#123;<br>        printf(&quot;v[%d]: &quot;, i);<br>        scanf(&quot;%d&quot;, &amp;v2[i]);<br>    &#125;<br>    <br>    rev_intary(v2, NUMBER);<br>    intary_rcpy(v1, v2, NUMBER);<br> <br>    puts(&quot;倒序排列了！&quot;);<br> <br>    for (i = 0; i &lt; NUMBER; i++) &#123;<br>        printf(&quot;v2[%d]: %d\n&quot;, i, v2[i]);<br>    &#125;<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-11"><a href="#6-11" class="headerlink" title="6-11"></a>6-11</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>#define NUMBER 7<br>#define FAILED -1<br><br>int search_idx(const int v[], int idx[], int key, int n) &#123;<br>int i;<br>int temp = 0;<br><br>    for (i = 0; i &lt; n; i++) &#123;<br>        if (v[i] == key) &#123;<br>            idx[temp] = i;<br>            temp += 1;<br>        &#125;<br>    &#125;<br>    return (temp &gt; 0) ? temp : FAILED;<br>&#125;<br><br>int main() &#123;<br>int i, ky, y;<br>int idx[NUMBER], vx[NUMBER + 1];<br>for (i = 0; i &lt; NUMBER; i++) &#123;<br>printf(&quot;vx[%d]:&quot;, i);<br>scanf(&quot;%d&quot;, &amp;vx[i]);<br>&#125;<br>printf(&quot;要查找的值:&quot;);<br>scanf(&quot;%d&quot;, &amp;ky);<br>y = search_idx(vx, idx, ky, NUMBER);<br>if (y == FAILED)<br>puts(&quot;\a查找失败。&quot;);<br>else<br>printf(&quot;%d&quot;, y);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-12"><a href="#6-12" class="headerlink" title="6-12"></a>6-12</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>void mat_mul(const int a[4][3],const int b [3][4],int c[4][3])&#123;<br>int i, j, k;<br><br>    for (i = 0; i &lt; 4; i++) &#123;<br>        for (j = 0; j &lt; 3; j++) &#123;<br>            c[i][j] = 0; &#125;<br>            for (k = 0; k &lt; 3; k++) &#123;<br>                c[i][j] += a[i][k] * b[k][j];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>int main()&#123;<br>int i,j;<br>int tensu1[4][3],tensu2[3][4],tensu3[3][3];<br>puts(&quot;请输入4行3列矩阵元素&quot;);<br>for(i=0;i&lt;4;i++)&#123;<br>for(j=0;j&lt;3;j++)&#123;<br>printf(&quot;tensu[%d][%d]=&quot;,i,j);<br>scanf(&quot;%d&quot;,&amp;tensu1[i][j]);<br>&#125;<br>&#125;<br>puts(&quot;请输入3行4列矩阵元素&quot;);<br>for(i=0;i&lt;3;i++)&#123;<br>for(j=0;j&lt;4;j++)&#123;<br>printf(&quot;[tensu2[%d][%d]=&quot;,i,j);<br>scanf(&quot;%d&quot;,&amp;tensu1[i][j]);<br>&#125;<br>&#125;<br>mat_mul(tensu1,tensu2,tensu3);<br>printf(&quot;两个矩阵的乘积为:\n&quot;);<br>for (i = 0; i &lt; 4; i++) &#123;<br>for (j = 0; j &lt; 3; j++) &#123;<br>printf(&quot;%4d&quot;, tensu3[i][j]);<br>&#125;<br>putchar(&#x27;\n&#x27;);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-13"><a href="#6-13" class="headerlink" title="6-13"></a>6-13</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br><br>void mat_add(const int a[4][3], const int b[4][3], int c[2][4][3]) &#123;<br>int i, j;<br><br>    for (i = 0; i &lt; 4; i++) &#123;<br>        for (j = 0; j &lt; 3; j++) &#123;<br>            c[0][i][j] = a[i][j]; // 存储第一次考试的分数<br>            c[1][i][j] = b[i][j]; // 存储第二次考试的分数<br>        &#125;<br>    &#125;<br>&#125;<br><br>void mat_print(const int m[4][3]) &#123;<br>int i, j;<br><br>    for (i = 0; i &lt; 4; i++) &#123;<br>        for (j = 0; j &lt; 3; j++) &#123;<br>            printf(&quot;%4d&quot;, m[i][j]);<br>        &#125;<br>        putchar(&#x27;\n&#x27;);<br>    &#125;<br>&#125;<br><br>int main() &#123;<br>int tensu1[4][3] = &#123;&#123;91, 63, 78&#125;, &#123;67, 72, 46&#125;, &#123;89, 34, 53&#125;, &#123;32, 54, 34&#125;&#125;;<br>int tensu2[4][3] = &#123;&#123;97, 67, 82&#125;, &#123;73, 43, 46&#125;, &#123;97, 56, 21&#125;, &#123;85, 46, 35&#125;&#125;;<br>int sum[2][4][3];<br><br>    mat_add(tensu1, tensu2, sum);<br>    puts(&quot;第一次考试的分数&quot;);<br>    mat_print(tensu1);<br>    puts(&quot;第二次考试的分数&quot;);<br>    mat_print(tensu2);<br>    puts(&quot;总分（储存在三维数组中）&quot;);<br>    for (int i = 0; i &lt; 2; i++) &#123;<br>        for (int j = 0; j &lt; 4; j++) &#123;<br>            for (int k = 0; k &lt; 3; k++) &#123;<br>                printf(&quot;%4d&quot;, sum[i][j][k]);<br>            &#125;<br>            putchar(&#x27;\n&#x27;);<br>        &#125;<br>    &#125;<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-14"><a href="#6-14" class="headerlink" title="6-14"></a>6-14</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int fx;<br>int main()&#123;<br>int i;<br>static double sa[5];<br>for(i=0;i&lt;5;i++)<br>printf(&quot;sa[%d]=%.1f\n&quot;,i,sa[i]);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-15"><a href="#6-15" class="headerlink" title="6-15"></a>6-15</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int x;<br>void put_count()&#123;<br>printf(&quot;put_count:第%d次&quot;,x+1);<br>x++;<br>putchar(&#x27;\n&#x27;);<br>&#125;<br>int main ()&#123;<br>int i,j;<br>printf(&quot;要调用多少次：&quot;);<br>scanf(&quot;%d&quot;,&amp;i);<br>for(j=0;j&lt;i;j++)&#123;<br>put_count();<br><br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h3 id="8-1"><a href="#8-1" class="headerlink" title="8-1"></a>8-1</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br><br>#define diff(x,y) ((x)-(y))<br><br>int main()<br>&#123;<br>int x,y;<br><br>    printf(&quot;请输入两个整数：&quot;);<br>    scanf(&quot;%d %d&quot;,&amp;x,&amp;y);<br>    printf(&quot;两数之差为%d。\n&quot;,x&gt;y?diff(x,y):diff(y,x));<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-3"><a href="#8-3" class="headerlink" title="8-3"></a>8-3</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br><br>#define swap(type,a,b) &#123;type temp;temp=(a);(a)=(b);(b)=temp;&#125;<br><br>int main()<br>&#123;<br>int x,y;<br><br>    printf(&quot;x = &quot;);    scanf(&quot;%d&quot;,&amp;x);<br>    printf(&quot;y = &quot;);    scanf(&quot;%d&quot;,&amp;y);<br>    swap(int,x,y);<br>    printf(&quot;这两个数已经互换了。\n&quot;);<br>    printf(&quot;x = %d\n&quot;,x);<br>    printf(&quot;y = %d\n&quot;,y);<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-4"><a href="#8-4" class="headerlink" title="8-4"></a>8-4</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br># define NUMBER 5<br>void bsort(int a[],int n)&#123;<br>int i,j;<br>for(i=n-1;i&gt;0;i--)&#123;<br>for(j=0;j&lt;i;j++)&#123;<br>if(a[j]&lt;a[j+1])&#123;<br>int temp =a[j];<br>a[j]=a[j+1];<br>a[j+1]=temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>int main()&#123;<br>int i;<br>int height[NUMBER];<br>printf(&quot;请输入%d人的身高。\n&quot;,NUMBER);<br>for(i=0;i&lt;NUMBER;i++)&#123;<br>printf(&quot;%2d号：&quot;,i+1);<br>scanf(&quot;%d&quot;,&amp;height[i]);<br>&#125;<br>bsort(height,NUMBER);<br>puts(&quot;按降序排列。&quot;);<br>for(i=0;i&lt;NUMBER;i++)&#123;<br>printf(&quot;%2d号：%d\n&quot;,i+1,height[i]);<br><br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-5"><a href="#8-5" class="headerlink" title="8-5"></a>8-5</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>enum sex &#123;male,female&#125;;<br>enum season    &#123;spring=1,summer,autumn,winter&#125;;<br><br>void select_sex(enum sex m)&#123;<br>switch(m)&#123;<br>case male:printf(&quot;先生&quot;); break;<br>case female:printf(&quot;女士&quot;);break;<br>default :printf(&quot;请正确选择性别！&quot;);  break;<br>&#125;<br>&#125;<br><br>void select_season (int n)&#123;<br>switch (n)<br>&#123;<br>case spring    :    puts(&quot;你最喜欢的是春季。&quot;);        break;<br>case summer    :    puts(&quot;你最喜欢的是夏季。&quot;);        break;<br>case autumn    :    puts(&quot;你最喜欢的是秋季。&quot;);        break;<br>case winter    :    puts(&quot;你最喜欢的是冬季。&quot;);        break;<br>default        :    puts(&quot;请正确选择季节。&quot;);        break;<br>&#125;<br><br>&#125;<br>int main()<br>&#123;<br>enum sex a;<br>int b;<br><br>    printf(&quot;请选择你的性别【0…男士】【1…女士)】：&quot;);<br>    scanf(&quot;%d&quot;,&amp;a);<br> <br>    printf(&quot;你最喜欢的季节是【1…春季】【2…夏季】【3…秋季】【4…冬季】：&quot;);<br>    scanf(&quot;%d&quot;,&amp;b);<br> <br>    select_sex(a);<br>    select_season(b);<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-6"><a href="#8-6" class="headerlink" title="8-6"></a>8-6</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int factorial(int n) &#123;<br>int result = 1;<br><br>    for (int i = 1; i &lt;= n; i++) <br>        result *= i;<br>    return result;<br>&#125;<br><br>int main() &#123;<br>int num;<br>printf(&quot;请输入一个整数：&quot;);<br>scanf(&quot;%d&quot;, &amp;num);<br><br>    if (num &lt; 0) &#123;<br>        printf(&quot;阶乘只定义于非负整数。\n&quot;);<br>    &#125; else &#123;<br>        printf(&quot;该整数的阶乘为 %d.\n&quot;, factorial(num));<br>    &#125;<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-7"><a href="#8-7" class="headerlink" title="8-7###"></a>8-7###</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include&lt;stdio.h&gt;<br><br>int combination(int n,int r);<br><br>int main(void)<br>&#123;<br>int n;<br>int r;<br><br>    do<br>    &#123;<br>        printf(&quot;请输入整数n：&quot;);<br>        scanf(&quot;%d&quot;,&amp;n);<br>        printf(&quot;请输入整数r：&quot;);<br>        scanf(&quot;%d&quot;,&amp;r);<br>        if(n&lt;=0||r&lt;0||n&lt;r)<br>        &#123;<br>            puts(&quot;请输入正确数量！&quot;);<br>        &#125;<br>    &#125;while(n&lt;=0||r&lt;0||n&lt;r);<br> <br>    printf(&quot;%d个整数中取%d个整数的组合数为%d。\n&quot;,n,r,combination(n,r));<br> <br>    return 0;<br>&#125;<br><br>int combination(int n,int r)<br>&#123;<br>if (r == 1)<br>&#123;<br>return n;<br>&#125;<br>else if (r==0 || r==n)<br>&#123;<br>return 1;<br>&#125;<br>else<br>&#123;<br>return combination(n-1,r-1)+combination(n-1,r);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-8"><a href="#8-8" class="headerlink" title="8-8"></a>8-8</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br><br>int gcd(int x, int y) &#123;<br>if (y == 0) &#123;<br>return x;<br>&#125; else &#123;<br>return gcd(y, x % y);<br>&#125;<br>&#125;<br><br>int main() &#123;<br>int x = 48;<br>int y = 18;<br>int result = gcd(x, y);<br>printf(&quot;GCD of %d and %d is %d\n&quot;, x, y, result);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-9"><a href="#8-9" class="headerlink" title="8-9"></a>8-9</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int i=1,ch;<br>while((ch=getchar())!=EOF)&#123;<br>switch(ch)&#123;<br>case &#x27;\n&#x27;: i++; break;<br>&#125;<br>&#125;<br>printf(&quot;标准输入中出现的行数：%d&quot;,i);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-10"><a href="#8-10" class="headerlink" title="8-10"></a>8-10</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>int i,ch;<br>int cnt[10]=&#123;0&#125;;<br>while((ch=getchar())!=EOF)&#123;<br>if(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)<br>cnt[ch-&#x27;0&#x27;]++;<br>&#125;<br>puts(&quot;数字字符串的出现次数&quot;);<br>for(i=0;i&lt;10;i++)&#123;<br>printf(&quot;%d:&quot;,i);<br>for (int j = 0; j &lt; cnt[i]; j++) &#123;<br>putchar(&#x27;*&#x27;);&#125;<br>putchar(&#x27;\n&#x27;);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="9-1"><a href="#9-1" class="headerlink" title="9-1"></a>9-1</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int main()&#123;<br>char str[]=&quot;ABC\0DEF&quot;;<br>printf(&quot;字符串str为\&quot;%s\&quot;。\n&quot;,str);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-2"><a href="#9-2" class="headerlink" title="9-2"></a>9-2</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br><br>int main()<br>&#123;<br>char s[]=&quot;ABC&quot;;<br><br>    s[0]=&#x27;\0&#x27;;<br> <br>    printf(&quot;字符串s为%s。\n&quot;,s);<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-3"><a href="#9-3" class="headerlink" title="9-3"></a>9-3</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>#define NUMBER 10<br>int myStrcmpWithoutPointers(const char str1[], const char str2[]) &#123;<br>int i = 0;<br><br>    while (str1[i] != &#x27;\0&#x27; &amp;&amp; str2[i] != &#x27;\0&#x27;) &#123;<br>        if (str1[i] != str2[i]) &#123;<br>            return str1[i] - str2[i];<br>        &#125;<br>        i++;<br>    &#125;<br>    return str1[i] - str2[i];<br>&#125;<br>int main()<br>&#123;<br>int i;<br>char s[NUMBER][128];<br>for(i=0;i&lt;NUMBER;i++)&#123;<br>printf(&quot;s[%d]:&quot;,i);<br>scanf(&quot;%s&quot;,s[i]);<br>if (myStrcmpWithoutPointers(s[i], &quot;$$$$$&quot;) == 0)<br>break;<br>&#125;<br>for(i=0;i&lt;NUMBER;i++)<br>printf(&quot;s[%d]=\&quot;%s\&quot;\n&quot;,i,s[i]);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-4"><a href="#9-4" class="headerlink" title="9-4"></a>9-4</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br><br>void null_string(char s[])&#123;<br>s[0] = &#x27;\0&#x27;;<br>&#125;<br><br>int main()&#123;<br>char s[] = &quot;abc&quot;;<br>null_string(s);<br>printf(&quot;该字符串为: \&quot;%s\&quot;&quot;, s);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-5"><a href="#9-5" class="headerlink" title="9-5"></a>9-5</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int  str_char(const  char s[],int c)&#123;<br>int i=0;<br>while(s[i])<br>&#123;<br>if(s[i]==&#x27;c&#x27;)&#123;<br>return i;<br>&#125;<br>i++;<br>&#125;<br>return -1;<br>&#125;<br>int main() &#123;<br>char s[] = &quot;example&quot;;<br>int index = str_char(s, &#x27;c&#x27;);<br>if (index != -1) &#123;<br>printf(&quot;字符 &#x27;c&#x27; 在字符串中的索引是 %d\n&quot;, index);<br>&#125; else &#123;<br>printf(&quot;字符 &#x27;c&#x27; 未在字符串中找到\n&quot;);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-6"><a href="#9-6" class="headerlink" title="9-6"></a>9-6</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int  str_char(const  char s[],int c)&#123;<br>int i=0,j=0;<br><br>    while(s[i])<br>    &#123;<br>        if(s[i]==&#x27;c&#x27;)&#123;<br>            j+=1;<br>        &#125;<br>        i++;<br>    &#125;<br>    return j;<br>&#125;<br>int main() &#123;<br>char s[] = &quot;cexcamplec&quot;;<br>int index = str_char(s, &#x27;c&#x27;);<br>if (index != 0) &#123;<br>printf(&quot;字符 &#x27;c&#x27; 有： %d个\n&quot;, index);<br>&#125; else &#123;<br>printf(&quot;字符 &#x27;c&#x27; 未在字符串中找到\n&quot;);<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-7"><a href="#9-7" class="headerlink" title="9-7"></a>9-7</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br><br>void put_stringn(const char s[], int n) &#123;<br>for (int i = 0; i &lt; n; i++) &#123;<br>for (int j = 0; s[j] != &#x27;\0&#x27;; j++) &#123;<br>putchar(s[j]);<br>&#125;<br>&#125;<br>&#125;<br><br>int main() &#123;<br>int j;<br>char str[128];<br>printf(&quot;请输入字符: &quot;);<br>scanf(&quot;%s&quot;, str);<br>printf(&quot;要重复多少次：&quot;);<br>scanf(&quot;%d&quot;, &amp;j);<br>printf(&quot;%s字符重复%d次为:&quot;, str, j);<br><br>    put_stringn(str, j);<br>    printf(&quot;.\n&quot;);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-8-p"><a href="#9-8-p" class="headerlink" title="9-8 p&gt;"></a>9-8 p&gt;</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>void put_string(const char s[])<br>&#123;int len=0;<br>while(s[len])<br>len++;<br>int i;<br>for(i=len-1;i&gt;=0;i--)<br>putchar(s[i]);<br>&#125;<br><br><br>int main()<br>&#123;<br>char str[128];<br><br>    printf(&quot;请输入一个字符串：&quot;);<br>    scanf(&quot;%s&quot;,str);<br> <br>    printf(&quot;字符串\&quot;%s\&quot;逆向后：&quot;,str);<br>    put_string(str);<br> <br>    return 0;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="9-9"><a href="#9-9" class="headerlink" title="9-9"></a>9-9</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>#define NUMBER 128<br><br>void put_stringn(char s[]) &#123;<br>int len = 0;<br><br>    while (s[len] != &#x27;\0&#x27;) &#123;<br>        len++;<br>    &#125;/*计算字符串长度*/<br> <br>    for (int i = 0; i &lt; len / 2; i++) &#123;<br>        char temp = s[i];<br>        s[i] = s[len - 1 - i];<br>        s[len - 1 - i] = temp;<br>    &#125;<br>&#125;<br><br>int main() &#123;<br>char str[NUMBER];<br>printf(&quot;请输入字符: &quot;);<br>scanf(&quot;%s&quot;, str);<br>printf(&quot;%s字符的逆向显示：&quot;, str);<br><br>    put_stringn(str);<br> <br>    printf(&quot;%s.\n&quot;, str);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-10"><a href="#9-10" class="headerlink" title="9-10"></a>9-10</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>void del_digit(char s[])<br>&#123;<br>int i = 0;<br>int j = 0;<br>char temp[128] = &#123;0&#125;;<br><br>    while (s[i])<br>    &#123;<br>        if (s[i] &lt; &#x27;0&#x27; || s[i] &gt; &#x27;9&#x27;)<br>        &#123;<br>            temp[j] = s[i];<br>            j++;<br>        &#125;<br>        i++;<br>    &#125;<br> <br>    j = 0;<br>    while (temp[j])<br>    &#123;<br>        s[j] = temp[j];<br>        j++;<br>    &#125;<br>    s[j] = &#x27;\0&#x27;;<br>&#125;<br><br><br>int main()<br>&#123;<br>int i;<br>char str[128];<br><br>    printf(&quot;请输入一个字符串：&quot;);<br>    scanf(&quot;%s&quot;, str);<br> <br>    del_digit(str);<br>    printf(&quot;删除数字后：%s\n&quot;, str);<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-11"><a href="#9-11" class="headerlink" title="9-11"></a>9-11</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>#define NUMBER1 10<br>#define NUMBER2 128<br>void put_strary(const char s[][NUMBER2], int n) &#123;<br>int i;<br>for (i = 0; i &lt; n; i++)<br>printf(&quot;s[%d]=\&quot;%s\&quot;\n&quot;, i, s[i]);<br>&#125;<br><br>int myStrcmpWithoutPointers(const char str1[], const char str2[]) &#123;<br>int i = 0;<br>while (str1[i] != &#x27;\0&#x27; &amp;&amp; str2[i] != &#x27;\0&#x27;) &#123;<br>if (str1[i] != str2[i]) &#123;<br>return str1[i] - str2[i];<br>&#125;<br>i++;<br>&#125;<br>return str1[i] - str2[i];<br>&#125;<br><br>int main() &#123;<br>int i;<br>char cs[NUMBER1][NUMBER2];<br>for (i = 0; i &lt; NUMBER1; i++) &#123;<br>printf(&quot;s[%d]:&quot;, i);<br>scanf(&quot;%s&quot;, cs[i]);<br>if (myStrcmpWithoutPointers(cs[i], &quot;$$$$$&quot;) == 0)<br>break;<br>&#125;<br>put_strary(cs, i);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-12"><a href="#9-12" class="headerlink" title="9-12"></a>9-12</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>int str_len(char s[])&#123;<br>int len=0 ;<br>while(s[len]!=&#x27;\0&#x27;)&#123;<br>len++;<br>&#125;<br>return len;<br>&#125;<br>void rev_string(char s[][128], int n) &#123;<br>int i, j;<br>for (i = 0; i &lt; n; i++) &#123;<br>int len = str_len(s[i]);<br>for (j = 0; j &lt; len / 2; j++) &#123;<br>char temp = s[i][j];<br>s[i][j] = s[i][len - 1 - j];<br>s[i][len - 1 - j] = temp;<br>&#125;<br>&#125;<br>&#125;<br>int main() &#123;<br>char strings[][128] = &#123;&quot;SEC&quot;, &quot;ABC&quot;&#125;;<br>int num_strings = 2;<br><br>    rev_string(strings, num_strings);<br> <br>    for (int i = 0; i &lt; num_strings; i++) &#123;<br>        printf(&quot;%s\n&quot;, strings[i]);<br>    &#125;<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h3 id="10-1"><a href="#10-1" class="headerlink" title="10-1"></a>10-1</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br>void adjust_point(int *n)&#123;<br>if(*n&lt;0)<br>*n=0;<br>if(*n&gt;100)<br>*n=100;<br>&#125;<br>int main()&#123;<br>int i;<br>printf(&quot;请输入一个数字：&quot;);<br>scanf(&quot;%d&quot;,&amp;i);<br>adjust_point(&amp;i);<br>printf(&quot;该数字为：%d&quot;,i);<br>return 0;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>10-2</p><h3 id="10-3"><a href="#10-3" class="headerlink" title="10-3"></a>10-3</h3><figure class="highlight plaintext"><figcaption><span>bush</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs [c]">#include &lt;stdio.h&gt;<br><br>void sort3(int *n1,int *n2,int *n3)<br>&#123;<br>int temp;<br><br>    if(*n1&gt;*n2)<br>    &#123;<br>        temp=*n1;<br>        *n1=*n2;<br>        *n2=temp;<br>    &#125;<br> <br>    if(*n1&gt;*n3)<br>    &#123;<br>        temp=*n1;<br>        *n1=*n3;<br>        *n3=temp;<br>    &#125;<br> <br>    if(*n2&gt;*n3)<br>    &#123;<br>        temp=*n2;<br>        *n2=*n3;<br>        *n3=temp;<br>    &#125;<br>&#125;<br><br><br>int main()<br>&#123;<br>int a,b,c;<br><br>    printf(&quot;整数a：&quot;);scanf(&quot;%d&quot;,&amp;a);<br>    printf(&quot;整数b：&quot;);scanf(&quot;%d&quot;,&amp;b);<br>    printf(&quot;整数c：&quot;);scanf(&quot;%d&quot;,&amp;c);<br> <br>    sort3(&amp;a,&amp;b,&amp;c);<br> <br>    printf(&quot;a = %d\nb = %d\nc = %d\n&quot;,a,b,c);<br> <br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github+Zeabur搭建博客</title>
    <link href="/2024/09/15/hexo+github/"/>
    <url>/2024/09/15/hexo+github/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>看了一个学长的发出的博客，自己也想弄一个博客，但经历十分的曲折，挑灯夜战到了五点，本来是一件很简单的事，但是总有些小毛病，<br>所以我想总结我的经历，可以给别人一个起到帮助的作用。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li><a href="https://nodejs.org/">Node.js  必需的环境 安装最新版Node.js</a></li><li><a href="http://git-scm.com/">git 必需的环境 版本控制，管理代码</a></li><li><a href="https://npmmirror.com/">npmmirror 源淘宝NPM镜像源</a></li><li><a href="https://hexo.io/"> Hexo 博客官网,可以查找更多主题</a></li><li><a href="http://localhost:4000/2024/07/31/AI%20era/Hexo/GitHub.conm>">Github 需要有一个GitHub账号，用来保存你的代码。</a></li><li><a href="https://code.visualstudio.com/">Vscode 方便后续操作非必需</a></li></ul><p>如果github进不去的话，就自行上网找找如何修改DNS,并且改成阿里云的，或者可以下载个加速器给github加速一下，网上的方法有很多，就不仔细说了。</p><h2 id="正式安装hexo"><a href="#正式安装hexo" class="headerlink" title="正式安装hexo"></a>正式安装hexo</h2><p>首先检查一下环境有没有出错了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bush">node -v<br>npm -v<br>git -v<br>cnpm -v (这个可有可无）<br></code></pre></td></tr></table></figure><p>安装hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bush">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>如果网速不太行的话,选择下面其中一种方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bush">npm install -g cnpm --registry=https://registry.npmmirror.com<br>cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><h2 id="自选合适的目录，新建文件夹-初始化hexo项目"><a href="#自选合适的目录，新建文件夹-初始化hexo项目" class="headerlink" title="自选合适的目录，新建文件夹,初始化hexo项目"></a>自选合适的目录，新建文件夹,初始化hexo项目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bush">cd floder <br>hexo init<br>cnpm install<br></code></pre></td></tr></table></figure><h2 id="选择并安装一个主题"><a href="#选择并安装一个主题" class="headerlink" title="选择并安装一个主题"></a>选择并安装一个主题</h2><ul><li>先选择一个hexo的主题，我用的是Fluid(也就是我疯狂出错的地方）- </li><li>访问主题的GitHub页面，可以选择下载压缩包，也可以用git下载,还可以用npm(cnpm)下载<br>详细的操作看<a href="https://hexo.fluid-dev.com/docs/">用户手册</a><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">-b</span> <span class="hljs-keyword">master</span> <span class="hljs-title">https</span>://github.com/fluid-dev/hexo-theme-fluid.git<br></code></pre></td></tr></table></figure></li><li>到最折磨人的地方了，首先要下载hexo-pagination moment hexo-util @adobe&#x2F;css-tools nunjucks 这几个插件，这该死的vscode<br>没有给出出错在哪，只给了渲染失败，官方文档也没有写出来，下载完后就首先找到根目录下的_config.yml文件，然后找到theme这个,改成下面这样<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bush">theme:fluid<br>#下载的指令是(后面也可以空格然后接着打其他插件的名字也行）： <br>cnpm install moment<br></code></pre></td></tr></table></figure>然后弄一个新的_config.fluid.yml文件在根目录，然后找到下载的主题，然后将主题里面的_config.yml文件中的内容复制到_config.fluid.yml上，<br>大概率是不会出错了，不同的主题操作不一样的，所以还是的仔细看官方文档</li></ul><h2 id="本地生成和预览"><a href="#本地生成和预览" class="headerlink" title="本地生成和预览"></a>本地生成和预览</h2><ul><li><p>清理缓存（最后每一次启动前都清一下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bush">hexo clean<br>#简写：hexo cl<br></code></pre></td></tr></table></figure></li><li><p>生成静态文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo <span class="hljs-selector-tag">g</span><br></code></pre></td></tr></table></figure></li><li><p>启动本地的服务器,在浏览器中访问<a href="http://localhost:4000查看效果。">http://localhost:4000查看效果。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bush">hexo s<br></code></pre></td></tr></table></figure></li></ul><p>如果前面的步骤都没有出错的话，恭喜你快要搭建一个属于自己的线上的blog了  </p><h2 id="推送或部署到GitHub"><a href="#推送或部署到GitHub" class="headerlink" title="推送或部署到GitHub"></a>推送或部署到GitHub</h2><ul><li><p>在github上创建一个仓库</p></li><li><p>安装hexo部署插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bush">官方源<br>npm install hexo-deployer-git --save<br>阿里源<br>cnpm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>配置Hexo部署信息，在_config.yml中规范写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bush">deploy:<br>type:git<br>repo:https://你的访问令牌@github.com/你的用户名/你的仓库名.git #直接复制你的仓库的网址就好了<br>branch:main<br></code></pre></td></tr></table></figure></li><li><p>推到Github:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bush">hexo d<br></code></pre></td></tr></table></figure></li></ul><h2 id="使用免费容器进行部署zeabur这个很简单的，我就不过说名了-自行上网找吧"><a href="#使用免费容器进行部署zeabur这个很简单的，我就不过说名了-自行上网找吧" class="headerlink" title="使用免费容器进行部署zeabur这个很简单的，我就不过说名了,自行上网找吧"></a>使用免费容器进行部署zeabur这个很简单的，我就不过说名了,自行上网找吧</h2><h2 id="一些提示和总结"><a href="#一些提示和总结" class="headerlink" title="一些提示和总结"></a>一些提示和总结</h2><p><strong>_post文件夹中必须要有一篇以上的md文件，不然的话，你的辛苦弄好的blog就要gg了（别问我是咋知道的</strong><br>其余的一些操作就看<a href="https://hexo.fluid-dev.com/docs/">官方文档</a>，如何写的blog的话,可以像htmll那样写，或者是markdown<br>如果以上步骤都没有出现差误，你应该是可以安装并且配置好你的blog的，并且别人可以通过网址来访问你的blog</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
